# ðŸ” FASE 2.3: Semantic Search

## BÃºsqueda SemÃ¡ntica para ClasificaciÃ³n de Mensajes

**Documento:** 2.3-SEMANTIC-SEARCH.md
**Fase:** 2 - Embeddings SemÃ¡nticos
**DuraciÃ³n estimada:** 1.5-2 semanas
**Dependencias:** 2.1 (Embedding Service), 2.2 (Vector Store)

---

## ðŸ“‹ Ãndice

1. [Objetivo](#objetivo)
2. [Arquitectura de BÃºsqueda](#arquitectura-de-bÃºsqueda)
3. [Algoritmos de ClasificaciÃ³n](#algoritmos-de-clasificaciÃ³n)
4. [ImplementaciÃ³n](#implementaciÃ³n)
5. [IntegraciÃ³n con LangGraph](#integraciÃ³n-con-langgraph)
6. [Checklist de ImplementaciÃ³n](#checklist-de-implementaciÃ³n)

---

## ðŸŽ¯ Objetivo

Implementar bÃºsqueda semÃ¡ntica para clasificar mensajes de usuarios por intenciÃ³n, encontrar FAQs relevantes, y detectar patrones similares - todo basado en significado en lugar de keywords.

### Casos de Uso

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SEMANTIC SEARCH USE CASES                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  1. INTENT CLASSIFICATION                                       â”‚
â”‚     User: "Me gustarÃ­a pedir hora"                              â”‚
â”‚                    â”‚                                             â”‚
â”‚                    â–¼                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚     â”‚ Semantic similarity to:                 â”‚                â”‚
â”‚     â”‚ â€¢ "quiero agendar cita" â†’ 0.94         â”‚                â”‚
â”‚     â”‚ â€¢ "reservar turno" â†’ 0.91              â”‚                â”‚
â”‚     â”‚ â€¢ "consulta de precios" â†’ 0.45         â”‚                â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                    â”‚                                             â”‚
â”‚                    â–¼                                             â”‚
â”‚     Intent: SCHEDULING (confidence: 0.94)                       â”‚
â”‚                                                                  â”‚
â”‚  2. FAQ RETRIEVAL                                               â”‚
â”‚     User: "Aceptan tarjeta?"                                    â”‚
â”‚                    â”‚                                             â”‚
â”‚                    â–¼                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚     â”‚ Similar FAQs found:                     â”‚                â”‚
â”‚     â”‚ â€¢ "Â¿QuÃ© formas de pago aceptan?" â†’ 0.89â”‚                â”‚
â”‚     â”‚ â€¢ "Â¿Puedo pagar en cuotas?" â†’ 0.76     â”‚                â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                                  â”‚
â”‚  3. DUPLICATE DETECTION                                         â”‚
â”‚     User: "Hola buenas tardes"                                  â”‚
â”‚                    â”‚                                             â”‚
â”‚                    â–¼                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚     â”‚ Similar to 47 previous greetings        â”‚                â”‚
â”‚     â”‚ Trigger: Use cached response            â”‚                â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ—ï¸ Arquitectura de BÃºsqueda

### Pipeline de BÃºsqueda SemÃ¡ntica

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SEMANTIC SEARCH PIPELINE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚     [User Message]                                                 â”‚
â”‚          â”‚                                                          â”‚
â”‚          â–¼                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  1. PREPROCESS    â”‚                                             â”‚
â”‚  â”‚  - Clean text     â”‚                                             â”‚
â”‚  â”‚  - Normalize      â”‚                                             â”‚
â”‚  â”‚  - Extract lang   â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚            â”‚                                                        â”‚
â”‚            â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  2. EMBED         â”‚                                             â”‚
â”‚  â”‚  - Check cache    â”‚                                             â”‚
â”‚  â”‚  - Generate emb   â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚            â”‚                                                        â”‚
â”‚            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚            â–¼                  â–¼                  â–¼                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ 3a. PATTERN     â”‚ â”‚ 3b. DOCUMENT    â”‚ â”‚ 3c. HISTORY     â”‚      â”‚
â”‚  â”‚     SEARCH      â”‚ â”‚     SEARCH      â”‚ â”‚     SEARCH      â”‚      â”‚
â”‚  â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚      â”‚
â”‚  â”‚ Find similar    â”‚ â”‚ Find relevant   â”‚ â”‚ Find similar    â”‚      â”‚
â”‚  â”‚ intent patterns â”‚ â”‚ FAQs, policies  â”‚ â”‚ past messages   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚           â”‚                   â”‚                   â”‚                 â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                               â”‚                                     â”‚
â”‚                               â–¼                                     â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                    â”‚  4. COMBINE       â”‚                           â”‚
â”‚                    â”‚  - Weight scores  â”‚                           â”‚
â”‚                    â”‚  - Apply thresholdâ”‚                           â”‚
â”‚                    â”‚  - Rank results   â”‚                           â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                              â”‚                                      â”‚
â”‚                              â–¼                                      â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                    â”‚  5. CLASSIFY      â”‚                           â”‚
â”‚                    â”‚  - Intent         â”‚                           â”‚
â”‚                    â”‚  - Confidence     â”‚                           â”‚
â”‚                    â”‚  - Context docs   â”‚                           â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                              â”‚                                      â”‚
â”‚                              â–¼                                      â”‚
â”‚                    [Classification Result]                          â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Componentes

```
src/features/ai/semantic/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ semantic-search.service.ts      # ðŸ†• Servicio principal
â”‚   â”œâ”€â”€ intent-classifier.service.ts    # ðŸ†• Clasificador de intenciones
â”‚   â””â”€â”€ context-retriever.service.ts    # ðŸ†• RecuperaciÃ³n de contexto
â”œâ”€â”€ types/
â”‚   â””â”€â”€ semantic.types.ts               # ðŸ†• Tipos
â””â”€â”€ utils/
    â””â”€â”€ ranking.utils.ts                # ðŸ†• Utilidades de ranking
```

---

## ðŸ“ Algoritmos de ClasificaciÃ³n

### 1. Intent Classification por Similitud

```typescript
/**
 * Intent Classification Algorithm
 *
 * 1. Pre-compute embeddings for canonical intent examples
 * 2. Compare incoming message to all intent embeddings
 * 3. Use k-NN voting with similarity threshold
 * 4. Return top intent with confidence score
 */

interface IntentExample {
  intent: string;
  examples: string[];
  embeddings: number[][];
}

function classifyIntent(
  queryEmbedding: number[],
  intentExamples: IntentExample[],
  k: number = 3,
  threshold: number = 0.7
): { intent: string; confidence: number } {
  // Find k nearest neighbors across all intents
  const candidates = intentExamples.flatMap(ie =>
    ie.embeddings.map(emb => ({
      intent: ie.intent,
      similarity: cosineSimilarity(queryEmbedding, emb),
    }))
  );

  // Filter by threshold and sort
  const topK = candidates
    .filter(c => c.similarity >= threshold)
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, k);

  if (topK.length === 0) {
    return { intent: 'unknown', confidence: 0 };
  }

  // Vote counting with similarity weighting
  const votes: Record<string, number> = {};
  for (const candidate of topK) {
    votes[candidate.intent] = (votes[candidate.intent] || 0) + candidate.similarity;
  }

  // Find winner
  const winner = Object.entries(votes)
    .sort((a, b) => b[1] - a[1])[0];

  return {
    intent: winner[0],
    confidence: winner[1] / topK.length,
  };
}
```

### 2. Reciprocal Rank Fusion (RRF)

```typescript
/**
 * RRF combines multiple ranking lists into a single ranking
 * Formula: score(d) = Î£ 1 / (k + rank_i(d))
 * where k is typically 60
 */

interface RRFConfig {
  k: number;  // Constant (usually 60)
  weights: Record<string, number>;  // Source weights
}

function reciprocalRankFusion<T>(
  rankings: Record<string, Array<{ item: T; score: number }>>,
  config: RRFConfig = { k: 60, weights: {} }
): Array<{ item: T; score: number }> {
  const scores = new Map<T, number>();
  const k = config.k;

  for (const [source, ranking] of Object.entries(rankings)) {
    const weight = config.weights[source] ?? 1;

    ranking.forEach((result, rank) => {
      const rrfScore = weight / (k + rank + 1);
      const currentScore = scores.get(result.item) ?? 0;
      scores.set(result.item, currentScore + rrfScore);
    });
  }

  return Array.from(scores.entries())
    .map(([item, score]) => ({ item, score }))
    .sort((a, b) => b.score - a.score);
}
```

### 3. Re-ranking con Cross-Encoder (Opcional)

```typescript
/**
 * Two-stage retrieval:
 * 1. Fast bi-encoder (embeddings) for candidate retrieval
 * 2. Slow cross-encoder for precise re-ranking of top candidates
 */

async function rerank(
  query: string,
  candidates: string[],
  model: string = 'cross-encoder/ms-marco-MiniLM-L-6-v2'
): Promise<Array<{ text: string; score: number }>> {
  // In production, call a cross-encoder API or local model
  // This is a placeholder showing the concept
  const pairs = candidates.map(c => [query, c]);

  // Cross-encoder scores query-document pairs directly
  const scores = await crossEncoderScore(pairs, model);

  return candidates
    .map((text, i) => ({ text, score: scores[i] }))
    .sort((a, b) => b.score - a.score);
}
```

---

## ðŸ’» ImplementaciÃ³n

### Archivo: `src/features/ai/semantic/types/semantic.types.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Semantic Search Types
// Tipos para bÃºsqueda semÃ¡ntica y clasificaciÃ³n
// =====================================================

export type Intent =
  | 'scheduling'      // Agendar, reservar, citas
  | 'inquiry'         // Preguntas, informaciÃ³n
  | 'complaint'       // Quejas, problemas
  | 'feedback'        // Comentarios positivos
  | 'pricing'         // Precios, costos
  | 'hours'           // Horarios
  | 'location'        // UbicaciÃ³n, direcciones
  | 'cancellation'    // Cancelar, modificar
  | 'confirmation'    // Confirmar
  | 'greeting'        // Saludos
  | 'farewell'        // Despedidas
  | 'unknown';        // No clasificado

export interface IntentDefinition {
  intent: Intent;
  label: string;
  description: string;
  examples: string[];
  priority: number;
  requiresHuman: boolean;
}

export interface ClassificationResult {
  intent: Intent;
  confidence: number;
  secondaryIntents: Array<{ intent: Intent; confidence: number }>;
  matchedExamples: string[];
  processingTimeMs: number;
}

export interface SemanticSearchOptions {
  tenant_id: string;
  sources?: ('patterns' | 'documents' | 'history')[];
  patternTypes?: string[];
  documentTypes?: string[];
  limit?: number;
  threshold?: number;
  includeMetadata?: boolean;
}

export interface SemanticSearchResult<T = unknown> {
  item: T;
  source: 'patterns' | 'documents' | 'history';
  similarity: number;
  metadata?: Record<string, unknown>;
}

export interface ContextDocument {
  title: string;
  content: string;
  type: string;
  relevanceScore: number;
  source: string;
}

export interface ClassificationContext {
  relevantDocuments: ContextDocument[];
  similarMessages: Array<{
    text: string;
    response: string;
    intent: Intent;
  }>;
  suggestedResponse?: string;
}

export interface SemanticAnalysisResult {
  classification: ClassificationResult;
  context: ClassificationContext;
  embeddings: {
    query: number[];
    cached: boolean;
  };
}
```

### Archivo: `src/features/ai/semantic/services/intent-classifier.service.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Intent Classifier Service
// Clasificador de intenciones basado en embeddings
// =====================================================

import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { EmbeddingService, embeddingService } from '../../embeddings/services/embedding.service';
import { cosineSimilarity } from '../../embeddings/utils/vector-utils';
import {
  Intent,
  IntentDefinition,
  ClassificationResult,
} from '../types/semantic.types';

// ==================== Intent Definitions ====================

export const INTENT_DEFINITIONS: IntentDefinition[] = [
  {
    intent: 'scheduling',
    label: 'Agendamiento',
    description: 'Usuario quiere agendar, reservar o programar una cita',
    examples: [
      'Quiero agendar una cita',
      'Me gustarÃ­a reservar hora',
      'Puedo pedir turno para maÃ±ana',
      'Necesito una cita con el doctor',
      'Tienen disponibilidad para esta semana',
      'Quiero hacer una reserva',
      'Puedo agendar para el viernes',
      'Necesito programar una consulta',
    ],
    priority: 1,
    requiresHuman: false,
  },
  {
    intent: 'inquiry',
    label: 'Consulta',
    description: 'Usuario tiene una pregunta general',
    examples: [
      'Quisiera informaciÃ³n sobre sus servicios',
      'QuÃ© tratamientos ofrecen',
      'Me pueden explicar cÃ³mo funciona',
      'Tengo una pregunta',
      'CuÃ¡les son los requisitos',
      'QuÃ© incluye el servicio',
      'Me pueden dar mÃ¡s detalles',
    ],
    priority: 2,
    requiresHuman: false,
  },
  {
    intent: 'pricing',
    label: 'Precios',
    description: 'Usuario pregunta por precios o costos',
    examples: [
      'CuÃ¡nto cuesta una consulta',
      'CuÃ¡l es el precio',
      'QuÃ© valor tiene',
      'CuÃ¡nto cobran',
      'Tienen lista de precios',
      'Es muy caro',
      'Hay algÃºn descuento',
      'CuÃ¡les son las tarifas',
      'Aceptan tarjeta',
      'Puedo pagar en cuotas',
    ],
    priority: 2,
    requiresHuman: false,
  },
  {
    intent: 'hours',
    label: 'Horarios',
    description: 'Usuario pregunta por horarios de atenciÃ³n',
    examples: [
      'CuÃ¡l es su horario',
      'A quÃ© hora abren',
      'Hasta quÃ© hora atienden',
      'EstÃ¡n abiertos los domingos',
      'Trabajan los feriados',
      'Horario de atenciÃ³n',
      'A quÃ© hora cierran',
    ],
    priority: 2,
    requiresHuman: false,
  },
  {
    intent: 'location',
    label: 'UbicaciÃ³n',
    description: 'Usuario pregunta por ubicaciÃ³n o direcciones',
    examples: [
      'DÃ³nde estÃ¡n ubicados',
      'CuÃ¡l es la direcciÃ³n',
      'CÃ³mo llego',
      'Tienen estacionamiento',
      'Cerca de quÃ© metro estÃ¡n',
      'En quÃ© comuna estÃ¡n',
      'Me pueden enviar la ubicaciÃ³n',
    ],
    priority: 2,
    requiresHuman: false,
  },
  {
    intent: 'cancellation',
    label: 'CancelaciÃ³n',
    description: 'Usuario quiere cancelar o modificar una cita',
    examples: [
      'Quiero cancelar mi cita',
      'Necesito reagendar',
      'Puedo cambiar la hora',
      'No voy a poder ir',
      'Tengo que cancelar',
      'Modificar mi reserva',
      'Cambiar fecha de cita',
    ],
    priority: 1,
    requiresHuman: false,
  },
  {
    intent: 'complaint',
    label: 'Queja',
    description: 'Usuario tiene una queja o problema',
    examples: [
      'Tengo un problema',
      'Quiero hacer un reclamo',
      'No estoy satisfecho',
      'Mala experiencia',
      'Quiero hablar con un supervisor',
      'Esto es inaceptable',
      'Me trataron muy mal',
      'El servicio fue pÃ©simo',
    ],
    priority: 1,
    requiresHuman: true,
  },
  {
    intent: 'feedback',
    label: 'Feedback',
    description: 'Usuario da feedback positivo',
    examples: [
      'Excelente servicio',
      'Muy buena atenciÃ³n',
      'Estoy muy contento',
      'Muchas gracias',
      'Los recomiendo',
      'Gran trabajo',
      'Muy satisfecho',
    ],
    priority: 3,
    requiresHuman: false,
  },
  {
    intent: 'greeting',
    label: 'Saludo',
    description: 'Usuario saluda',
    examples: [
      'Hola',
      'Buenos dÃ­as',
      'Buenas tardes',
      'Buenas noches',
      'Hola buenas',
      'QuÃ© tal',
      'Hey',
    ],
    priority: 4,
    requiresHuman: false,
  },
  {
    intent: 'farewell',
    label: 'Despedida',
    description: 'Usuario se despide',
    examples: [
      'AdiÃ³s',
      'Hasta luego',
      'Chao',
      'Gracias, eso es todo',
      'Nos vemos',
      'Hasta pronto',
      'Bye',
    ],
    priority: 4,
    requiresHuman: false,
  },
  {
    intent: 'confirmation',
    label: 'ConfirmaciÃ³n',
    description: 'Usuario confirma algo',
    examples: [
      'SÃ­',
      'Confirmo',
      'De acuerdo',
      'Perfecto',
      'EstÃ¡ bien',
      'Ok',
      'Correcto',
      'AsÃ­ es',
    ],
    priority: 3,
    requiresHuman: false,
  },
];

// ==================== Service ====================

interface CachedIntentEmbeddings {
  intent: Intent;
  embeddings: number[][];
  examples: string[];
}

export class IntentClassifierService {
  private supabase: SupabaseClient;
  private embeddingService: EmbeddingService;
  private intentEmbeddings: CachedIntentEmbeddings[] | null = null;
  private initPromise: Promise<void> | null = null;

  constructor(embeddingSvc?: EmbeddingService) {
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
    this.embeddingService = embeddingSvc ?? embeddingService;
  }

  /**
   * Initialize intent embeddings (lazy loaded)
   */
  private async initialize(): Promise<void> {
    if (this.intentEmbeddings) return;
    if (this.initPromise) return this.initPromise;

    this.initPromise = this.loadIntentEmbeddings();
    await this.initPromise;
  }

  private async loadIntentEmbeddings(): Promise<void> {
    console.log('[IntentClassifier] Loading intent embeddings...');

    const allExamples: string[] = [];
    const intentMap: Map<number, Intent> = new Map();

    let index = 0;
    for (const def of INTENT_DEFINITIONS) {
      for (const example of def.examples) {
        allExamples.push(example);
        intentMap.set(index, def.intent);
        index++;
      }
    }

    // Batch generate embeddings for all examples
    const batchResult = await this.embeddingService.embedBatch({
      texts: allExamples,
    });

    // Group by intent
    const intentEmbeddingsMap = new Map<Intent, { embeddings: number[][]; examples: string[] }>();

    batchResult.results.forEach((result, i) => {
      const intent = intentMap.get(i)!;
      const existing = intentEmbeddingsMap.get(intent) || { embeddings: [], examples: [] };
      existing.embeddings.push(result.embedding);
      existing.examples.push(result.text);
      intentEmbeddingsMap.set(intent, existing);
    });

    this.intentEmbeddings = Array.from(intentEmbeddingsMap.entries()).map(([intent, data]) => ({
      intent,
      embeddings: data.embeddings,
      examples: data.examples,
    }));

    console.log(`[IntentClassifier] Loaded ${this.intentEmbeddings.length} intent categories`);
  }

  /**
   * Classify user message intent
   */
  async classify(
    message: string,
    options: {
      k?: number;
      threshold?: number;
      returnSecondary?: boolean;
    } = {}
  ): Promise<ClassificationResult> {
    const startTime = Date.now();
    const { k = 5, threshold = 0.65, returnSecondary = true } = options;

    await this.initialize();

    // Generate embedding for query
    const queryResult = await this.embeddingService.embed({ text: message });
    const queryEmbedding = queryResult.embedding;

    // Find similar examples across all intents
    const candidates: Array<{
      intent: Intent;
      similarity: number;
      example: string;
    }> = [];

    for (const intentData of this.intentEmbeddings!) {
      for (let i = 0; i < intentData.embeddings.length; i++) {
        const similarity = cosineSimilarity(queryEmbedding, intentData.embeddings[i]);
        if (similarity >= threshold) {
          candidates.push({
            intent: intentData.intent,
            similarity,
            example: intentData.examples[i],
          });
        }
      }
    }

    // Sort by similarity
    candidates.sort((a, b) => b.similarity - a.similarity);

    // Take top k
    const topK = candidates.slice(0, k);

    if (topK.length === 0) {
      return {
        intent: 'unknown',
        confidence: 0,
        secondaryIntents: [],
        matchedExamples: [],
        processingTimeMs: Date.now() - startTime,
      };
    }

    // Weighted voting
    const intentScores: Record<Intent, { score: number; count: number }> = {} as Record<Intent, { score: number; count: number }>;

    for (const candidate of topK) {
      if (!intentScores[candidate.intent]) {
        intentScores[candidate.intent] = { score: 0, count: 0 };
      }
      intentScores[candidate.intent].score += candidate.similarity;
      intentScores[candidate.intent].count += 1;
    }

    // Calculate weighted confidence and sort
    const sortedIntents = Object.entries(intentScores)
      .map(([intent, data]) => ({
        intent: intent as Intent,
        confidence: data.score / topK.length,
        avgSimilarity: data.score / data.count,
      }))
      .sort((a, b) => b.confidence - a.confidence);

    const primaryIntent = sortedIntents[0];
    const secondaryIntents = returnSecondary
      ? sortedIntents.slice(1, 3).map(s => ({ intent: s.intent, confidence: s.confidence }))
      : [];

    const matchedExamples = topK
      .filter(c => c.intent === primaryIntent.intent)
      .slice(0, 3)
      .map(c => c.example);

    return {
      intent: primaryIntent.intent,
      confidence: primaryIntent.confidence,
      secondaryIntents,
      matchedExamples,
      processingTimeMs: Date.now() - startTime,
    };
  }

  /**
   * Add custom intent examples for a tenant
   */
  async addCustomExamples(
    tenantId: string,
    intent: Intent,
    examples: string[]
  ): Promise<void> {
    // Generate embeddings
    const batchResult = await this.embeddingService.embedBatch({ texts: examples });

    // Store in database
    const records = examples.map((example, i) => ({
      tenant_id: tenantId,
      intent,
      example,
      embedding: `[${batchResult.results[i].embedding.join(',')}]`,
    }));

    await this.supabase.from('ai_intent_examples').upsert(records);
  }

  /**
   * Get intent definition
   */
  getIntentDefinition(intent: Intent): IntentDefinition | undefined {
    return INTENT_DEFINITIONS.find(d => d.intent === intent);
  }

  /**
   * Check if intent requires human intervention
   */
  requiresHuman(intent: Intent): boolean {
    const def = this.getIntentDefinition(intent);
    return def?.requiresHuman ?? false;
  }
}

export const intentClassifier = new IntentClassifierService();
```

### Archivo: `src/features/ai/semantic/services/semantic-search.service.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Semantic Search Service
// Servicio unificado de bÃºsqueda semÃ¡ntica
// =====================================================

import {
  SemanticSearchOptions,
  SemanticSearchResult,
  SemanticAnalysisResult,
  ContextDocument,
  ClassificationContext,
} from '../types/semantic.types';
import { VectorStoreService, vectorStore } from '../../embeddings/services/vector-store.service';
import { EmbeddingService, embeddingService } from '../../embeddings/services/embedding.service';
import { IntentClassifierService, intentClassifier } from './intent-classifier.service';
import { reciprocalRankFusion } from '../utils/ranking.utils';

interface SemanticSearchConfig {
  defaultLimit: number;
  defaultThreshold: number;
  maxContextDocs: number;
  maxSimilarMessages: number;
}

const DEFAULT_CONFIG: SemanticSearchConfig = {
  defaultLimit: 10,
  defaultThreshold: 0.6,
  maxContextDocs: 5,
  maxSimilarMessages: 3,
};

export class SemanticSearchService {
  private vectorStore: VectorStoreService;
  private embeddingService: EmbeddingService;
  private intentClassifier: IntentClassifierService;
  private config: SemanticSearchConfig;

  constructor(config: Partial<SemanticSearchConfig> = {}) {
    this.vectorStore = vectorStore;
    this.embeddingService = embeddingService;
    this.intentClassifier = intentClassifier;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Perform comprehensive semantic analysis
   */
  async analyze(
    query: string,
    tenantId: string
  ): Promise<SemanticAnalysisResult> {
    // 1. Generate query embedding
    const embedResult = await this.embeddingService.embed({ text: query });

    // 2. Classify intent
    const classification = await this.intentClassifier.classify(query);

    // 3. Retrieve context in parallel
    const [documents, similarMessages] = await Promise.all([
      this.searchDocuments(query, tenantId, classification.intent),
      this.findSimilarHistoricalMessages(query, tenantId),
    ]);

    // 4. Build context
    const context: ClassificationContext = {
      relevantDocuments: documents.slice(0, this.config.maxContextDocs),
      similarMessages: similarMessages.slice(0, this.config.maxSimilarMessages),
    };

    // 5. Suggest response if high-confidence similar message exists
    if (similarMessages.length > 0 && similarMessages[0].response) {
      const topMatch = similarMessages[0];
      if (topMatch.intent === classification.intent) {
        context.suggestedResponse = topMatch.response;
      }
    }

    return {
      classification,
      context,
      embeddings: {
        query: embedResult.embedding,
        cached: embedResult.cached,
      },
    };
  }

  /**
   * Search across multiple sources with RRF
   */
  async search(
    query: string,
    options: SemanticSearchOptions
  ): Promise<SemanticSearchResult[]> {
    const sources = options.sources ?? ['patterns', 'documents'];
    const rankings: Record<string, SemanticSearchResult[]> = {};

    // Search each source in parallel
    const searchPromises: Promise<void>[] = [];

    if (sources.includes('patterns')) {
      searchPromises.push(
        this.vectorStore
          .searchSimilarPatterns(query, {
            tenant_id: options.tenant_id,
            pattern_types: options.patternTypes,
            limit: options.limit ?? this.config.defaultLimit,
            threshold: options.threshold ?? this.config.defaultThreshold,
          })
          .then(results => {
            rankings['patterns'] = results.map(r => ({
              item: r.item,
              source: 'patterns' as const,
              similarity: r.similarity,
            }));
          })
      );
    }

    if (sources.includes('documents')) {
      searchPromises.push(
        this.vectorStore
          .searchSimilarDocuments(query, {
            tenant_id: options.tenant_id,
            document_types: options.documentTypes,
            limit: options.limit ?? this.config.defaultLimit,
            threshold: options.threshold ?? this.config.defaultThreshold,
          })
          .then(results => {
            rankings['documents'] = results.map(r => ({
              item: r.item,
              source: 'documents' as const,
              similarity: r.similarity,
              metadata: options.includeMetadata ? r.item.metadata : undefined,
            }));
          })
      );
    }

    if (sources.includes('history')) {
      searchPromises.push(
        this.vectorStore
          .findSimilarMessages(query, {
            tenant_id: options.tenant_id,
            limit: options.limit ?? this.config.defaultLimit,
            threshold: options.threshold ?? 0.85, // Higher threshold for history
          })
          .then(results => {
            rankings['history'] = results.map(r => ({
              item: r.item,
              source: 'history' as const,
              similarity: r.similarity,
            }));
          })
      );
    }

    await Promise.all(searchPromises);

    // Combine with RRF if multiple sources
    if (Object.keys(rankings).length > 1) {
      const combined = reciprocalRankFusion(rankings, {
        k: 60,
        weights: {
          patterns: 1.2,
          documents: 1.0,
          history: 0.8,
        },
      });

      return combined.slice(0, options.limit ?? this.config.defaultLimit);
    }

    // Single source, return directly
    const singleSource = Object.values(rankings)[0] ?? [];
    return singleSource.slice(0, options.limit ?? this.config.defaultLimit);
  }

  /**
   * Search for relevant documents
   */
  async searchDocuments(
    query: string,
    tenantId: string,
    intent?: string
  ): Promise<ContextDocument[]> {
    // Determine relevant document types based on intent
    let documentTypes: string[] | undefined;

    if (intent) {
      documentTypes = this.getRelevantDocumentTypes(intent);
    }

    const results = await this.vectorStore.searchSimilarDocuments(query, {
      tenant_id: tenantId,
      document_types: documentTypes,
      limit: this.config.maxContextDocs * 2,
      threshold: 0.5,
    });

    return results.map(r => ({
      title: r.item.document_title,
      content: r.item.document_content,
      type: r.item.document_type,
      relevanceScore: r.similarity,
      source: 'vector_store',
    }));
  }

  /**
   * Find similar historical messages with their responses
   */
  async findSimilarHistoricalMessages(
    query: string,
    tenantId: string
  ): Promise<Array<{ text: string; response: string; intent: string }>> {
    const results = await this.vectorStore.findSimilarMessages(query, {
      tenant_id: tenantId,
      limit: this.config.maxSimilarMessages * 2,
      threshold: 0.85,
    });

    // Filter to user messages only and get their responses
    const userMessages = results.filter(r => r.item.message_role === 'user');

    // For each user message, find the assistant response
    const withResponses: Array<{ text: string; response: string; intent: string }> = [];

    for (const msg of userMessages.slice(0, this.config.maxSimilarMessages)) {
      // Query for the assistant response in the same conversation
      const { data: response } = await this.vectorStore['supabase']
        .from('ai_message_embeddings')
        .select('message_text')
        .eq('conversation_id', msg.item.conversation_id)
        .eq('message_role', 'assistant')
        .gt('created_at', msg.item.created_at)
        .order('created_at', { ascending: true })
        .limit(1)
        .single();

      if (response) {
        withResponses.push({
          text: msg.item.message_text,
          response: response.message_text,
          intent: msg.item.classified_intent || 'unknown',
        });
      }
    }

    return withResponses;
  }

  /**
   * Detect if message is a duplicate/very similar to recent messages
   */
  async detectDuplicate(
    query: string,
    tenantId: string,
    conversationId?: string,
    timeWindowMinutes: number = 5
  ): Promise<{ isDuplicate: boolean; similarity: number; originalMessageId?: string }> {
    const results = await this.vectorStore.findSimilarMessages(query, {
      tenant_id: tenantId,
      limit: 1,
      threshold: 0.95, // Very high threshold for duplicates
    });

    if (results.length === 0) {
      return { isDuplicate: false, similarity: 0 };
    }

    const match = results[0];

    // Check if within time window
    if (match.item.message_timestamp) {
      const messageTime = new Date(match.item.message_timestamp);
      const cutoff = new Date(Date.now() - timeWindowMinutes * 60 * 1000);

      if (messageTime < cutoff) {
        return { isDuplicate: false, similarity: match.similarity };
      }
    }

    // Check if same conversation (if specified)
    if (conversationId && match.item.conversation_id !== conversationId) {
      return { isDuplicate: false, similarity: match.similarity };
    }

    return {
      isDuplicate: true,
      similarity: match.similarity,
      originalMessageId: match.item.message_id,
    };
  }

  // ==================== Private Helpers ====================

  private getRelevantDocumentTypes(intent: string): string[] | undefined {
    const mapping: Record<string, string[]> = {
      scheduling: ['service', 'policy'],
      pricing: ['service', 'pricing'],
      hours: ['policy', 'faq'],
      location: ['faq'],
      inquiry: ['faq', 'service'],
      complaint: ['policy'],
    };

    return mapping[intent];
  }
}

export const semanticSearch = new SemanticSearchService();
```

### Archivo: `src/features/ai/semantic/utils/ranking.utils.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Ranking Utilities
// Utilidades para combinar y rankear resultados
// =====================================================

/**
 * Reciprocal Rank Fusion
 * Combines multiple ranking lists into one
 */
export function reciprocalRankFusion<T>(
  rankings: Record<string, Array<{ item: T; similarity: number }>>,
  config: { k: number; weights: Record<string, number> } = { k: 60, weights: {} }
): Array<{ item: T; similarity: number; source: string }> {
  const scores = new Map<string, { item: T; score: number; sources: string[] }>();
  const k = config.k;

  for (const [source, ranking] of Object.entries(rankings)) {
    const weight = config.weights[source] ?? 1;

    ranking.forEach((result, rank) => {
      const key = JSON.stringify(result.item);
      const rrfScore = weight / (k + rank + 1);

      const existing = scores.get(key);
      if (existing) {
        existing.score += rrfScore;
        existing.sources.push(source);
      } else {
        scores.set(key, {
          item: result.item,
          score: rrfScore,
          sources: [source],
        });
      }
    });
  }

  return Array.from(scores.values())
    .map(({ item, score, sources }) => ({
      item,
      similarity: score,
      source: sources.join(','),
    }))
    .sort((a, b) => b.similarity - a.similarity);
}

/**
 * Normalize scores to 0-1 range
 */
export function normalizeScores<T extends { score: number }>(
  items: T[]
): Array<T & { normalizedScore: number }> {
  if (items.length === 0) return [];

  const scores = items.map(i => i.score);
  const min = Math.min(...scores);
  const max = Math.max(...scores);
  const range = max - min || 1;

  return items.map(item => ({
    ...item,
    normalizedScore: (item.score - min) / range,
  }));
}

/**
 * Apply diversity penalty to avoid similar results
 */
export function diversityRerank<T>(
  items: Array<{ item: T; score: number; embedding?: number[] }>,
  lambda: number = 0.5,
  similarityFn?: (a: T, b: T) => number
): Array<{ item: T; score: number }> {
  if (items.length <= 1) return items;

  const result: Array<{ item: T; score: number }> = [];
  const remaining = [...items];

  // Greedy selection with MMR (Maximal Marginal Relevance)
  while (remaining.length > 0 && result.length < items.length) {
    let bestIdx = 0;
    let bestScore = -Infinity;

    for (let i = 0; i < remaining.length; i++) {
      const candidate = remaining[i];
      let maxSimilarityToSelected = 0;

      // Calculate max similarity to already selected items
      for (const selected of result) {
        const similarity = similarityFn
          ? similarityFn(candidate.item, selected.item)
          : 0;
        maxSimilarityToSelected = Math.max(maxSimilarityToSelected, similarity);
      }

      // MMR score: balance relevance and diversity
      const mmrScore = lambda * candidate.score - (1 - lambda) * maxSimilarityToSelected;

      if (mmrScore > bestScore) {
        bestScore = mmrScore;
        bestIdx = i;
      }
    }

    result.push(remaining[bestIdx]);
    remaining.splice(bestIdx, 1);
  }

  return result;
}

/**
 * Combine keyword and semantic scores
 */
export function hybridScore(
  semanticScore: number,
  keywordScore: number,
  alpha: number = 0.7
): number {
  return alpha * semanticScore + (1 - alpha) * keywordScore;
}
```

---

## ðŸ”— IntegraciÃ³n con LangGraph

### Modificar: `src/features/ai/graph/tistis-graph.ts`

```typescript
// Agregar imports
import { semanticSearch } from '../semantic/services/semantic-search.service';
import { SemanticAnalysisResult } from '../semantic/types/semantic.types';

// Modificar el nodo de clasificaciÃ³n
async function classificationNode(state: GraphState): Promise<GraphState> {
  const { tenantId, userMessage } = state;

  // Perform semantic analysis
  const analysis: SemanticAnalysisResult = await semanticSearch.analyze(
    userMessage,
    tenantId
  );

  // Store classification result
  const classification = analysis.classification;

  // Check if we have a high-confidence suggested response
  if (
    analysis.context.suggestedResponse &&
    classification.confidence > 0.9 &&
    classification.intent !== 'unknown'
  ) {
    // Use cached response path
    return {
      ...state,
      intent: classification.intent,
      confidence: classification.confidence,
      contextDocuments: analysis.context.relevantDocuments,
      suggestedResponse: analysis.context.suggestedResponse,
      nextNode: 'response_validator', // Validate before sending
    };
  }

  // Normal flow with context
  return {
    ...state,
    intent: classification.intent,
    confidence: classification.confidence,
    secondaryIntents: classification.secondaryIntents,
    contextDocuments: analysis.context.relevantDocuments,
    queryEmbedding: analysis.embeddings.query,
    nextNode: getNextNode(classification.intent),
  };
}

// Router decision based on semantic classification
function getNextNode(intent: string): string {
  const routing: Record<string, string> = {
    scheduling: 'booking_agent',
    cancellation: 'booking_agent',
    pricing: 'info_agent',
    inquiry: 'info_agent',
    hours: 'info_agent',
    location: 'info_agent',
    complaint: 'escalation_agent',
    feedback: 'feedback_agent',
    greeting: 'greeting_agent',
    farewell: 'farewell_agent',
    confirmation: 'confirmation_handler',
    unknown: 'fallback_agent',
  };

  return routing[intent] ?? 'fallback_agent';
}
```

---

## âœ… Checklist de ImplementaciÃ³n

```
â–¡ Paso 1: Crear Types
â”œâ”€â”€ [ ] Crear semantic.types.ts
â”œâ”€â”€ [ ] Definir Intent enum
â”œâ”€â”€ [ ] Definir interfaces de bÃºsqueda
â””â”€â”€ [ ] Exportar tipos

â–¡ Paso 2: Implementar Intent Classifier
â”œâ”€â”€ [ ] Crear intent-classifier.service.ts
â”œâ”€â”€ [ ] Definir INTENT_DEFINITIONS
â”œâ”€â”€ [ ] Implementar classify()
â”œâ”€â”€ [ ] Implementar lazy loading de embeddings
â”œâ”€â”€ [ ] Unit tests

â–¡ Paso 3: Implementar Semantic Search
â”œâ”€â”€ [ ] Crear semantic-search.service.ts
â”œâ”€â”€ [ ] Implementar analyze()
â”œâ”€â”€ [ ] Implementar search()
â”œâ”€â”€ [ ] Implementar detectDuplicate()
â””â”€â”€ [ ] Integration tests

â–¡ Paso 4: Implementar Ranking Utils
â”œâ”€â”€ [ ] Crear ranking.utils.ts
â”œâ”€â”€ [ ] Implementar RRF
â”œâ”€â”€ [ ] Implementar diversity rerank
â””â”€â”€ [ ] Unit tests

â–¡ Paso 5: Integrar con LangGraph
â”œâ”€â”€ [ ] Modificar classificationNode
â”œâ”€â”€ [ ] Actualizar routing
â”œâ”€â”€ [ ] Agregar context injection
â””â”€â”€ [ ] E2E tests

â–¡ Paso 6: ValidaciÃ³n
â”œâ”€â”€ [ ] Test con mensajes reales
â”œâ”€â”€ [ ] Medir accuracy vs regex
â”œâ”€â”€ [ ] Benchmark performance
â””â”€â”€ [ ] Documentar API
```

---

**Siguiente documento:** [2.4-PATTERN-MIGRATION.md](./2.4-PATTERN-MIGRATION.md)
