# ðŸ§ª FASE 2.5: Testing del Sistema de Embeddings

## Pruebas y ValidaciÃ³n del Sistema SemÃ¡ntico

**Documento:** 2.5-TESTING.md
**Fase:** 2 - Embeddings SemÃ¡nticos
**DuraciÃ³n estimada:** 1 semana
**Dependencias:** 2.1-2.4 (Todo el sistema de embeddings)

---

## ðŸ“‹ Ãndice

1. [Estrategia de Testing](#estrategia-de-testing)
2. [Unit Tests](#unit-tests)
3. [Integration Tests](#integration-tests)
4. [Accuracy Tests](#accuracy-tests)
5. [Performance Tests](#performance-tests)
6. [CI/CD Pipeline](#cicd-pipeline)
7. [Checklist de ValidaciÃ³n](#checklist-de-validaciÃ³n)

---

## ðŸŽ¯ Estrategia de Testing

### Cobertura por Componente

| Componente | Unit | Integration | E2E | Performance |
|------------|------|-------------|-----|-------------|
| Embedding Service | 95% | 90% | N/A | âœ“ |
| Vector Store | 90% | 95% | âœ“ | âœ“ |
| Semantic Search | 85% | 90% | âœ“ | âœ“ |
| Intent Classifier | 90% | 85% | âœ“ | âœ“ |
| Pattern Migration | 80% | 90% | âœ“ | N/A |

### MÃ©tricas Clave

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SUCCESS METRICS                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ACCURACY                                                        â”‚
â”‚  â”œâ”€â”€ Intent Classification: > 90%                               â”‚
â”‚  â”œâ”€â”€ Pattern Detection: > 85%                                   â”‚
â”‚  â””â”€â”€ FAQ Retrieval: > 80% relevance                             â”‚
â”‚                                                                  â”‚
â”‚  PERFORMANCE                                                     â”‚
â”‚  â”œâ”€â”€ Single Embedding: < 100ms                                  â”‚
â”‚  â”œâ”€â”€ Batch (100): < 2s                                          â”‚
â”‚  â”œâ”€â”€ Similarity Search: < 50ms                                  â”‚
â”‚  â””â”€â”€ Full Classification: < 200ms                               â”‚
â”‚                                                                  â”‚
â”‚  RELIABILITY                                                     â”‚
â”‚  â”œâ”€â”€ Cache Hit Rate: > 70%                                      â”‚
â”‚  â”œâ”€â”€ API Availability: > 99.5%                                  â”‚
â”‚  â””â”€â”€ Error Rate: < 1%                                           â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ”¬ Unit Tests

### Archivo: `src/features/ai/embeddings/__tests__/embedding.service.test.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Embedding Service Unit Tests
// =====================================================

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { EmbeddingService } from '../services/embedding.service';
import { EmbeddingCacheService } from '../services/embedding-cache.service';

// Mock OpenAI
vi.mock('openai', () => ({
  default: vi.fn().mockImplementation(() => ({
    embeddings: {
      create: vi.fn().mockResolvedValue({
        data: [{ embedding: new Array(1536).fill(0.1) }],
      }),
    },
  })),
}));

describe('EmbeddingService', () => {
  let service: EmbeddingService;
  let mockCache: EmbeddingCacheService;

  beforeEach(() => {
    mockCache = {
      get: vi.fn().mockResolvedValue(null),
      set: vi.fn().mockResolvedValue(undefined),
      getMany: vi.fn().mockResolvedValue(new Map()),
    } as unknown as EmbeddingCacheService;

    service = new EmbeddingService({}, undefined, mockCache);
  });

  describe('embed', () => {
    it('should generate embedding for text', async () => {
      const result = await service.embed({ text: 'Hello world' });

      expect(result.embedding).toHaveLength(1536);
      expect(result.model).toBe('text-embedding-3-small');
      expect(result.cached).toBe(false);
    });

    it('should return cached embedding if available', async () => {
      const cachedEmbedding = new Array(1536).fill(0.5);
      mockCache.get = vi.fn().mockResolvedValue(cachedEmbedding);

      const result = await service.embed({ text: 'Cached text' });

      expect(result.embedding).toEqual(cachedEmbedding);
      expect(result.cached).toBe(true);
    });

    it('should skip cache when skipCache is true', async () => {
      const cachedEmbedding = new Array(1536).fill(0.5);
      mockCache.get = vi.fn().mockResolvedValue(cachedEmbedding);

      const result = await service.embed({ text: 'Text', skipCache: true });

      expect(mockCache.get).not.toHaveBeenCalled();
      expect(result.cached).toBe(false);
    });

    it('should preprocess text before embedding', async () => {
      const result = await service.embed({
        text: '  Hello   world  https://example.com  ',
      });

      // Text should be cleaned
      expect(result.text).toBe('Hello world [URL]');
    });

    it('should store embedding in cache after generation', async () => {
      await service.embed({ text: 'New text' });

      expect(mockCache.set).toHaveBeenCalledWith(
        expect.any(String),
        'text-embedding-3-small',
        expect.any(Array)
      );
    });
  });

  describe('embedBatch', () => {
    it('should generate embeddings for multiple texts', async () => {
      const result = await service.embedBatch({
        texts: ['Text 1', 'Text 2', 'Text 3'],
      });

      expect(result.results).toHaveLength(3);
      expect(result.results[0].embedding).toHaveLength(1536);
    });

    it('should use cached embeddings when available', async () => {
      const cached = new Map([
        ['Text 1', new Array(1536).fill(0.5)],
      ]);
      mockCache.getMany = vi.fn().mockResolvedValue(cached);

      const result = await service.embedBatch({
        texts: ['Text 1', 'Text 2'],
      });

      expect(result.cacheHits).toBe(1);
      expect(result.results[0].cached).toBe(true);
      expect(result.results[1].cached).toBe(false);
    });

    it('should batch API calls efficiently', async () => {
      const texts = Array.from({ length: 150 }, (_, i) => `Text ${i}`);

      const result = await service.embedBatch({ texts });

      // Should split into 3 batches (50 each)
      expect(result.apiCalls).toBe(3);
    });
  });

  describe('getTokenCount', () => {
    it('should count tokens correctly', () => {
      const count = service.getTokenCount('Hello world, this is a test.');

      expect(count).toBeGreaterThan(0);
      expect(count).toBeLessThan(20);
    });

    it('should handle empty string', () => {
      const count = service.getTokenCount('');
      expect(count).toBe(0);
    });
  });
});
```

### Archivo: `src/features/ai/embeddings/__tests__/vector-utils.test.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Vector Utils Unit Tests
// =====================================================

import { describe, it, expect } from 'vitest';
import {
  cosineSimilarity,
  euclideanDistance,
  dotProduct,
  normalizeVector,
  averageVectors,
  findTopK,
} from '../utils/vector-utils';

describe('cosineSimilarity', () => {
  it('should return 1 for identical vectors', () => {
    const v = [1, 2, 3, 4, 5];
    expect(cosineSimilarity(v, v)).toBeCloseTo(1, 5);
  });

  it('should return 0 for orthogonal vectors', () => {
    const a = [1, 0];
    const b = [0, 1];
    expect(cosineSimilarity(a, b)).toBeCloseTo(0, 5);
  });

  it('should return -1 for opposite vectors', () => {
    const a = [1, 2, 3];
    const b = [-1, -2, -3];
    expect(cosineSimilarity(a, b)).toBeCloseTo(-1, 5);
  });

  it('should handle zero vectors', () => {
    const a = [0, 0, 0];
    const b = [1, 2, 3];
    expect(cosineSimilarity(a, b)).toBe(0);
  });

  it('should throw for different dimensions', () => {
    expect(() => cosineSimilarity([1, 2], [1, 2, 3])).toThrow();
  });
});

describe('euclideanDistance', () => {
  it('should return 0 for identical vectors', () => {
    const v = [1, 2, 3];
    expect(euclideanDistance(v, v)).toBe(0);
  });

  it('should calculate correct distance', () => {
    const a = [0, 0];
    const b = [3, 4];
    expect(euclideanDistance(a, b)).toBe(5); // 3-4-5 triangle
  });

  it('should be symmetric', () => {
    const a = [1, 2, 3];
    const b = [4, 5, 6];
    expect(euclideanDistance(a, b)).toBe(euclideanDistance(b, a));
  });
});

describe('dotProduct', () => {
  it('should calculate correct dot product', () => {
    const a = [1, 2, 3];
    const b = [4, 5, 6];
    expect(dotProduct(a, b)).toBe(32); // 1*4 + 2*5 + 3*6 = 32
  });

  it('should return 0 for orthogonal vectors', () => {
    const a = [1, 0, 0];
    const b = [0, 1, 0];
    expect(dotProduct(a, b)).toBe(0);
  });
});

describe('normalizeVector', () => {
  it('should normalize to unit length', () => {
    const v = [3, 4]; // Length = 5
    const normalized = normalizeVector(v);

    expect(normalized[0]).toBeCloseTo(0.6, 5);
    expect(normalized[1]).toBeCloseTo(0.8, 5);

    // Check magnitude is 1
    const magnitude = Math.sqrt(normalized[0] ** 2 + normalized[1] ** 2);
    expect(magnitude).toBeCloseTo(1, 5);
  });

  it('should handle zero vector', () => {
    const v = [0, 0, 0];
    const normalized = normalizeVector(v);
    expect(normalized).toEqual([0, 0, 0]);
  });
});

describe('averageVectors', () => {
  it('should calculate correct average', () => {
    const vectors = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9],
    ];
    const avg = averageVectors(vectors);

    expect(avg[0]).toBe(4);
    expect(avg[1]).toBe(5);
    expect(avg[2]).toBe(6);
  });

  it('should handle single vector', () => {
    const vectors = [[1, 2, 3]];
    expect(averageVectors(vectors)).toEqual([1, 2, 3]);
  });

  it('should handle empty input', () => {
    expect(averageVectors([])).toEqual([]);
  });
});

describe('findTopK', () => {
  it('should find top k most similar', () => {
    const query = [1, 0, 0];
    const candidates = [
      { embedding: [0.9, 0.1, 0], metadata: 'A' },
      { embedding: [0.5, 0.5, 0], metadata: 'B' },
      { embedding: [0, 1, 0], metadata: 'C' },
    ];

    const results = findTopK(query, candidates, 2, 'cosine');

    expect(results).toHaveLength(2);
    expect(results[0].metadata).toBe('A');
    expect(results[1].metadata).toBe('B');
  });

  it('should handle different metrics', () => {
    const query = [1, 0];
    const candidates = [{ embedding: [1, 0] }];

    const cosine = findTopK(query, candidates, 1, 'cosine')[0].score;
    const euclidean = findTopK(query, candidates, 1, 'euclidean')[0].score;
    const dot = findTopK(query, candidates, 1, 'dot_product')[0].score;

    expect(cosine).toBeCloseTo(1, 5);
    expect(euclidean).toBe(1); // 1 / (1 + 0) = 1
    expect(dot).toBe(1);
  });
});
```

### Archivo: `src/features/ai/semantic/__tests__/intent-classifier.test.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Intent Classifier Unit Tests
// =====================================================

import { describe, it, expect, beforeAll, vi } from 'vitest';
import { IntentClassifierService, INTENT_DEFINITIONS } from '../services/intent-classifier.service';

// Mock embedding service
vi.mock('../../embeddings/services/embedding.service', () => ({
  embeddingService: {
    embed: vi.fn().mockImplementation(({ text }) => ({
      embedding: generateMockEmbedding(text),
      cached: false,
      tokenCount: 10,
      model: 'text-embedding-3-small',
    })),
    embedBatch: vi.fn().mockImplementation(({ texts }) => ({
      results: texts.map((text: string) => ({
        embedding: generateMockEmbedding(text),
        cached: false,
        tokenCount: 10,
        model: 'text-embedding-3-small',
      })),
      totalTokens: texts.length * 10,
      cacheHits: 0,
      apiCalls: 1,
    })),
  },
  EmbeddingService: vi.fn(),
}));

// Generate deterministic mock embedding based on text
function generateMockEmbedding(text: string): number[] {
  const hash = text.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  const embedding = new Array(1536).fill(0);

  // Create a pattern based on hash
  for (let i = 0; i < 1536; i++) {
    embedding[i] = Math.sin(hash + i) * 0.5 + 0.5;
  }

  return embedding;
}

describe('IntentClassifierService', () => {
  let classifier: IntentClassifierService;

  beforeAll(async () => {
    classifier = new IntentClassifierService();
    // Wait for initialization
    await classifier.classify('test');
  });

  describe('classify', () => {
    it('should classify scheduling intent', async () => {
      const result = await classifier.classify('Quiero agendar una cita');

      expect(result.intent).toBe('scheduling');
      expect(result.confidence).toBeGreaterThan(0);
    });

    it('should classify pricing intent', async () => {
      const result = await classifier.classify('CuÃ¡nto cuesta la consulta');

      expect(result.intent).toBe('pricing');
    });

    it('should return secondary intents when requested', async () => {
      const result = await classifier.classify('Quiero saber el precio', {
        returnSecondary: true,
      });

      expect(result.secondaryIntents).toBeDefined();
      expect(Array.isArray(result.secondaryIntents)).toBe(true);
    });

    it('should return unknown for unrecognized input', async () => {
      const result = await classifier.classify('xyzabc123', {
        threshold: 0.9,
      });

      expect(result.intent).toBe('unknown');
      expect(result.confidence).toBe(0);
    });

    it('should include matched examples', async () => {
      const result = await classifier.classify('Hola buenas tardes');

      expect(result.matchedExamples).toBeDefined();
      expect(result.matchedExamples.length).toBeGreaterThanOrEqual(0);
    });

    it('should respect threshold parameter', async () => {
      const lowThreshold = await classifier.classify('test message', {
        threshold: 0.1,
      });
      const highThreshold = await classifier.classify('test message', {
        threshold: 0.99,
      });

      // Low threshold should find matches more easily
      if (lowThreshold.intent !== 'unknown') {
        expect(lowThreshold.confidence).toBeGreaterThan(0.1);
      }
    });

    it('should measure processing time', async () => {
      const result = await classifier.classify('Test message');

      expect(result.processingTimeMs).toBeGreaterThan(0);
    });
  });

  describe('getIntentDefinition', () => {
    it('should return definition for valid intent', () => {
      const def = classifier.getIntentDefinition('scheduling');

      expect(def).toBeDefined();
      expect(def?.intent).toBe('scheduling');
      expect(def?.examples).toBeInstanceOf(Array);
    });

    it('should return undefined for invalid intent', () => {
      const def = classifier.getIntentDefinition('invalid' as unknown as 'scheduling');

      expect(def).toBeUndefined();
    });
  });

  describe('requiresHuman', () => {
    it('should return true for complaint', () => {
      expect(classifier.requiresHuman('complaint')).toBe(true);
    });

    it('should return false for greeting', () => {
      expect(classifier.requiresHuman('greeting')).toBe(false);
    });
  });

  describe('INTENT_DEFINITIONS', () => {
    it('should have all required intents', () => {
      const requiredIntents = [
        'scheduling',
        'inquiry',
        'pricing',
        'complaint',
        'greeting',
      ];

      const definedIntents = INTENT_DEFINITIONS.map(d => d.intent);

      for (const intent of requiredIntents) {
        expect(definedIntents).toContain(intent);
      }
    });

    it('should have examples for all intents', () => {
      for (const def of INTENT_DEFINITIONS) {
        expect(def.examples.length).toBeGreaterThan(0);
      }
    });
  });
});
```

---

## ðŸ”— Integration Tests

### Archivo: `src/features/ai/embeddings/__tests__/vector-store.integration.test.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Vector Store Integration Tests
// =====================================================

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { createClient } from '@supabase/supabase-js';
import { VectorStoreService } from '../services/vector-store.service';
import { EmbeddingService } from '../services/embedding.service';

describe('VectorStoreService Integration', () => {
  let vectorStore: VectorStoreService;
  let supabase: ReturnType<typeof createClient>;
  let testTenantId: string;

  beforeAll(async () => {
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    // Create test tenant
    const { data } = await supabase
      .from('tenants')
      .insert({
        name: 'Vector Test Tenant',
        slug: `vector_test_${Date.now()}`,
        vertical: 'dental',
        plan: 'essentials',
      })
      .select()
      .single();

    testTenantId = data.id;
    vectorStore = new VectorStoreService();
  });

  afterAll(async () => {
    // Cleanup
    await vectorStore.deleteAllForTenant(testTenantId);
    await supabase.from('tenants').delete().eq('id', testTenantId);
  });

  beforeEach(async () => {
    // Clear embeddings before each test
    await vectorStore.deleteAllForTenant(testTenantId);
  });

  describe('Pattern Embeddings', () => {
    it('should store and retrieve pattern embedding', async () => {
      const stored = await vectorStore.storePatternEmbedding(
        testTenantId,
        'scheduling',
        'Quiero agendar una cita'
      );

      expect(stored.tenant_id).toBe(testTenantId);
      expect(stored.pattern_type).toBe('scheduling');
      expect(stored.embedding).toHaveLength(1536);
    });

    it('should find similar patterns', async () => {
      // Store patterns
      await vectorStore.storePatternEmbedding(testTenantId, 'scheduling', 'Quiero una cita');
      await vectorStore.storePatternEmbedding(testTenantId, 'scheduling', 'Necesito agendar');
      await vectorStore.storePatternEmbedding(testTenantId, 'pricing', 'CuÃ¡nto cuesta');

      // Search
      const results = await vectorStore.searchSimilarPatterns(
        'Quiero reservar hora',
        { tenant_id: testTenantId, threshold: 0.5 }
      );

      expect(results.length).toBeGreaterThan(0);
      expect(results[0].item.pattern_type).toBe('scheduling');
    });

    it('should filter by pattern type', async () => {
      await vectorStore.storePatternEmbedding(testTenantId, 'scheduling', 'Agendar cita');
      await vectorStore.storePatternEmbedding(testTenantId, 'pricing', 'Precio consulta');

      const results = await vectorStore.searchSimilarPatterns(
        'Consulta',
        {
          tenant_id: testTenantId,
          pattern_types: ['pricing'],
          threshold: 0.3,
        }
      );

      results.forEach(r => {
        expect(r.item.pattern_type).toBe('pricing');
      });
    });

    it('should batch store patterns efficiently', async () => {
      const patterns = Array.from({ length: 100 }, (_, i) => ({
        type: i % 2 === 0 ? 'scheduling' : 'inquiry',
        text: `Test pattern ${i}`,
      }));

      const count = await vectorStore.batchStorePatterns(testTenantId, patterns);

      expect(count).toBe(100);

      const stats = await vectorStore.getStats(testTenantId);
      expect(stats.pattern_count).toBe(100);
    });
  });

  describe('Document Embeddings', () => {
    it('should store document with chunking', async () => {
      const longContent = 'Lorem ipsum '.repeat(500); // Long document

      const chunks = await vectorStore.storeDocumentEmbedding(testTenantId, {
        type: 'faq',
        title: 'Test FAQ',
        content: longContent,
      });

      expect(chunks.length).toBeGreaterThan(1);
      expect(chunks[0].chunk_index).toBe(0);
      expect(chunks[0].total_chunks).toBe(chunks.length);
    });

    it('should search documents by type', async () => {
      await vectorStore.storeDocumentEmbedding(testTenantId, {
        type: 'faq',
        title: 'FAQ sobre horarios',
        content: 'Nuestro horario es de 9am a 6pm',
      });

      await vectorStore.storeDocumentEmbedding(testTenantId, {
        type: 'policy',
        title: 'PolÃ­tica de cancelaciÃ³n',
        content: 'Las cancelaciones deben hacerse con 24 horas de anticipaciÃ³n',
      });

      const results = await vectorStore.searchSimilarDocuments(
        'horario de atenciÃ³n',
        {
          tenant_id: testTenantId,
          document_types: ['faq'],
          threshold: 0.3,
        }
      );

      expect(results.length).toBeGreaterThan(0);
      results.forEach(r => {
        expect(r.item.document_type).toBe('faq');
      });
    });

    it('should filter by tags', async () => {
      await vectorStore.storeDocumentEmbedding(testTenantId, {
        type: 'faq',
        title: 'FAQ con tags',
        content: 'Contenido de prueba',
        tags: ['horarios', 'general'],
      });

      const results = await vectorStore.searchSimilarDocuments(
        'pregunta',
        {
          tenant_id: testTenantId,
          tags: ['horarios'],
          threshold: 0.1,
        }
      );

      expect(results.length).toBeGreaterThan(0);
    });
  });

  describe('Message Embeddings', () => {
    it('should store message embedding', async () => {
      const stored = await vectorStore.storeMessageEmbedding(testTenantId, {
        messageId: 'msg_1',
        conversationId: 'conv_1',
        text: 'Hola, quiero informaciÃ³n',
        role: 'user',
      });

      expect(stored.message_id).toBe('msg_1');
      expect(stored.embedding).toHaveLength(1536);
    });

    it('should find similar messages', async () => {
      // Store messages
      await vectorStore.storeMessageEmbedding(testTenantId, {
        messageId: 'msg_1',
        text: 'Quiero agendar una cita',
        role: 'user',
      });

      await vectorStore.storeMessageEmbedding(testTenantId, {
        messageId: 'msg_2',
        text: 'Necesito reservar hora',
        role: 'user',
      });

      const results = await vectorStore.findSimilarMessages(
        'Quiero pedir una cita',
        { tenant_id: testTenantId, threshold: 0.7 }
      );

      expect(results.length).toBeGreaterThan(0);
    });
  });

  describe('Tenant Isolation', () => {
    it('should not return data from other tenants', async () => {
      // Create another tenant
      const { data: otherTenant } = await supabase
        .from('tenants')
        .insert({ name: 'Other', slug: `other_${Date.now()}`, vertical: 'dental', plan: 'essentials' })
        .select()
        .single();

      // Store pattern for other tenant
      await vectorStore.storePatternEmbedding(otherTenant.id, 'scheduling', 'Other tenant pattern');

      // Search from test tenant
      const results = await vectorStore.searchSimilarPatterns(
        'Other tenant pattern',
        { tenant_id: testTenantId, threshold: 0.1 }
      );

      // Should not find the other tenant's pattern
      expect(results.length).toBe(0);

      // Cleanup
      await vectorStore.deleteAllForTenant(otherTenant.id);
      await supabase.from('tenants').delete().eq('id', otherTenant.id);
    });
  });
});
```

---

## ðŸ“Š Accuracy Tests

### Archivo: `src/features/ai/semantic/__tests__/accuracy.test.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Classification Accuracy Tests
// Tests con dataset de evaluaciÃ³n
// =====================================================

import { describe, it, expect, beforeAll } from 'vitest';
import { IntentClassifierService } from '../services/intent-classifier.service';
import { Intent } from '../types/semantic.types';

// Test dataset with labeled examples
const TEST_DATASET: Array<{ text: string; expectedIntent: Intent }> = [
  // Scheduling
  { text: 'Quiero agendar una cita', expectedIntent: 'scheduling' },
  { text: 'Me gustarÃ­a reservar hora', expectedIntent: 'scheduling' },
  { text: 'Necesito un turno para maÃ±ana', expectedIntent: 'scheduling' },
  { text: 'Puedo pedir hora para el viernes', expectedIntent: 'scheduling' },
  { text: 'Tienen disponibilidad esta semana', expectedIntent: 'scheduling' },

  // Pricing
  { text: 'CuÃ¡nto cuesta una consulta', expectedIntent: 'pricing' },
  { text: 'CuÃ¡l es el precio del tratamiento', expectedIntent: 'pricing' },
  { text: 'QuÃ© valor tiene la limpieza', expectedIntent: 'pricing' },
  { text: 'CuÃ¡nto cobran', expectedIntent: 'pricing' },
  { text: 'Aceptan tarjeta de crÃ©dito', expectedIntent: 'pricing' },

  // Hours
  { text: 'CuÃ¡l es su horario de atenciÃ³n', expectedIntent: 'hours' },
  { text: 'A quÃ© hora abren', expectedIntent: 'hours' },
  { text: 'Hasta quÃ© hora atienden', expectedIntent: 'hours' },
  { text: 'Trabajan los sÃ¡bados', expectedIntent: 'hours' },

  // Location
  { text: 'DÃ³nde estÃ¡n ubicados', expectedIntent: 'location' },
  { text: 'CuÃ¡l es la direcciÃ³n', expectedIntent: 'location' },
  { text: 'Tienen estacionamiento', expectedIntent: 'location' },

  // Complaint
  { text: 'Tengo un problema con mi cita', expectedIntent: 'complaint' },
  { text: 'Quiero hacer un reclamo', expectedIntent: 'complaint' },
  { text: 'No estoy satisfecho con el servicio', expectedIntent: 'complaint' },

  // Cancellation
  { text: 'Quiero cancelar mi cita', expectedIntent: 'cancellation' },
  { text: 'Necesito reagendar', expectedIntent: 'cancellation' },
  { text: 'No voy a poder ir', expectedIntent: 'cancellation' },

  // Greeting
  { text: 'Hola', expectedIntent: 'greeting' },
  { text: 'Buenos dÃ­as', expectedIntent: 'greeting' },
  { text: 'Buenas tardes', expectedIntent: 'greeting' },

  // Inquiry
  { text: 'QuÃ© servicios ofrecen', expectedIntent: 'inquiry' },
  { text: 'Me pueden dar mÃ¡s informaciÃ³n', expectedIntent: 'inquiry' },
  { text: 'Tienen ortodoncia', expectedIntent: 'inquiry' },
];

describe('Intent Classification Accuracy', () => {
  let classifier: IntentClassifierService;

  beforeAll(async () => {
    classifier = new IntentClassifierService();
    // Warm up
    await classifier.classify('test');
  });

  it('should achieve >90% accuracy on test dataset', async () => {
    let correct = 0;
    const results: Array<{
      text: string;
      expected: Intent;
      predicted: Intent;
      confidence: number;
      correct: boolean;
    }> = [];

    for (const { text, expectedIntent } of TEST_DATASET) {
      const result = await classifier.classify(text);

      const isCorrect = result.intent === expectedIntent;
      if (isCorrect) correct++;

      results.push({
        text,
        expected: expectedIntent,
        predicted: result.intent,
        confidence: result.confidence,
        correct: isCorrect,
      });
    }

    const accuracy = (correct / TEST_DATASET.length) * 100;

    // Log detailed results for debugging
    console.log('\n=== Classification Results ===');
    console.log(`Accuracy: ${accuracy.toFixed(1)}%`);
    console.log(`Correct: ${correct}/${TEST_DATASET.length}`);

    const incorrect = results.filter(r => !r.correct);
    if (incorrect.length > 0) {
      console.log('\nIncorrect classifications:');
      incorrect.forEach(r => {
        console.log(`  "${r.text.substring(0, 40)}..." => ${r.predicted} (expected: ${r.expected})`);
      });
    }

    expect(accuracy).toBeGreaterThan(90);
  });

  it('should have high confidence for clear intents', async () => {
    const clearExamples = [
      'Quiero agendar una cita',
      'CuÃ¡nto cuesta',
      'Hola',
    ];

    for (const text of clearExamples) {
      const result = await classifier.classify(text);
      expect(result.confidence).toBeGreaterThan(0.7);
    }
  });

  it('should handle ambiguous messages gracefully', async () => {
    const ambiguous = [
      'SÃ­', // Could be confirmation
      'Ok', // Could be confirmation or acknowledgment
      'Gracias', // Could be farewell or feedback
    ];

    for (const text of ambiguous) {
      const result = await classifier.classify(text);
      // Should not be unknown, should make a reasonable choice
      expect(result.intent).not.toBe('unknown');
    }
  });

  describe('Per-intent accuracy', () => {
    const intentGroups = TEST_DATASET.reduce((acc, item) => {
      if (!acc[item.expectedIntent]) {
        acc[item.expectedIntent] = [];
      }
      acc[item.expectedIntent].push(item);
      return acc;
    }, {} as Record<Intent, typeof TEST_DATASET>);

    for (const [intent, examples] of Object.entries(intentGroups)) {
      it(`should classify ${intent} correctly (>80%)`, async () => {
        let correct = 0;

        for (const { text } of examples) {
          const result = await classifier.classify(text);
          if (result.intent === intent) correct++;
        }

        const accuracy = (correct / examples.length) * 100;
        console.log(`${intent}: ${accuracy.toFixed(1)}% (${correct}/${examples.length})`);

        expect(accuracy).toBeGreaterThan(80);
      });
    }
  });
});
```

---

## âš¡ Performance Tests

### Archivo: `src/features/ai/embeddings/__tests__/performance.test.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Embedding Performance Tests
// =====================================================

import { describe, it, expect, beforeAll } from 'vitest';
import { EmbeddingService } from '../services/embedding.service';
import { VectorStoreService } from '../services/vector-store.service';

describe('Performance: Embedding Service', () => {
  let embeddingService: EmbeddingService;

  beforeAll(() => {
    embeddingService = new EmbeddingService();
  });

  it('should generate single embedding under 100ms (cached)', async () => {
    // Warm up cache
    await embeddingService.embed({ text: 'Performance test text' });

    const start = Date.now();
    const result = await embeddingService.embed({ text: 'Performance test text' });
    const duration = Date.now() - start;

    expect(result.cached).toBe(true);
    expect(duration).toBeLessThan(100);
  });

  it('should batch 100 embeddings under 5 seconds', async () => {
    const texts = Array.from({ length: 100 }, (_, i) => `Batch test text ${i}`);

    const start = Date.now();
    const result = await embeddingService.embedBatch({ texts });
    const duration = Date.now() - start;

    expect(result.results).toHaveLength(100);
    expect(duration).toBeLessThan(5000);

    console.log(`Batch 100: ${duration}ms (${(duration / 100).toFixed(1)}ms per item)`);
  });

  it('should maintain throughput under concurrent load', async () => {
    const concurrentRequests = 10;
    const textsPerRequest = 20;

    const start = Date.now();

    const promises = Array.from({ length: concurrentRequests }, (_, i) =>
      embeddingService.embedBatch({
        texts: Array.from({ length: textsPerRequest }, (_, j) => `Concurrent ${i}-${j}`),
      })
    );

    const results = await Promise.all(promises);
    const duration = Date.now() - start;

    const totalItems = concurrentRequests * textsPerRequest;
    const throughput = totalItems / (duration / 1000);

    console.log(`Concurrent: ${totalItems} items in ${duration}ms`);
    console.log(`Throughput: ${throughput.toFixed(1)} items/sec`);

    expect(results.every(r => r.results.length === textsPerRequest)).toBe(true);
    expect(duration).toBeLessThan(15000); // 15 seconds max
  });
});

describe('Performance: Vector Search', () => {
  let vectorStore: VectorStoreService;
  let testTenantId: string;

  beforeAll(async () => {
    vectorStore = new VectorStoreService();
    testTenantId = `perf_test_${Date.now()}`;

    // Seed test data
    const patterns = Array.from({ length: 1000 }, (_, i) => ({
      type: ['scheduling', 'pricing', 'inquiry'][i % 3],
      text: `Performance test pattern ${i} with some content`,
    }));

    await vectorStore.batchStorePatterns(testTenantId, patterns);
  });

  it('should search 1000 vectors under 50ms', async () => {
    const start = Date.now();
    const results = await vectorStore.searchSimilarPatterns(
      'Test query for performance',
      { tenant_id: testTenantId, limit: 10, threshold: 0.3 }
    );
    const duration = Date.now() - start;

    console.log(`Search 1000 vectors: ${duration}ms`);
    expect(results.length).toBeGreaterThan(0);
    expect(duration).toBeLessThan(50);
  });

  it('should handle multiple concurrent searches', async () => {
    const queries = Array.from({ length: 20 }, (_, i) => `Query ${i}`);

    const start = Date.now();

    const results = await Promise.all(
      queries.map(q =>
        vectorStore.searchSimilarPatterns(q, {
          tenant_id: testTenantId,
          limit: 5,
          threshold: 0.2,
        })
      )
    );

    const duration = Date.now() - start;

    console.log(`20 concurrent searches: ${duration}ms`);
    expect(results.every(r => Array.isArray(r))).toBe(true);
    expect(duration).toBeLessThan(1000);
  });
});
```

---

## ðŸ”„ CI/CD Pipeline

### Archivo: `.github/workflows/embeddings-tests.yml`

```yaml
name: Embeddings System Tests

on:
  push:
    branches: [main, develop]
    paths:
      - 'src/features/ai/embeddings/**'
      - 'src/features/ai/semantic/**'
  pull_request:
    branches: [main]
    paths:
      - 'src/features/ai/embeddings/**'
      - 'src/features/ai/semantic/**'

env:
  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.TEST_SUPABASE_URL }}
  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.TEST_SUPABASE_SERVICE_KEY }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - run: npm ci
      - run: npm run test:unit -- --coverage src/features/ai/embeddings src/features/ai/semantic

      - uses: codecov/codecov-action@v3
        with:
          flags: embeddings-unit

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - run: npm ci
      - run: npm run test:integration -- src/features/ai/embeddings src/features/ai/semantic

  accuracy-tests:
    name: Accuracy Tests
    runs-on: ubuntu-latest
    needs: integration-tests
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - run: npm ci
      - run: npm run test:accuracy

      - name: Check accuracy threshold
        run: |
          ACCURACY=$(cat accuracy-results.json | jq '.overall_accuracy')
          if (( $(echo "$ACCURACY < 90" | bc -l) )); then
            echo "Accuracy $ACCURACY% is below 90% threshold"
            exit 1
          fi

  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: integration-tests
    if: github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - run: npm ci
      - run: npm run test:perf -- src/features/ai/embeddings

      - name: Upload perf results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: perf-results.json
```

---

## âœ… Checklist de ValidaciÃ³n

```
â–¡ Unit Tests
â”œâ”€â”€ [ ] embedding.service.test.ts passing (95%)
â”œâ”€â”€ [ ] vector-utils.test.ts passing (100%)
â”œâ”€â”€ [ ] intent-classifier.test.ts passing (90%)
â”œâ”€â”€ [ ] vector-store.test.ts passing (90%)
â””â”€â”€ [ ] All coverage targets met

â–¡ Integration Tests
â”œâ”€â”€ [ ] vector-store.integration.test.ts passing
â”œâ”€â”€ [ ] semantic-search.integration.test.ts passing
â”œâ”€â”€ [ ] Tenant isolation verified
â””â”€â”€ [ ] Database operations correct

â–¡ Accuracy Tests
â”œâ”€â”€ [ ] Overall accuracy > 90%
â”œâ”€â”€ [ ] Per-intent accuracy > 80%
â”œâ”€â”€ [ ] Confidence calibration good
â””â”€â”€ [ ] Edge cases handled

â–¡ Performance Tests
â”œâ”€â”€ [ ] Single embedding < 100ms (cached)
â”œâ”€â”€ [ ] Batch 100 < 5 seconds
â”œâ”€â”€ [ ] Search < 50ms
â”œâ”€â”€ [ ] Concurrent load handled

â–¡ CI/CD
â”œâ”€â”€ [ ] GitHub Actions configured
â”œâ”€â”€ [ ] All tests passing in CI
â”œâ”€â”€ [ ] Coverage reports uploading
â””â”€â”€ [ ] Accuracy threshold enforced
```

### Comandos de Test

```bash
# Run all embedding tests
npm run test -- src/features/ai/embeddings src/features/ai/semantic

# Run only unit tests
npm run test:unit -- src/features/ai/embeddings

# Run accuracy tests
npm run test:accuracy

# Run performance tests
npm run test:perf -- src/features/ai/embeddings

# Run with coverage
npm run test -- --coverage src/features/ai/embeddings

# Run specific test file
npm run test -- src/features/ai/semantic/__tests__/accuracy.test.ts
```

---

**FASE 2 COMPLETADA** âœ…

Siguiente: [FASE-3-DRIFT/3.0-OVERVIEW.md](../FASE-3-DRIFT/3.0-OVERVIEW.md)
