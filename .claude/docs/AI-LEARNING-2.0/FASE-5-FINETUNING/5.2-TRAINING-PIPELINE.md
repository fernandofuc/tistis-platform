# 5.2 Training Pipeline - Fine-tuning

## Descripción General

El Training Pipeline orquesta el proceso de fine-tuning con OpenAI, incluyendo upload de datos, creación de jobs, monitoreo y gestión de modelos.

## OpenAI Fine-tuning Service

```typescript
// lib/ai-learning/finetuning/training/openai-service.ts

import OpenAI from 'openai';
import { createClient } from '@/lib/supabase/server';

interface TrainingConfig {
  tenantId: string;
  datasetId: string;
  baseModel: string;
  hyperparameters?: {
    nEpochs?: number;
    batchSize?: number;
    learningRateMultiplier?: number;
  };
  suffix?: string;
}

interface TrainingJob {
  id: string;
  tenantId: string;
  openaiJobId: string;
  status: 'pending' | 'running' | 'succeeded' | 'failed' | 'cancelled';
  baseModel: string;
  fineTunedModel?: string;
  trainingFile: string;
  validationFile?: string;
  hyperparameters: Record<string, any>;
  trainedTokens?: number;
  error?: string;
  createdAt: Date;
  completedAt?: Date;
}

export class OpenAIFineTuningService {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
  }

  /**
   * Inicia un job de fine-tuning
   */
  async startTraining(config: TrainingConfig): Promise<TrainingJob> {
    const supabase = await createClient();

    // Obtener dataset
    const { data: dataset } = await supabase
      .from('ai_finetuning_datasets')
      .select('*')
      .eq('id', config.datasetId)
      .single();

    if (!dataset) throw new Error('Dataset not found');

    // Obtener archivos firmados
    const { data: trainUrl } = await supabase.storage
      .from('ai-datasets')
      .createSignedUrl(dataset.train_file_path, 3600);

    const { data: validationUrl } = dataset.validation_file_path
      ? await supabase.storage
          .from('ai-datasets')
          .createSignedUrl(dataset.validation_file_path, 3600)
      : { data: null };

    // Descargar y subir a OpenAI
    const trainFileId = await this.uploadFileToOpenAI(trainUrl!.signedUrl, 'train');
    const validationFileId = validationUrl
      ? await this.uploadFileToOpenAI(validationUrl.signedUrl, 'validation')
      : undefined;

    // Crear job de fine-tuning
    const job = await this.openai.fineTuning.jobs.create({
      training_file: trainFileId,
      validation_file: validationFileId,
      model: config.baseModel,
      suffix: config.suffix || `tistis-${config.tenantId.slice(0, 8)}`,
      hyperparameters: config.hyperparameters ? {
        n_epochs: config.hyperparameters.nEpochs,
        batch_size: config.hyperparameters.batchSize,
        learning_rate_multiplier: config.hyperparameters.learningRateMultiplier,
      } : undefined,
    });

    // Registrar en DB
    const { data: savedJob } = await supabase
      .from('ai_finetuning_jobs')
      .insert({
        tenant_id: config.tenantId,
        dataset_id: config.datasetId,
        openai_job_id: job.id,
        base_model: config.baseModel,
        training_file_id: trainFileId,
        validation_file_id: validationFileId,
        hyperparameters: config.hyperparameters || {},
        status: 'pending',
      })
      .select()
      .single();

    return this.mapJob(savedJob);
  }

  /**
   * Sube archivo a OpenAI
   */
  private async uploadFileToOpenAI(url: string, purpose: string): Promise<string> {
    // Descargar contenido
    const response = await fetch(url);
    const content = await response.text();

    // Crear File object
    const blob = new Blob([content], { type: 'application/jsonl' });
    const file = new File([blob], `${purpose}.jsonl`, { type: 'application/jsonl' });

    // Subir a OpenAI
    const uploadedFile = await this.openai.files.create({
      file,
      purpose: 'fine-tune',
    });

    return uploadedFile.id;
  }

  /**
   * Obtiene estado de un job
   */
  async getJobStatus(jobId: string): Promise<TrainingJob> {
    const supabase = await createClient();

    const { data: job } = await supabase
      .from('ai_finetuning_jobs')
      .select('*')
      .eq('id', jobId)
      .single();

    if (!job) throw new Error('Job not found');

    // Obtener estado actualizado de OpenAI
    const openaiJob = await this.openai.fineTuning.jobs.retrieve(job.openai_job_id);

    // Actualizar si cambió
    if (openaiJob.status !== job.status || openaiJob.fine_tuned_model !== job.fine_tuned_model) {
      const updates: Record<string, any> = {
        status: this.mapOpenAIStatus(openaiJob.status),
        trained_tokens: openaiJob.trained_tokens,
      };

      if (openaiJob.fine_tuned_model) {
        updates.fine_tuned_model = openaiJob.fine_tuned_model;
        updates.completed_at = new Date().toISOString();
      }

      if (openaiJob.error) {
        updates.error = openaiJob.error.message;
      }

      await supabase
        .from('ai_finetuning_jobs')
        .update(updates)
        .eq('id', jobId);

      Object.assign(job, updates);
    }

    return this.mapJob(job);
  }

  /**
   * Lista eventos de un job
   */
  async listJobEvents(openaiJobId: string): Promise<Array<{
    type: string;
    message: string;
    createdAt: Date;
  }>> {
    const events = await this.openai.fineTuning.jobs.listEvents(openaiJobId, {
      limit: 100,
    });

    return events.data.map(e => ({
      type: e.type || 'info',
      message: e.message,
      createdAt: new Date(e.created_at * 1000),
    }));
  }

  /**
   * Cancela un job
   */
  async cancelJob(jobId: string): Promise<void> {
    const supabase = await createClient();

    const { data: job } = await supabase
      .from('ai_finetuning_jobs')
      .select('openai_job_id')
      .eq('id', jobId)
      .single();

    if (job) {
      await this.openai.fineTuning.jobs.cancel(job.openai_job_id);

      await supabase
        .from('ai_finetuning_jobs')
        .update({ status: 'cancelled' })
        .eq('id', jobId);
    }
  }

  /**
   * Lista jobs de un tenant
   */
  async listJobs(tenantId: string): Promise<TrainingJob[]> {
    const supabase = await createClient();

    const { data } = await supabase
      .from('ai_finetuning_jobs')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false });

    return (data || []).map(this.mapJob);
  }

  private mapOpenAIStatus(status: string): TrainingJob['status'] {
    const mapping: Record<string, TrainingJob['status']> = {
      validating_files: 'pending',
      queued: 'pending',
      running: 'running',
      succeeded: 'succeeded',
      failed: 'failed',
      cancelled: 'cancelled',
    };
    return mapping[status] || 'pending';
  }

  private mapJob(row: any): TrainingJob {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      openaiJobId: row.openai_job_id,
      status: row.status,
      baseModel: row.base_model,
      fineTunedModel: row.fine_tuned_model,
      trainingFile: row.training_file_id,
      validationFile: row.validation_file_id,
      hyperparameters: row.hyperparameters,
      trainedTokens: row.trained_tokens,
      error: row.error,
      createdAt: new Date(row.created_at),
      completedAt: row.completed_at ? new Date(row.completed_at) : undefined,
    };
  }
}
```

## Training Orchestrator

```typescript
// lib/ai-learning/finetuning/training/orchestrator.ts

import { DataPreparationService } from '../data-preparation/service';
import { OpenAIFineTuningService } from './openai-service';
import { createClient } from '@/lib/supabase/server';

interface TrainingRequest {
  tenantId: string;
  name: string;
  description?: string;
  config: {
    startDate: Date;
    endDate: Date;
    baseModel: string;
    minExamples: number;
    maxExamples: number;
    trainSplit: number;
    systemPrompt?: string;
    hyperparameters?: {
      nEpochs?: number;
      batchSize?: number;
      learningRateMultiplier?: number;
    };
  };
}

interface TrainingRun {
  id: string;
  tenantId: string;
  name: string;
  status: 'preparing' | 'training' | 'completed' | 'failed';
  datasetId?: string;
  jobId?: string;
  fineTunedModel?: string;
  stats?: Record<string, any>;
  error?: string;
  createdAt: Date;
  completedAt?: Date;
}

export class TrainingOrchestrator {
  private dataPrep: DataPreparationService;
  private openaiService: OpenAIFineTuningService;

  constructor() {
    this.dataPrep = new DataPreparationService();
    this.openaiService = new OpenAIFineTuningService();
  }

  /**
   * Inicia un run completo de training
   */
  async startTrainingRun(request: TrainingRequest): Promise<TrainingRun> {
    const supabase = await createClient();

    // Crear registro de run
    const { data: run } = await supabase
      .from('ai_finetuning_runs')
      .insert({
        tenant_id: request.tenantId,
        name: request.name,
        description: request.description,
        config: request.config,
        status: 'preparing',
      })
      .select()
      .single();

    try {
      // 1. Preparar dataset
      const datasetResult = await this.dataPrep.prepareDataset({
        tenantId: request.tenantId,
        startDate: request.config.startDate,
        endDate: request.config.endDate,
        minExamples: request.config.minExamples,
        maxExamples: request.config.maxExamples,
        trainSplit: request.config.trainSplit,
        systemPrompt: request.config.systemPrompt,
      });

      // Verificar mínimo de ejemplos
      if (datasetResult.stats.trainExamples < request.config.minExamples) {
        throw new Error(
          `Insufficient training examples: ${datasetResult.stats.trainExamples} < ${request.config.minExamples}`
        );
      }

      // Guardar dataset
      const savedDataset = await this.dataPrep.saveDataset(
        request.tenantId,
        `${request.name}_dataset`,
        datasetResult
      );

      // Obtener dataset ID
      const { data: dataset } = await supabase
        .from('ai_finetuning_datasets')
        .select('id')
        .eq('tenant_id', request.tenantId)
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      // Actualizar run con dataset
      await supabase
        .from('ai_finetuning_runs')
        .update({
          dataset_id: dataset?.id,
          stats: datasetResult.stats,
          status: 'training',
        })
        .eq('id', run.id);

      // 2. Iniciar training
      const job = await this.openaiService.startTraining({
        tenantId: request.tenantId,
        datasetId: dataset!.id,
        baseModel: request.config.baseModel,
        hyperparameters: request.config.hyperparameters,
        suffix: request.name.toLowerCase().replace(/\s+/g, '-'),
      });

      // Actualizar run con job
      await supabase
        .from('ai_finetuning_runs')
        .update({ job_id: job.id })
        .eq('id', run.id);

      return {
        id: run.id,
        tenantId: run.tenant_id,
        name: run.name,
        status: 'training',
        datasetId: dataset?.id,
        jobId: job.id,
        stats: datasetResult.stats,
        createdAt: new Date(run.created_at),
      };
    } catch (err) {
      // Marcar como fallido
      await supabase
        .from('ai_finetuning_runs')
        .update({
          status: 'failed',
          error: String(err),
        })
        .eq('id', run.id);

      throw err;
    }
  }

  /**
   * Verifica y actualiza estado de runs activos
   */
  async checkRunStatus(runId: string): Promise<TrainingRun> {
    const supabase = await createClient();

    const { data: run } = await supabase
      .from('ai_finetuning_runs')
      .select('*')
      .eq('id', runId)
      .single();

    if (!run) throw new Error('Run not found');

    if (run.status === 'training' && run.job_id) {
      const job = await this.openaiService.getJobStatus(run.job_id);

      if (job.status === 'succeeded') {
        await supabase
          .from('ai_finetuning_runs')
          .update({
            status: 'completed',
            fine_tuned_model: job.fineTunedModel,
            completed_at: new Date().toISOString(),
          })
          .eq('id', runId);

        run.status = 'completed';
        run.fine_tuned_model = job.fineTunedModel;
      } else if (job.status === 'failed') {
        await supabase
          .from('ai_finetuning_runs')
          .update({
            status: 'failed',
            error: job.error,
          })
          .eq('id', runId);

        run.status = 'failed';
        run.error = job.error;
      }
    }

    return this.mapRun(run);
  }

  private mapRun(row: any): TrainingRun {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      name: row.name,
      status: row.status,
      datasetId: row.dataset_id,
      jobId: row.job_id,
      fineTunedModel: row.fine_tuned_model,
      stats: row.stats,
      error: row.error,
      createdAt: new Date(row.created_at),
      completedAt: row.completed_at ? new Date(row.completed_at) : undefined,
    };
  }
}
```

## Cron para Monitoreo

```typescript
// app/api/cron/finetuning-monitor/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { TrainingOrchestrator } from '@/lib/ai-learning/finetuning/training/orchestrator';

export const runtime = 'nodejs';
export const maxDuration = 60;

export async function GET(request: NextRequest) {
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const supabase = await createClient();
  const orchestrator = new TrainingOrchestrator();

  // Obtener runs activos
  const { data: activeRuns } = await supabase
    .from('ai_finetuning_runs')
    .select('id')
    .eq('status', 'training');

  const results: any[] = [];

  for (const run of activeRuns || []) {
    try {
      const updated = await orchestrator.checkRunStatus(run.id);
      results.push({
        runId: run.id,
        status: updated.status,
        fineTunedModel: updated.fineTunedModel,
      });
    } catch (err) {
      results.push({
        runId: run.id,
        error: String(err),
      });
    }
  }

  return NextResponse.json({
    success: true,
    checked: results.length,
    results,
  });
}
```

## Siguiente Documento

Continúa con [5.3-EVALUATION.md](./5.3-EVALUATION.md) para evaluación de modelos fine-tuned.
