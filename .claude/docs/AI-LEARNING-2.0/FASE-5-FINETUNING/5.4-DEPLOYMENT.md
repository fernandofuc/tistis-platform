# 5.4 Deployment - Fine-tuning Pipeline

## Descripción General

El deployment gestiona la promoción de modelos fine-tuned a producción con soporte para A/B testing, rollback, y monitoreo.

## Model Registry

```typescript
// lib/ai-learning/finetuning/deployment/model-registry.ts

import { createClient } from '@/lib/supabase/server';

interface ModelVersion {
  id: string;
  tenantId: string;
  name: string;
  modelId: string; // OpenAI model ID
  version: number;
  status: 'staging' | 'production' | 'deprecated' | 'archived';
  runId: string;
  evaluationId?: string;
  metrics: Record<string, number>;
  trafficPercent: number;
  createdAt: Date;
  deployedAt?: Date;
}

export class ModelRegistry {
  /**
   * Registra una nueva versión de modelo
   */
  async registerModel(
    tenantId: string,
    runId: string,
    modelId: string,
    evaluationId?: string
  ): Promise<ModelVersion> {
    const supabase = await createClient();

    // Obtener última versión
    const { data: latestVersion } = await supabase
      .from('ai_model_versions')
      .select('version')
      .eq('tenant_id', tenantId)
      .order('version', { ascending: false })
      .limit(1)
      .single();

    const newVersion = (latestVersion?.version || 0) + 1;

    // Obtener métricas de evaluación
    let metrics = {};
    if (evaluationId) {
      const { data: evaluation } = await supabase
        .from('ai_finetuning_evaluations')
        .select('metrics')
        .eq('id', evaluationId)
        .single();
      metrics = evaluation?.metrics || {};
    }

    const { data, error } = await supabase
      .from('ai_model_versions')
      .insert({
        tenant_id: tenantId,
        name: `v${newVersion}`,
        model_id: modelId,
        version: newVersion,
        status: 'staging',
        run_id: runId,
        evaluation_id: evaluationId,
        metrics,
        traffic_percent: 0,
      })
      .select()
      .single();

    if (error) throw error;
    return this.mapVersion(data);
  }

  /**
   * Promueve modelo a producción
   */
  async promoteToProduction(
    versionId: string,
    trafficPercent: number = 100
  ): Promise<ModelVersion> {
    const supabase = await createClient();

    // Obtener versión
    const { data: version } = await supabase
      .from('ai_model_versions')
      .select('*')
      .eq('id', versionId)
      .single();

    if (!version) throw new Error('Version not found');

    // Si es 100%, deprecar versiones anteriores en producción
    if (trafficPercent === 100) {
      await supabase
        .from('ai_model_versions')
        .update({
          status: 'deprecated',
          traffic_percent: 0,
        })
        .eq('tenant_id', version.tenant_id)
        .eq('status', 'production')
        .neq('id', versionId);
    } else {
      // Ajustar tráfico de otras versiones
      const remainingTraffic = 100 - trafficPercent;
      await supabase
        .from('ai_model_versions')
        .update({ traffic_percent: remainingTraffic })
        .eq('tenant_id', version.tenant_id)
        .eq('status', 'production')
        .neq('id', versionId);
    }

    // Actualizar versión actual
    const { data: updated } = await supabase
      .from('ai_model_versions')
      .update({
        status: 'production',
        traffic_percent: trafficPercent,
        deployed_at: new Date().toISOString(),
      })
      .eq('id', versionId)
      .select()
      .single();

    return this.mapVersion(updated);
  }

  /**
   * Rollback a versión anterior
   */
  async rollback(tenantId: string): Promise<ModelVersion | null> {
    const supabase = await createClient();

    // Obtener versión actual en producción
    const { data: current } = await supabase
      .from('ai_model_versions')
      .select('*')
      .eq('tenant_id', tenantId)
      .eq('status', 'production')
      .order('version', { ascending: false })
      .limit(1)
      .single();

    if (!current) return null;

    // Obtener versión anterior (deprecated más reciente)
    const { data: previous } = await supabase
      .from('ai_model_versions')
      .select('*')
      .eq('tenant_id', tenantId)
      .eq('status', 'deprecated')
      .lt('version', current.version)
      .order('version', { ascending: false })
      .limit(1)
      .single();

    if (!previous) return null;

    // Hacer rollback
    await supabase
      .from('ai_model_versions')
      .update({ status: 'deprecated', traffic_percent: 0 })
      .eq('id', current.id);

    const { data: restored } = await supabase
      .from('ai_model_versions')
      .update({
        status: 'production',
        traffic_percent: 100,
        deployed_at: new Date().toISOString(),
      })
      .eq('id', previous.id)
      .select()
      .single();

    return this.mapVersion(restored);
  }

  /**
   * Obtiene modelo activo para un tenant
   */
  async getActiveModel(tenantId: string): Promise<string | null> {
    const supabase = await createClient();

    const { data: versions } = await supabase
      .from('ai_model_versions')
      .select('model_id, traffic_percent')
      .eq('tenant_id', tenantId)
      .eq('status', 'production')
      .gt('traffic_percent', 0);

    if (!versions || versions.length === 0) return null;

    // Selección weighted random si hay múltiples
    if (versions.length === 1) return versions[0].model_id;

    const random = Math.random() * 100;
    let cumulative = 0;

    for (const version of versions) {
      cumulative += version.traffic_percent;
      if (random <= cumulative) return version.model_id;
    }

    return versions[0].model_id;
  }

  /**
   * Lista versiones de un tenant
   */
  async listVersions(tenantId: string): Promise<ModelVersion[]> {
    const supabase = await createClient();

    const { data } = await supabase
      .from('ai_model_versions')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('version', { ascending: false });

    return (data || []).map(this.mapVersion);
  }

  private mapVersion(row: any): ModelVersion {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      name: row.name,
      modelId: row.model_id,
      version: row.version,
      status: row.status,
      runId: row.run_id,
      evaluationId: row.evaluation_id,
      metrics: row.metrics,
      trafficPercent: row.traffic_percent,
      createdAt: new Date(row.created_at),
      deployedAt: row.deployed_at ? new Date(row.deployed_at) : undefined,
    };
  }
}
```

## Deployment Service

```typescript
// lib/ai-learning/finetuning/deployment/service.ts

import { ModelRegistry } from './model-registry';
import { EvaluationService } from '../evaluation/service';
import { createClient } from '@/lib/supabase/server';

interface DeploymentConfig {
  tenantId: string;
  runId: string;
  strategy: 'immediate' | 'canary' | 'blue_green';
  canaryPercent?: number;
  autoPromote?: boolean;
  autoPromoteThreshold?: number;
}

export class DeploymentService {
  private registry: ModelRegistry;
  private evaluationService: EvaluationService;

  constructor() {
    this.registry = new ModelRegistry();
    this.evaluationService = new EvaluationService();
  }

  /**
   * Despliega un modelo fine-tuned
   */
  async deploy(config: DeploymentConfig): Promise<{
    versionId: string;
    status: string;
    trafficPercent: number;
  }> {
    const supabase = await createClient();

    // Obtener run
    const { data: run } = await supabase
      .from('ai_finetuning_runs')
      .select('*')
      .eq('id', config.runId)
      .single();

    if (!run?.fine_tuned_model) {
      throw new Error('No fine-tuned model available');
    }

    // Verificar evaluación
    const { data: evaluation } = await supabase
      .from('ai_finetuning_evaluations')
      .select('*')
      .eq('run_id', config.runId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (!evaluation || evaluation.recommendation === 'reject') {
      throw new Error('Model did not pass evaluation');
    }

    // Registrar versión
    const version = await this.registry.registerModel(
      config.tenantId,
      config.runId,
      run.fine_tuned_model,
      evaluation?.id
    );

    // Desplegar según estrategia
    let trafficPercent: number;

    switch (config.strategy) {
      case 'immediate':
        trafficPercent = 100;
        break;
      case 'canary':
        trafficPercent = config.canaryPercent || 10;
        break;
      case 'blue_green':
        trafficPercent = 0; // Se activa manualmente
        break;
      default:
        trafficPercent = 100;
    }

    if (trafficPercent > 0) {
      await this.registry.promoteToProduction(version.id, trafficPercent);
    }

    // Registrar deployment
    await supabase.from('ai_deployments').insert({
      tenant_id: config.tenantId,
      version_id: version.id,
      strategy: config.strategy,
      initial_traffic: trafficPercent,
      auto_promote: config.autoPromote || false,
      auto_promote_threshold: config.autoPromoteThreshold,
      status: trafficPercent > 0 ? 'active' : 'pending',
    });

    return {
      versionId: version.id,
      status: trafficPercent > 0 ? 'deployed' : 'staged',
      trafficPercent,
    };
  }

  /**
   * Promueve canary a 100%
   */
  async promoteCanary(versionId: string): Promise<void> {
    await this.registry.promoteToProduction(versionId, 100);
  }

  /**
   * Ejecuta rollback
   */
  async rollback(tenantId: string): Promise<{ success: boolean; rolledBackTo?: string }> {
    const version = await this.registry.rollback(tenantId);

    if (version) {
      return { success: true, rolledBackTo: version.name };
    }

    return { success: false };
  }
}
```

## Schema SQL

```sql
-- Modelo versions
CREATE TABLE ai_model_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  name TEXT NOT NULL,
  model_id TEXT NOT NULL,
  version INT NOT NULL,
  status TEXT NOT NULL DEFAULT 'staging',
  run_id UUID REFERENCES ai_finetuning_runs(id),
  evaluation_id UUID,
  metrics JSONB DEFAULT '{}',
  traffic_percent INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  deployed_at TIMESTAMPTZ,
  UNIQUE(tenant_id, version)
);

-- Deployments
CREATE TABLE ai_deployments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  version_id UUID NOT NULL REFERENCES ai_model_versions(id),
  strategy TEXT NOT NULL,
  initial_traffic INT NOT NULL,
  auto_promote BOOLEAN DEFAULT false,
  auto_promote_threshold FLOAT,
  status TEXT NOT NULL DEFAULT 'pending',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_model_versions_tenant ON ai_model_versions(tenant_id, status);
CREATE INDEX idx_deployments_tenant ON ai_deployments(tenant_id, created_at DESC);
```

## Fin de FASE-5

Con este documento se completa la documentación de FASE-5 Fine-tuning. Continúa con [FASE-6-XAI](../FASE-6-XAI/6.0-OVERVIEW.md) para la implementación de Explainability.
