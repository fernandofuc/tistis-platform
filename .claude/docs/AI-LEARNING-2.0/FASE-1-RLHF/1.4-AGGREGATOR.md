# üìä FASE 1.4: RLHF Aggregator Service

## Microfase del Sistema de Agregaci√≥n de Feedback

**Documento:** 1.4-AGGREGATOR.md
**Fase:** 1 - RLHF (Reinforcement Learning from Human Feedback)
**Duraci√≥n estimada:** 1.5-2 semanas
**Dependencias:** 1.1 (Schema DB), 1.2 (API Feedback), 1.3 (UI Components)

---

## üìã √çndice

1. [Objetivo](#objetivo)
2. [Arquitectura del Aggregator](#arquitectura-del-aggregator)
3. [Algoritmo de Agregaci√≥n](#algoritmo-de-agregaci√≥n)
4. [Implementaci√≥n del Servicio](#implementaci√≥n-del-servicio)
5. [Cron Job Configuration](#cron-job-configuration)
6. [M√©tricas y Monitoreo](#m√©tricas-y-monitoreo)
7. [Checklist de Implementaci√≥n](#checklist-de-implementaci√≥n)

---

## üéØ Objetivo

El Aggregator procesa el feedback individual recolectado y genera m√©tricas agregadas que alimentar√°n el Prompt Optimizer. Transforma datos crudos en insights accionables.

### Funciones Principales

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    AGGREGATOR FLOW                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  [Raw Feedback]                                             ‚îÇ
‚îÇ       ‚îÇ                                                     ‚îÇ
‚îÇ       ‚ñº                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                       ‚îÇ
‚îÇ  ‚îÇ Time Window     ‚îÇ  (√∫ltimas 24h, 7d, 30d)              ‚îÇ
‚îÇ  ‚îÇ Selection       ‚îÇ                                       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                       ‚îÇ
‚îÇ           ‚îÇ                                                 ‚îÇ
‚îÇ           ‚ñº                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                       ‚îÇ
‚îÇ  ‚îÇ Group By:       ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ - pattern_type  ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ - response_type ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ - agent_node    ‚îÇ                                       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                       ‚îÇ
‚îÇ           ‚îÇ                                                 ‚îÇ
‚îÇ           ‚ñº                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                       ‚îÇ
‚îÇ  ‚îÇ Calculate:      ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ - satisfaction  ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ - trend         ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ - confidence    ‚îÇ                                       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                       ‚îÇ
‚îÇ           ‚îÇ                                                 ‚îÇ
‚îÇ           ‚ñº                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                       ‚îÇ
‚îÇ  ‚îÇ Store in        ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ ai_rlhf_        ‚îÇ                                       ‚îÇ
‚îÇ  ‚îÇ aggregated      ‚îÇ                                       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                       ‚îÇ
‚îÇ           ‚îÇ                                                 ‚îÇ
‚îÇ           ‚ñº                                                 ‚îÇ
‚îÇ  [Prompt Optimizer Ready]                                   ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üèóÔ∏è Arquitectura del Aggregator

### Componentes

```
src/features/ai/rlhf/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ feedback-capture.service.ts    # ‚úÖ De 1.2
‚îÇ   ‚îî‚îÄ‚îÄ feedback-aggregator.service.ts # üÜï Este documento
‚îú‚îÄ‚îÄ jobs/
‚îÇ   ‚îî‚îÄ‚îÄ aggregation-cron.ts            # üÜï Cron job
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ statistics.utils.ts            # üÜï Utilidades estad√≠sticas
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ aggregation.types.ts           # üÜï Tipos para agregaci√≥n
```

### Diagrama de Dependencias

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  ‚îÇ ai_rlhf_        ‚îÇ         ‚îÇ Vercel Cron     ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ feedback        ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ (cada 6 horas)  ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ (tabla)         ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ                      ‚îÇ
‚îÇ           ‚îÇ                           ‚îÇ                      ‚îÇ
‚îÇ           ‚ñº                           ‚ñº                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  ‚îÇ         FeedbackAggregatorService           ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ                                             ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Fetch   ‚îÇ‚îÄ‚ñ∫‚îÇ Process ‚îÇ‚îÄ‚ñ∫‚îÇ Store   ‚îÇ    ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Raw     ‚îÇ  ‚îÇ Stats   ‚îÇ  ‚îÇ Agg     ‚îÇ    ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ           ‚îÇ                                                  ‚îÇ
‚îÇ           ‚ñº                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                        ‚îÇ
‚îÇ  ‚îÇ ai_rlhf_        ‚îÇ                                        ‚îÇ
‚îÇ  ‚îÇ aggregated      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Prompt Optimizer            ‚îÇ
‚îÇ  ‚îÇ (tabla)         ‚îÇ                                        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                        ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìê Algoritmo de Agregaci√≥n

### 1. C√°lculo de Satisfaction Score

```typescript
/**
 * Satisfaction Score Calculation
 *
 * Formula: weighted_positive / total_feedback
 *
 * Weights:
 * - Positive (üëç): +1.0
 * - Negative without reason (üëé): -0.5
 * - Negative with reason (üëé + comment): -1.0
 * - Negative with correction (üëé + expected): -0.8
 */

interface SatisfactionCalculation {
  positive_count: number;
  negative_count: number;
  negative_with_reason: number;
  negative_with_correction: number;

  // Calculated
  weighted_score: number;
  satisfaction_rate: number;
  confidence_interval: [number, number];
}
```

### 2. Trend Detection

```typescript
/**
 * Trend Detection using Linear Regression
 *
 * Compares satisfaction rate across time periods:
 * - Current period (0-7 days)
 * - Previous period (7-14 days)
 * - Baseline (14-30 days)
 *
 * Trend values:
 * - 'improving': current > previous && current > baseline
 * - 'declining': current < previous && current < baseline
 * - 'stable': |current - previous| < threshold
 * - 'volatile': high standard deviation
 */

type TrendDirection = 'improving' | 'stable' | 'declining' | 'volatile';

interface TrendAnalysis {
  direction: TrendDirection;
  magnitude: number;  // -1.0 to +1.0
  confidence: number; // 0.0 to 1.0
  periods: {
    current: number;
    previous: number;
    baseline: number;
  };
}
```

### 3. Statistical Confidence

```typescript
/**
 * Confidence Calculation using Wilson Score Interval
 *
 * Provides statistically valid confidence for small sample sizes
 * Reference: https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval
 */

function wilsonScoreInterval(
  positive: number,
  total: number,
  confidence: number = 0.95
): { lower: number; upper: number; center: number } {
  if (total === 0) return { lower: 0, upper: 0, center: 0 };

  const z = 1.96; // 95% confidence
  const phat = positive / total;

  const denominator = 1 + (z * z) / total;
  const center = (phat + (z * z) / (2 * total)) / denominator;
  const margin = (z * Math.sqrt((phat * (1 - phat) + (z * z) / (4 * total)) / total)) / denominator;

  return {
    lower: Math.max(0, center - margin),
    upper: Math.min(1, center + margin),
    center
  };
}
```

---

## üíª Implementaci√≥n del Servicio

### Archivo: `src/features/ai/rlhf/types/aggregation.types.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - RLHF Aggregation Types
// Tipos para el servicio de agregaci√≥n de feedback
// =====================================================

export type TrendDirection = 'improving' | 'stable' | 'declining' | 'volatile';
export type AggregationPeriod = '24h' | '7d' | '30d';
export type GroupByDimension = 'pattern_type' | 'response_type' | 'agent_node' | 'message_intent';

export interface AggregationConfig {
  period: AggregationPeriod;
  groupBy: GroupByDimension[];
  minSampleSize: number;
  confidenceLevel: number;
}

export interface RawFeedbackRow {
  id: string;
  tenant_id: string;
  feedback_type: 'positive' | 'negative';
  feedback_reason: string | null;
  expected_response: string | null;
  metadata: {
    pattern_type?: string;
    response_type?: string;
    agent_node?: string;
    message_intent?: string;
  };
  created_at: string;
}

export interface AggregatedMetrics {
  tenant_id: string;
  dimension_type: GroupByDimension;
  dimension_value: string;
  period: AggregationPeriod;

  // Counts
  total_feedback: number;
  positive_count: number;
  negative_count: number;
  negative_with_reason: number;

  // Calculated metrics
  satisfaction_rate: number;
  weighted_satisfaction: number;
  confidence_lower: number;
  confidence_upper: number;

  // Trend
  trend_direction: TrendDirection;
  trend_magnitude: number;
  trend_confidence: number;

  // Common issues
  top_negative_reasons: Array<{
    reason: string;
    count: number;
    percentage: number;
  }>;

  // Timestamps
  period_start: string;
  period_end: string;
  aggregated_at: string;
}

export interface AggregationResult {
  success: boolean;
  tenant_id: string;
  metrics_generated: number;
  processing_time_ms: number;
  errors: string[];
}

export interface AggregationJobConfig {
  enabled: boolean;
  schedule: string; // cron expression
  batch_size: number;
  max_tenants_per_run: number;
}
```

### Archivo: `src/features/ai/rlhf/utils/statistics.utils.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Statistical Utilities for RLHF
// Funciones estad√≠sticas para an√°lisis de feedback
// =====================================================

/**
 * Wilson Score Interval
 * Statistically valid confidence interval for proportions
 */
export function wilsonScoreInterval(
  positive: number,
  total: number,
  z: number = 1.96 // 95% confidence
): { lower: number; upper: number; center: number } {
  if (total === 0) {
    return { lower: 0, upper: 0, center: 0 };
  }

  const phat = positive / total;
  const denominator = 1 + (z * z) / total;
  const center = (phat + (z * z) / (2 * total)) / denominator;
  const margin =
    (z * Math.sqrt((phat * (1 - phat) + (z * z) / (4 * total)) / total)) /
    denominator;

  return {
    lower: Math.max(0, center - margin),
    upper: Math.min(1, center + margin),
    center,
  };
}

/**
 * Calculate weighted satisfaction score
 */
export function calculateWeightedSatisfaction(
  positive: number,
  negativeSimple: number,
  negativeWithReason: number,
  negativeWithCorrection: number
): number {
  const total = positive + negativeSimple + negativeWithReason + negativeWithCorrection;
  if (total === 0) return 0.5; // Neutral when no data

  // Weights for different feedback types
  const WEIGHT_POSITIVE = 1.0;
  const WEIGHT_NEGATIVE_SIMPLE = -0.5;
  const WEIGHT_NEGATIVE_REASON = -1.0;
  const WEIGHT_NEGATIVE_CORRECTION = -0.8;

  const weightedSum =
    positive * WEIGHT_POSITIVE +
    negativeSimple * WEIGHT_NEGATIVE_SIMPLE +
    negativeWithReason * WEIGHT_NEGATIVE_REASON +
    negativeWithCorrection * WEIGHT_NEGATIVE_CORRECTION;

  // Normalize to 0-1 range
  const maxPossible = total * WEIGHT_POSITIVE;
  const minPossible = total * WEIGHT_NEGATIVE_REASON;

  return (weightedSum - minPossible) / (maxPossible - minPossible);
}

/**
 * Detect trend direction comparing periods
 */
export function detectTrend(
  current: number,
  previous: number,
  baseline: number,
  threshold: number = 0.05
): { direction: 'improving' | 'stable' | 'declining' | 'volatile'; magnitude: number; confidence: number } {
  const currentVsPrevious = current - previous;
  const currentVsBaseline = current - baseline;
  const previousVsBaseline = previous - baseline;

  // Check for volatility (inconsistent changes)
  const isVolatile =
    Math.sign(currentVsPrevious) !== Math.sign(previousVsBaseline) &&
    Math.abs(currentVsPrevious) > threshold &&
    Math.abs(previousVsBaseline) > threshold;

  if (isVolatile) {
    return {
      direction: 'volatile',
      magnitude: Math.abs(currentVsPrevious),
      confidence: 0.5,
    };
  }

  // Check for stable
  if (Math.abs(currentVsPrevious) <= threshold && Math.abs(currentVsBaseline) <= threshold) {
    return {
      direction: 'stable',
      magnitude: 0,
      confidence: 0.9,
    };
  }

  // Determine improving or declining
  const isImproving = currentVsPrevious > 0 && currentVsBaseline > 0;
  const isDeclining = currentVsPrevious < 0 && currentVsBaseline < 0;

  if (isImproving) {
    return {
      direction: 'improving',
      magnitude: currentVsBaseline,
      confidence: Math.min(0.95, 0.7 + Math.abs(currentVsBaseline)),
    };
  }

  if (isDeclining) {
    return {
      direction: 'declining',
      magnitude: currentVsBaseline,
      confidence: Math.min(0.95, 0.7 + Math.abs(currentVsBaseline)),
    };
  }

  // Mixed signals
  return {
    direction: 'stable',
    magnitude: currentVsPrevious,
    confidence: 0.6,
  };
}

/**
 * Calculate period boundaries
 */
export function getPeriodBoundaries(period: '24h' | '7d' | '30d'): { start: Date; end: Date } {
  const now = new Date();
  const end = new Date(now);
  const start = new Date(now);

  switch (period) {
    case '24h':
      start.setHours(start.getHours() - 24);
      break;
    case '7d':
      start.setDate(start.getDate() - 7);
      break;
    case '30d':
      start.setDate(start.getDate() - 30);
      break;
  }

  return { start, end };
}

/**
 * Group feedback by dimension
 */
export function groupByDimension<T extends Record<string, unknown>>(
  items: T[],
  dimension: string
): Map<string, T[]> {
  const groups = new Map<string, T[]>();

  for (const item of items) {
    const value = String(item[dimension] ?? 'unknown');
    const existing = groups.get(value) || [];
    existing.push(item);
    groups.set(value, existing);
  }

  return groups;
}

/**
 * Count negative reasons and return top N
 */
export function getTopNegativeReasons(
  feedback: Array<{ feedback_reason: string | null }>,
  topN: number = 5
): Array<{ reason: string; count: number; percentage: number }> {
  const reasonCounts = new Map<string, number>();
  let totalWithReason = 0;

  for (const f of feedback) {
    if (f.feedback_reason) {
      totalWithReason++;
      const count = reasonCounts.get(f.feedback_reason) || 0;
      reasonCounts.set(f.feedback_reason, count + 1);
    }
  }

  const sorted = Array.from(reasonCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, topN)
    .map(([reason, count]) => ({
      reason,
      count,
      percentage: totalWithReason > 0 ? (count / totalWithReason) * 100 : 0,
    }));

  return sorted;
}
```

### Archivo: `src/features/ai/rlhf/services/feedback-aggregator.service.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Feedback Aggregator Service
// Servicio para agregar y analizar feedback RLHF
// =====================================================

import { createClient, SupabaseClient } from '@supabase/supabase-js';
import {
  AggregationConfig,
  AggregatedMetrics,
  AggregationResult,
  RawFeedbackRow,
  GroupByDimension,
  AggregationPeriod,
} from '../types/aggregation.types';
import {
  wilsonScoreInterval,
  calculateWeightedSatisfaction,
  detectTrend,
  getPeriodBoundaries,
  groupByDimension,
  getTopNegativeReasons,
} from '../utils/statistics.utils';

// Default configuration
const DEFAULT_CONFIG: AggregationConfig = {
  period: '7d',
  groupBy: ['pattern_type', 'response_type', 'agent_node'],
  minSampleSize: 5,
  confidenceLevel: 0.95,
};

export class FeedbackAggregatorService {
  private supabase: SupabaseClient;
  private config: AggregationConfig;

  constructor(config: Partial<AggregationConfig> = {}) {
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY! // Service role for cron job
    );
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Run aggregation for a specific tenant
   */
  async aggregateForTenant(tenantId: string): Promise<AggregationResult> {
    const startTime = Date.now();
    const errors: string[] = [];
    let metricsGenerated = 0;

    try {
      // Fetch raw feedback for all periods
      const periods: AggregationPeriod[] = ['24h', '7d', '30d'];

      for (const period of periods) {
        const { start, end } = getPeriodBoundaries(period);

        // Fetch feedback for this period
        const { data: feedback, error } = await this.supabase
          .from('ai_rlhf_feedback')
          .select('*')
          .eq('tenant_id', tenantId)
          .gte('created_at', start.toISOString())
          .lte('created_at', end.toISOString());

        if (error) {
          errors.push(`Error fetching feedback for ${period}: ${error.message}`);
          continue;
        }

        if (!feedback || feedback.length < this.config.minSampleSize) {
          continue; // Not enough data for meaningful aggregation
        }

        // Aggregate by each dimension
        for (const dimension of this.config.groupBy) {
          const metrics = await this.aggregateByDimension(
            tenantId,
            feedback as RawFeedbackRow[],
            dimension,
            period,
            start,
            end
          );

          // Store aggregated metrics
          for (const metric of metrics) {
            const { error: upsertError } = await this.supabase
              .from('ai_rlhf_aggregated')
              .upsert(metric, {
                onConflict: 'tenant_id,dimension_type,dimension_value,period',
              });

            if (upsertError) {
              errors.push(`Error storing metric: ${upsertError.message}`);
            } else {
              metricsGenerated++;
            }
          }
        }
      }

      return {
        success: errors.length === 0,
        tenant_id: tenantId,
        metrics_generated: metricsGenerated,
        processing_time_ms: Date.now() - startTime,
        errors,
      };
    } catch (error) {
      return {
        success: false,
        tenant_id: tenantId,
        metrics_generated: metricsGenerated,
        processing_time_ms: Date.now() - startTime,
        errors: [error instanceof Error ? error.message : 'Unknown error'],
      };
    }
  }

  /**
   * Aggregate feedback by a specific dimension
   */
  private async aggregateByDimension(
    tenantId: string,
    feedback: RawFeedbackRow[],
    dimension: GroupByDimension,
    period: AggregationPeriod,
    periodStart: Date,
    periodEnd: Date
  ): Promise<AggregatedMetrics[]> {
    const metrics: AggregatedMetrics[] = [];

    // Extract dimension value from metadata or direct field
    const feedbackWithDimension = feedback.map(f => ({
      ...f,
      dimensionValue: f.metadata?.[dimension] ?? 'unknown',
    }));

    // Group by dimension value
    const groups = groupByDimension(feedbackWithDimension, 'dimensionValue');

    for (const [dimensionValue, groupFeedback] of groups) {
      if (groupFeedback.length < this.config.minSampleSize) {
        continue; // Skip groups with insufficient data
      }

      // Calculate counts
      const positiveCount = groupFeedback.filter(f => f.feedback_type === 'positive').length;
      const negativeAll = groupFeedback.filter(f => f.feedback_type === 'negative');
      const negativeCount = negativeAll.length;
      const negativeWithReason = negativeAll.filter(f => f.feedback_reason).length;
      const negativeWithCorrection = negativeAll.filter(f => f.expected_response).length;

      // Calculate satisfaction metrics
      const satisfactionRate = positiveCount / groupFeedback.length;
      const weightedSatisfaction = calculateWeightedSatisfaction(
        positiveCount,
        negativeCount - negativeWithReason,
        negativeWithReason - negativeWithCorrection,
        negativeWithCorrection
      );

      // Calculate confidence interval
      const { lower, upper } = wilsonScoreInterval(
        positiveCount,
        groupFeedback.length
      );

      // Get trend (requires historical data)
      const trend = await this.calculateTrendForDimension(
        tenantId,
        dimension,
        dimensionValue,
        satisfactionRate
      );

      // Get top negative reasons
      const topReasons = getTopNegativeReasons(negativeAll);

      metrics.push({
        tenant_id: tenantId,
        dimension_type: dimension,
        dimension_value: dimensionValue,
        period,
        total_feedback: groupFeedback.length,
        positive_count: positiveCount,
        negative_count: negativeCount,
        negative_with_reason: negativeWithReason,
        satisfaction_rate: satisfactionRate,
        weighted_satisfaction: weightedSatisfaction,
        confidence_lower: lower,
        confidence_upper: upper,
        trend_direction: trend.direction,
        trend_magnitude: trend.magnitude,
        trend_confidence: trend.confidence,
        top_negative_reasons: topReasons,
        period_start: periodStart.toISOString(),
        period_end: periodEnd.toISOString(),
        aggregated_at: new Date().toISOString(),
      });
    }

    return metrics;
  }

  /**
   * Calculate trend by comparing with historical aggregations
   */
  private async calculateTrendForDimension(
    tenantId: string,
    dimension: GroupByDimension,
    dimensionValue: string,
    currentSatisfaction: number
  ): Promise<{ direction: 'improving' | 'stable' | 'declining' | 'volatile'; magnitude: number; confidence: number }> {
    // Fetch previous aggregations for comparison
    const { data: history } = await this.supabase
      .from('ai_rlhf_aggregated')
      .select('satisfaction_rate, aggregated_at')
      .eq('tenant_id', tenantId)
      .eq('dimension_type', dimension)
      .eq('dimension_value', dimensionValue)
      .order('aggregated_at', { ascending: false })
      .limit(3);

    if (!history || history.length < 2) {
      // Not enough history for trend
      return { direction: 'stable', magnitude: 0, confidence: 0.5 };
    }

    const previous = history[0]?.satisfaction_rate ?? currentSatisfaction;
    const baseline = history[history.length - 1]?.satisfaction_rate ?? currentSatisfaction;

    return detectTrend(currentSatisfaction, previous, baseline);
  }

  /**
   * Run aggregation for all active tenants
   */
  async aggregateAllTenants(maxTenants: number = 100): Promise<AggregationResult[]> {
    // Get tenants with RLHF enabled
    const { data: tenants, error } = await this.supabase
      .from('ai_learning_config')
      .select('tenant_id')
      .eq('learning_enabled', true)
      .limit(maxTenants);

    if (error || !tenants) {
      console.error('[Aggregator] Error fetching tenants:', error);
      return [];
    }

    const results: AggregationResult[] = [];

    for (const tenant of tenants) {
      const result = await this.aggregateForTenant(tenant.tenant_id);
      results.push(result);

      // Log progress
      console.log(
        `[Aggregator] Tenant ${tenant.tenant_id}: ` +
        `${result.metrics_generated} metrics, ` +
        `${result.processing_time_ms}ms, ` +
        `${result.errors.length} errors`
      );
    }

    return results;
  }

  /**
   * Get aggregated metrics for a tenant
   */
  async getAggregatedMetrics(
    tenantId: string,
    options: {
      dimension?: GroupByDimension;
      period?: AggregationPeriod;
      limit?: number;
    } = {}
  ): Promise<AggregatedMetrics[]> {
    let query = this.supabase
      .from('ai_rlhf_aggregated')
      .select('*')
      .eq('tenant_id', tenantId);

    if (options.dimension) {
      query = query.eq('dimension_type', options.dimension);
    }

    if (options.period) {
      query = query.eq('period', options.period);
    }

    query = query
      .order('aggregated_at', { ascending: false })
      .limit(options.limit ?? 50);

    const { data, error } = await query;

    if (error) {
      console.error('[Aggregator] Error fetching metrics:', error);
      return [];
    }

    return data as AggregatedMetrics[];
  }

  /**
   * Get insights summary for a tenant
   */
  async getInsightsSummary(tenantId: string): Promise<{
    overall_satisfaction: number;
    trending_issues: Array<{ dimension: string; value: string; trend: string }>;
    top_improvement_areas: Array<{ area: string; current: number; potential: number }>;
  }> {
    const metrics = await this.getAggregatedMetrics(tenantId, { period: '7d' });

    if (metrics.length === 0) {
      return {
        overall_satisfaction: 0.5,
        trending_issues: [],
        top_improvement_areas: [],
      };
    }

    // Calculate overall satisfaction (weighted average)
    const totalFeedback = metrics.reduce((sum, m) => sum + m.total_feedback, 0);
    const weightedSatisfaction = metrics.reduce(
      (sum, m) => sum + m.satisfaction_rate * m.total_feedback,
      0
    ) / totalFeedback;

    // Find declining trends
    const trendingIssues = metrics
      .filter(m => m.trend_direction === 'declining')
      .sort((a, b) => a.trend_magnitude - b.trend_magnitude)
      .slice(0, 5)
      .map(m => ({
        dimension: m.dimension_type,
        value: m.dimension_value,
        trend: `${(m.trend_magnitude * 100).toFixed(1)}% decline`,
      }));

    // Find improvement opportunities (low satisfaction but high volume)
    const improvementAreas = metrics
      .filter(m => m.satisfaction_rate < 0.7 && m.total_feedback >= 10)
      .sort((a, b) => a.satisfaction_rate - b.satisfaction_rate)
      .slice(0, 5)
      .map(m => ({
        area: `${m.dimension_type}: ${m.dimension_value}`,
        current: m.satisfaction_rate,
        potential: m.confidence_upper, // Upper bound of confidence interval
      }));

    return {
      overall_satisfaction: weightedSatisfaction,
      trending_issues: trendingIssues,
      top_improvement_areas: improvementAreas,
    };
  }
}

// Export singleton instance
export const feedbackAggregator = new FeedbackAggregatorService();
```

---

## ‚è∞ Cron Job Configuration

### Archivo: `src/features/ai/rlhf/jobs/aggregation-cron.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - RLHF Aggregation Cron Job
// Job para ejecutar agregaci√≥n peri√≥dica
// =====================================================

import { FeedbackAggregatorService } from '../services/feedback-aggregator.service';

export interface AggregationJobResult {
  success: boolean;
  tenants_processed: number;
  total_metrics: number;
  total_errors: number;
  duration_ms: number;
  timestamp: string;
}

/**
 * Run the aggregation job
 * Called by Vercel Cron or manual trigger
 */
export async function runAggregationJob(): Promise<AggregationJobResult> {
  const startTime = Date.now();

  console.log('[Aggregation Job] Starting...');

  const aggregator = new FeedbackAggregatorService({
    period: '7d',
    groupBy: ['pattern_type', 'response_type', 'agent_node'],
    minSampleSize: 5,
    confidenceLevel: 0.95,
  });

  const results = await aggregator.aggregateAllTenants(100);

  const totalMetrics = results.reduce((sum, r) => sum + r.metrics_generated, 0);
  const totalErrors = results.reduce((sum, r) => sum + r.errors.length, 0);

  const jobResult: AggregationJobResult = {
    success: totalErrors === 0,
    tenants_processed: results.length,
    total_metrics: totalMetrics,
    total_errors: totalErrors,
    duration_ms: Date.now() - startTime,
    timestamp: new Date().toISOString(),
  };

  console.log('[Aggregation Job] Completed:', jobResult);

  return jobResult;
}
```

### Archivo: `app/api/cron/rlhf-aggregation/route.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - RLHF Aggregation Cron Endpoint
// Endpoint para Vercel Cron Jobs
// =====================================================

import { NextRequest, NextResponse } from 'next/server';
import { runAggregationJob } from '@/src/features/ai/rlhf/jobs/aggregation-cron';

// Vercel Cron configuration
export const runtime = 'nodejs';
export const maxDuration = 300; // 5 minutes max

/**
 * GET /api/cron/rlhf-aggregation
 * Triggered by Vercel Cron every 6 hours
 */
export async function GET(request: NextRequest) {
  // Verify cron secret (Vercel adds this header)
  const authHeader = request.headers.get('authorization');
  const cronSecret = process.env.CRON_SECRET;

  if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const result = await runAggregationJob();

    return NextResponse.json({
      success: result.success,
      message: 'Aggregation job completed',
      result,
    });
  } catch (error) {
    console.error('[Cron] Aggregation job failed:', error);

    return NextResponse.json(
      {
        error: 'Aggregation job failed',
        message: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
```

### Archivo: `vercel.json` (agregar configuraci√≥n)

```json
{
  "crons": [
    {
      "path": "/api/cron/rlhf-aggregation",
      "schedule": "0 */6 * * *"
    }
  ]
}
```

---

## üìà M√©tricas y Monitoreo

### Dashboard Queries

```sql
-- Overall satisfaction by tenant (last 7 days)
SELECT
  tenant_id,
  ROUND(AVG(satisfaction_rate) * 100, 1) as avg_satisfaction_pct,
  SUM(total_feedback) as total_feedback,
  COUNT(DISTINCT dimension_value) as dimensions_tracked
FROM ai_rlhf_aggregated
WHERE period = '7d'
  AND aggregated_at > NOW() - INTERVAL '7 days'
GROUP BY tenant_id
ORDER BY avg_satisfaction_pct DESC;

-- Declining trends alert
SELECT
  tenant_id,
  dimension_type,
  dimension_value,
  satisfaction_rate,
  trend_direction,
  trend_magnitude
FROM ai_rlhf_aggregated
WHERE trend_direction = 'declining'
  AND trend_magnitude < -0.1
  AND period = '7d'
ORDER BY trend_magnitude ASC
LIMIT 20;

-- Top negative reasons across all tenants
SELECT
  reason->>'reason' as reason,
  SUM((reason->>'count')::int) as total_count
FROM ai_rlhf_aggregated,
  jsonb_array_elements(top_negative_reasons) as reason
WHERE period = '7d'
GROUP BY reason->>'reason'
ORDER BY total_count DESC
LIMIT 10;
```

### Alertas Recomendadas

| Alerta | Condici√≥n | Acci√≥n |
|--------|-----------|--------|
| Low Satisfaction | `satisfaction_rate < 0.5` | Notificar admin |
| Rapid Decline | `trend_direction = 'declining' AND trend_magnitude < -0.2` | Notificar inmediato |
| High Volume Negative | `negative_count > 50 AND period = '24h'` | Revisar urgente |
| Volatile Pattern | `trend_direction = 'volatile'` | Investigar causa |

---

## ‚úÖ Checklist de Implementaci√≥n

### Pre-requisitos
- [ ] Tabla `ai_rlhf_feedback` creada y poblada (1.1, 1.2)
- [ ] API de feedback funcionando (1.2)
- [ ] Tabla `ai_rlhf_aggregated` creada (1.1)

### Implementaci√≥n

```
‚ñ° Paso 1: Crear tipos
‚îú‚îÄ‚îÄ [ ] Crear archivo aggregation.types.ts
‚îú‚îÄ‚îÄ [ ] Definir interfaces principales
‚îî‚îÄ‚îÄ [ ] Exportar tipos

‚ñ° Paso 2: Crear utilidades estad√≠sticas
‚îú‚îÄ‚îÄ [ ] Implementar wilsonScoreInterval
‚îú‚îÄ‚îÄ [ ] Implementar calculateWeightedSatisfaction
‚îú‚îÄ‚îÄ [ ] Implementar detectTrend
‚îú‚îÄ‚îÄ [ ] Implementar helpers de per√≠odo
‚îî‚îÄ‚îÄ [ ] Unit tests para utilidades

‚ñ° Paso 3: Implementar servicio
‚îú‚îÄ‚îÄ [ ] Crear FeedbackAggregatorService
‚îú‚îÄ‚îÄ [ ] Implementar aggregateForTenant
‚îú‚îÄ‚îÄ [ ] Implementar aggregateByDimension
‚îú‚îÄ‚îÄ [ ] Implementar calculateTrendForDimension
‚îú‚îÄ‚îÄ [ ] Implementar getAggregatedMetrics
‚îú‚îÄ‚îÄ [ ] Implementar getInsightsSummary
‚îî‚îÄ‚îÄ [ ] Integration tests

‚ñ° Paso 4: Configurar cron job
‚îú‚îÄ‚îÄ [ ] Crear aggregation-cron.ts
‚îú‚îÄ‚îÄ [ ] Crear endpoint /api/cron/rlhf-aggregation
‚îú‚îÄ‚îÄ [ ] Configurar vercel.json
‚îú‚îÄ‚îÄ [ ] Configurar CRON_SECRET
‚îî‚îÄ‚îÄ [ ] Test manual del cron

‚ñ° Paso 5: Monitoreo
‚îú‚îÄ‚îÄ [ ] Crear queries de dashboard
‚îú‚îÄ‚îÄ [ ] Configurar alertas
‚îî‚îÄ‚îÄ [ ] Documentar m√©tricas
```

### Validaci√≥n

```bash
# Test manual del aggregator
curl -X GET "http://localhost:3000/api/cron/rlhf-aggregation" \
  -H "Authorization: Bearer $CRON_SECRET"

# Verificar m√©tricas generadas
SELECT COUNT(*) FROM ai_rlhf_aggregated
WHERE aggregated_at > NOW() - INTERVAL '1 hour';

# Verificar tendencias
SELECT dimension_value, trend_direction, trend_magnitude
FROM ai_rlhf_aggregated
WHERE period = '7d'
ORDER BY aggregated_at DESC
LIMIT 10;
```

---

## üìù Notas de Implementaci√≥n

### Performance Considerations

1. **Batch Processing**: El agregador procesa tenants uno a uno para evitar sobrecarga
2. **√çndices**: Asegurar √≠ndices en `tenant_id`, `created_at` para queries eficientes
3. **Caching**: Considerar cachear resultados de agregaci√≥n por 1 hora

### Edge Cases

1. **Nuevos tenants**: Sin historial, trend ser√° `stable` con baja confianza
2. **Picos de feedback**: Usar ventanas m√≥viles para suavizar outliers
3. **Datos faltantes**: Interpolaci√≥n lineal para per√≠odos sin datos

---

**Siguiente documento:** [1.5-PROMPT-OPTIMIZER.md](./1.5-PROMPT-OPTIMIZER.md)
