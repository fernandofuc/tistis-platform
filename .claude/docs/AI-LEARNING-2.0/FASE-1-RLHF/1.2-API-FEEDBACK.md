# ğŸ”Œ FASE 1.2: API de Captura de Feedback

## Documento de ImplementaciÃ³n

**VersiÃ³n:** 1.0.0
**DuraciÃ³n estimada:** 1 semana
**Dependencias:** 1.1-SCHEMA-DB (completado)
**Output:** Endpoint `/api/rlhf/feedback` funcionando

---

## 1. OBJETIVO

Crear el endpoint API que:
1. Recibe feedback (ğŸ‘/ğŸ‘) de respuestas del AI
2. Valida y enriquece el payload
3. Almacena en `ai_rlhf_feedback`
4. Aplica rate limiting para prevenir abuso

---

## 2. ESPECIFICACIÃ“N DE API

### 2.1 Endpoint Principal

```yaml
POST /api/rlhf/feedback
Content-Type: application/json
Authorization: Bearer <access_token>

Request Body:
{
  "message_id": "uuid",           # REQUIRED - ID del mensaje del AI
  "rating": "up" | "down",        # REQUIRED - Tipo de feedback
  "feedback_text": "string",      # OPTIONAL - Comentario adicional
  "feedback_category": "string"   # OPTIONAL - CategorÃ­a predefinida
}

Response 201 (Created):
{
  "success": true,
  "feedback_id": "uuid",
  "message": "Feedback registrado correctamente"
}

Response 400 (Bad Request):
{
  "success": false,
  "error": "message_id es requerido"
}

Response 429 (Too Many Requests):
{
  "success": false,
  "error": "Demasiados feedbacks. Intenta en 1 hora.",
  "retry_after": 3600
}
```

### 2.2 Rate Limiting

```yaml
LÃ­mites por lead:
  - 10 feedbacks por hora
  - 50 feedbacks por dÃ­a

LÃ­mites por conversaciÃ³n:
  - 5 feedbacks por hora

LÃ­mites por IP (fallback si no hay lead):
  - 20 feedbacks por hora
```

### 2.3 Validaciones

```yaml
message_id:
  - Requerido
  - Debe ser UUID vÃ¡lido
  - Debe existir en tabla messages
  - Debe pertenecer al tenant del usuario
  - El mensaje debe ser de sender_type = 'agent'

rating:
  - Requerido
  - Debe ser 'up' o 'down'

feedback_text:
  - Opcional
  - MÃ¡ximo 500 caracteres
  - Sanitizar HTML/scripts

feedback_category:
  - Opcional
  - Debe ser uno de los valores permitidos
```

---

## 3. IMPLEMENTACIÃ“N

### 3.1 Archivo: `src/features/ai/types/rlhf.types.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - RLHF Types
// Tipos para el sistema de feedback RLHF
// =====================================================

/**
 * Tipos de rating permitidos
 */
export type FeedbackRating = 'up' | 'down';

/**
 * CategorÃ­as de feedback permitidas
 */
export type FeedbackCategory =
  | 'wrong_info'   // InformaciÃ³n incorrecta
  | 'incomplete'   // Respuesta incompleta
  | 'rude'         // Tono inapropiado
  | 'slow'         // Respuesta lenta
  | 'helpful'      // Muy Ãºtil
  | 'accurate'     // InformaciÃ³n precisa
  | 'friendly'     // Tono amigable
  | 'other';       // Otro

/**
 * Payload de entrada para captura de feedback
 */
export interface FeedbackCaptureInput {
  message_id: string;
  rating: FeedbackRating;
  feedback_text?: string;
  feedback_category?: FeedbackCategory;
}

/**
 * Feedback enriquecido con contexto
 */
export interface EnrichedFeedback extends FeedbackCaptureInput {
  tenant_id: string;
  conversation_id: string;
  lead_id?: string;
  intent_detected?: string;
  agent_used?: string;
  response_text?: string;
  confidence_score?: number;
  user_agent?: string;
  ip_hash?: string;
}

/**
 * Registro completo de feedback (desde DB)
 */
export interface FeedbackRecord extends EnrichedFeedback {
  id: string;
  created_at: string;
}

/**
 * Respuesta de la API de captura
 */
export interface FeedbackCaptureResponse {
  success: boolean;
  feedback_id?: string;
  message?: string;
  error?: string;
}

/**
 * MÃ©tricas agregadas de feedback
 */
export interface FeedbackAggregatedMetrics {
  period_start: string;
  period_end: string;
  intent?: string;
  agent?: string;
  total_responses: number;
  positive_count: number;
  negative_count: number;
  satisfaction_rate: number;
  negative_patterns: NegativePattern[];
}

/**
 * PatrÃ³n negativo detectado
 */
export interface NegativePattern {
  pattern: string;
  count: number;
  examples: string[];
}

/**
 * Resultado de rate limit check
 */
export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  reset_at: number;
  limit: number;
}
```

### 3.2 Archivo: `src/features/ai/services/rlhf/feedback-capture.service.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - Feedback Capture Service
// Servicio para capturar y validar feedback RLHF
// =====================================================

import { createServerClient } from '@/src/shared/lib/supabase';
import crypto from 'crypto';
import type {
  FeedbackCaptureInput,
  EnrichedFeedback,
  FeedbackCaptureResponse,
  FeedbackRating,
  FeedbackCategory,
  RateLimitResult,
} from '../../types/rlhf.types';

// ======================
// CONSTANTS
// ======================

const VALID_RATINGS: FeedbackRating[] = ['up', 'down'];

const VALID_CATEGORIES: FeedbackCategory[] = [
  'wrong_info',
  'incomplete',
  'rude',
  'slow',
  'helpful',
  'accurate',
  'friendly',
  'other',
];

const RATE_LIMITS = {
  perLeadHour: 10,
  perLeadDay: 50,
  perConversationHour: 5,
  perIpHour: 20,
};

const MAX_FEEDBACK_TEXT_LENGTH = 500;

// ======================
// VALIDATION
// ======================

/**
 * Valida el payload de entrada
 */
export function validateFeedbackInput(
  input: unknown
): { valid: true; data: FeedbackCaptureInput } | { valid: false; error: string } {
  // Check if input is object
  if (!input || typeof input !== 'object') {
    return { valid: false, error: 'El payload debe ser un objeto JSON' };
  }

  const data = input as Record<string, unknown>;

  // Validate message_id
  if (!data.message_id) {
    return { valid: false, error: 'message_id es requerido' };
  }

  if (typeof data.message_id !== 'string') {
    return { valid: false, error: 'message_id debe ser un string' };
  }

  // UUID validation regex
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(data.message_id)) {
    return { valid: false, error: 'message_id debe ser un UUID vÃ¡lido' };
  }

  // Validate rating
  if (!data.rating) {
    return { valid: false, error: 'rating es requerido' };
  }

  if (!VALID_RATINGS.includes(data.rating as FeedbackRating)) {
    return { valid: false, error: `rating debe ser uno de: ${VALID_RATINGS.join(', ')}` };
  }

  // Validate feedback_text (optional)
  if (data.feedback_text !== undefined) {
    if (typeof data.feedback_text !== 'string') {
      return { valid: false, error: 'feedback_text debe ser un string' };
    }

    if (data.feedback_text.length > MAX_FEEDBACK_TEXT_LENGTH) {
      return {
        valid: false,
        error: `feedback_text no puede exceder ${MAX_FEEDBACK_TEXT_LENGTH} caracteres`,
      };
    }
  }

  // Validate feedback_category (optional)
  if (data.feedback_category !== undefined) {
    if (!VALID_CATEGORIES.includes(data.feedback_category as FeedbackCategory)) {
      return {
        valid: false,
        error: `feedback_category debe ser uno de: ${VALID_CATEGORIES.join(', ')}`,
      };
    }
  }

  return {
    valid: true,
    data: {
      message_id: data.message_id as string,
      rating: data.rating as FeedbackRating,
      feedback_text: data.feedback_text as string | undefined,
      feedback_category: data.feedback_category as FeedbackCategory | undefined,
    },
  };
}

/**
 * Sanitiza el texto de feedback
 */
function sanitizeFeedbackText(text: string): string {
  // Remove HTML tags
  let sanitized = text.replace(/<[^>]*>/g, '');

  // Remove potential script injections
  sanitized = sanitized.replace(/javascript:/gi, '');
  sanitized = sanitized.replace(/on\w+=/gi, '');

  // Trim and limit length
  sanitized = sanitized.trim().substring(0, MAX_FEEDBACK_TEXT_LENGTH);

  return sanitized;
}

/**
 * Hash de IP para privacidad
 */
function hashIP(ip: string): string {
  return crypto.createHash('sha256').update(ip).digest('hex').substring(0, 16);
}

// ======================
// RATE LIMITING
// ======================

/**
 * Verifica rate limits para un lead
 */
async function checkRateLimitForLead(
  tenantId: string,
  leadId: string
): Promise<RateLimitResult> {
  const supabase = createServerClient();

  const oneHourAgo = new Date();
  oneHourAgo.setHours(oneHourAgo.getHours() - 1);

  const { count } = await supabase
    .from('ai_rlhf_feedback')
    .select('*', { count: 'exact', head: true })
    .eq('tenant_id', tenantId)
    .eq('lead_id', leadId)
    .gte('created_at', oneHourAgo.toISOString());

  const currentCount = count || 0;
  const allowed = currentCount < RATE_LIMITS.perLeadHour;

  return {
    allowed,
    remaining: Math.max(0, RATE_LIMITS.perLeadHour - currentCount),
    reset_at: oneHourAgo.getTime() + 3600000,
    limit: RATE_LIMITS.perLeadHour,
  };
}

/**
 * Verifica rate limits para una conversaciÃ³n
 */
async function checkRateLimitForConversation(
  tenantId: string,
  conversationId: string
): Promise<RateLimitResult> {
  const supabase = createServerClient();

  const oneHourAgo = new Date();
  oneHourAgo.setHours(oneHourAgo.getHours() - 1);

  const { count } = await supabase
    .from('ai_rlhf_feedback')
    .select('*', { count: 'exact', head: true })
    .eq('tenant_id', tenantId)
    .eq('conversation_id', conversationId)
    .gte('created_at', oneHourAgo.toISOString());

  const currentCount = count || 0;
  const allowed = currentCount < RATE_LIMITS.perConversationHour;

  return {
    allowed,
    remaining: Math.max(0, RATE_LIMITS.perConversationHour - currentCount),
    reset_at: oneHourAgo.getTime() + 3600000,
    limit: RATE_LIMITS.perConversationHour,
  };
}

// ======================
// CONTEXT ENRICHMENT
// ======================

/**
 * Enriquece el feedback con contexto del mensaje
 */
async function enrichFeedbackWithContext(
  input: FeedbackCaptureInput,
  tenantId: string,
  userAgent?: string,
  ipAddress?: string
): Promise<EnrichedFeedback | null> {
  const supabase = createServerClient();

  // Obtener informaciÃ³n del mensaje
  const { data: message, error } = await supabase
    .from('messages')
    .select(`
      id,
      conversation_id,
      content,
      sender_type,
      metadata,
      conversations!inner (
        tenant_id,
        lead_id
      )
    `)
    .eq('id', input.message_id)
    .single();

  if (error || !message) {
    console.error('[RLHF] Message not found:', input.message_id);
    return null;
  }

  // Verificar que el mensaje pertenece al tenant
  const messageConv = message.conversations as { tenant_id: string; lead_id?: string };
  if (messageConv.tenant_id !== tenantId) {
    console.error('[RLHF] Message does not belong to tenant');
    return null;
  }

  // Verificar que es un mensaje del AI
  if (message.sender_type !== 'agent' && message.sender_type !== 'ai') {
    console.error('[RLHF] Message is not from AI');
    return null;
  }

  // Extraer metadata del mensaje
  const metadata = message.metadata as Record<string, unknown> | null;

  return {
    ...input,
    feedback_text: input.feedback_text
      ? sanitizeFeedbackText(input.feedback_text)
      : undefined,
    tenant_id: tenantId,
    conversation_id: message.conversation_id,
    lead_id: messageConv.lead_id,
    intent_detected: metadata?.intent as string | undefined,
    agent_used: metadata?.agent as string | undefined,
    response_text: message.content?.substring(0, 500), // Limitar longitud
    confidence_score: metadata?.confidence as number | undefined,
    user_agent: userAgent?.substring(0, 200),
    ip_hash: ipAddress ? hashIP(ipAddress) : undefined,
  };
}

// ======================
// MAIN SERVICE
// ======================

/**
 * Captura y almacena feedback de una respuesta del AI
 */
export async function captureFeedback(
  input: FeedbackCaptureInput,
  tenantId: string,
  options?: {
    userAgent?: string;
    ipAddress?: string;
  }
): Promise<FeedbackCaptureResponse> {
  const supabase = createServerClient();

  try {
    // 1. Enriquecer con contexto
    const enrichedFeedback = await enrichFeedbackWithContext(
      input,
      tenantId,
      options?.userAgent,
      options?.ipAddress
    );

    if (!enrichedFeedback) {
      return {
        success: false,
        error: 'Mensaje no encontrado o no pertenece a tu cuenta',
      };
    }

    // 2. Verificar rate limits
    if (enrichedFeedback.lead_id) {
      const leadLimit = await checkRateLimitForLead(tenantId, enrichedFeedback.lead_id);
      if (!leadLimit.allowed) {
        return {
          success: false,
          error: 'Demasiados feedbacks. Intenta en 1 hora.',
        };
      }
    }

    const convLimit = await checkRateLimitForConversation(
      tenantId,
      enrichedFeedback.conversation_id
    );
    if (!convLimit.allowed) {
      return {
        success: false,
        error: 'Demasiados feedbacks para esta conversaciÃ³n',
      };
    }

    // 3. Verificar que no existe feedback duplicado
    const { data: existing } = await supabase
      .from('ai_rlhf_feedback')
      .select('id')
      .eq('message_id', input.message_id)
      .eq('tenant_id', tenantId)
      .maybeSingle();

    if (existing) {
      // Actualizar feedback existente en lugar de crear nuevo
      const { error: updateError } = await supabase
        .from('ai_rlhf_feedback')
        .update({
          rating: enrichedFeedback.rating,
          feedback_text: enrichedFeedback.feedback_text,
          feedback_category: enrichedFeedback.feedback_category,
        })
        .eq('id', existing.id);

      if (updateError) {
        console.error('[RLHF] Error updating feedback:', updateError);
        return {
          success: false,
          error: 'Error al actualizar feedback',
        };
      }

      return {
        success: true,
        feedback_id: existing.id,
        message: 'Feedback actualizado correctamente',
      };
    }

    // 4. Insertar nuevo feedback
    const { data: inserted, error: insertError } = await supabase
      .from('ai_rlhf_feedback')
      .insert({
        tenant_id: enrichedFeedback.tenant_id,
        message_id: input.message_id,
        conversation_id: enrichedFeedback.conversation_id,
        lead_id: enrichedFeedback.lead_id,
        rating: enrichedFeedback.rating,
        feedback_text: enrichedFeedback.feedback_text,
        feedback_category: enrichedFeedback.feedback_category,
        intent_detected: enrichedFeedback.intent_detected,
        agent_used: enrichedFeedback.agent_used,
        response_text: enrichedFeedback.response_text,
        confidence_score: enrichedFeedback.confidence_score,
        user_agent: enrichedFeedback.user_agent,
        ip_hash: enrichedFeedback.ip_hash,
      })
      .select('id')
      .single();

    if (insertError) {
      console.error('[RLHF] Error inserting feedback:', insertError);
      return {
        success: false,
        error: 'Error al guardar feedback',
      };
    }

    console.log(`[RLHF] Feedback captured: ${inserted.id} (${enrichedFeedback.rating})`);

    return {
      success: true,
      feedback_id: inserted.id,
      message: 'Feedback registrado correctamente',
    };
  } catch (error) {
    console.error('[RLHF] Unexpected error:', error);
    return {
      success: false,
      error: 'Error interno del servidor',
    };
  }
}

// ======================
// EXPORTS
// ======================

export const FeedbackCaptureService = {
  validate: validateFeedbackInput,
  capture: captureFeedback,
  checkRateLimitForLead,
  checkRateLimitForConversation,
};
```

### 3.3 Archivo: `app/api/rlhf/feedback/route.ts`

```typescript
// =====================================================
// TIS TIS PLATFORM - RLHF Feedback API
// POST /api/rlhf/feedback - Captura feedback de respuestas
// =====================================================

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import {
  FeedbackCaptureService,
  validateFeedbackInput,
} from '@/src/features/ai/services/rlhf/feedback-capture.service';
import { checkRateLimitMigration } from '@/src/shared/lib/rate-limit-migration';
import {
  getClientIP,
  publicAPILimiter,
  rateLimitExceeded,
} from '@/src/shared/lib/rate-limit';

// Force dynamic rendering
export const dynamic = 'force-dynamic';

// ======================
// HELPERS
// ======================

function createAuthenticatedClient(accessToken: string) {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      global: {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      },
    }
  );
}

function getAccessToken(request: NextRequest): string | null {
  const authHeader = request.headers.get('authorization');
  if (authHeader?.startsWith('Bearer ')) {
    return authHeader.substring(7);
  }
  return null;
}

async function getUserContext(supabase: ReturnType<typeof createAuthenticatedClient>) {
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) return null;

  const { data: userRole } = await supabase
    .from('user_roles')
    .select('tenant_id, role')
    .eq('user_id', user.id)
    .single();

  if (!userRole) return null;

  return { user, userRole };
}

// ======================
// POST - Capture Feedback
// ======================

export async function POST(request: NextRequest) {
  // 1. Rate limiting global
  const clientIP = getClientIP(request);
  const rateLimitResult = await checkRateLimitMigration(clientIP, publicAPILimiter);

  if (!rateLimitResult.success) {
    return rateLimitExceeded(rateLimitResult);
  }

  try {
    // 2. Authenticate user
    const accessToken = getAccessToken(request);
    if (!accessToken) {
      return NextResponse.json(
        { success: false, error: 'No autenticado - Token no proporcionado' },
        { status: 401 }
      );
    }

    const supabase = createAuthenticatedClient(accessToken);
    const context = await getUserContext(supabase);

    if (!context) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 403 }
      );
    }

    const tenantId = context.userRole.tenant_id;

    // 3. Parse and validate body
    let body: unknown;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json(
        { success: false, error: 'JSON invÃ¡lido en el body' },
        { status: 400 }
      );
    }

    const validation = validateFeedbackInput(body);
    if (!validation.valid) {
      return NextResponse.json(
        { success: false, error: validation.error },
        { status: 400 }
      );
    }

    // 4. Capture feedback
    const result = await FeedbackCaptureService.capture(
      validation.data,
      tenantId,
      {
        userAgent: request.headers.get('user-agent') || undefined,
        ipAddress: clientIP,
      }
    );

    if (!result.success) {
      // Determine appropriate status code
      const status = result.error?.includes('Demasiados') ? 429 : 400;
      return NextResponse.json(result, { status });
    }

    return NextResponse.json(result, { status: 201 });

  } catch (error) {
    console.error('[RLHF API] POST error:', error);
    return NextResponse.json(
      { success: false, error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

// ======================
// GET - Get feedback for a message (optional)
// ======================

export async function GET(request: NextRequest) {
  try {
    const accessToken = getAccessToken(request);
    if (!accessToken) {
      return NextResponse.json(
        { success: false, error: 'No autenticado' },
        { status: 401 }
      );
    }

    const supabase = createAuthenticatedClient(accessToken);
    const context = await getUserContext(supabase);

    if (!context) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 403 }
      );
    }

    const tenantId = context.userRole.tenant_id;

    // Get message_id from query params
    const { searchParams } = new URL(request.url);
    const messageId = searchParams.get('message_id');

    if (!messageId) {
      return NextResponse.json(
        { success: false, error: 'message_id es requerido' },
        { status: 400 }
      );
    }

    // Fetch feedback
    const { data: feedback, error } = await supabase
      .from('ai_rlhf_feedback')
      .select('id, rating, feedback_text, feedback_category, created_at')
      .eq('message_id', messageId)
      .eq('tenant_id', tenantId)
      .maybeSingle();

    if (error) {
      console.error('[RLHF API] GET error:', error);
      return NextResponse.json(
        { success: false, error: 'Error al obtener feedback' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      feedback: feedback || null,
    });

  } catch (error) {
    console.error('[RLHF API] GET error:', error);
    return NextResponse.json(
      { success: false, error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}
```

---

## 4. TESTING

### 4.1 Unit Tests

```typescript
// __tests__/features/ai/services/rlhf/feedback-capture.test.ts

import { describe, it, expect } from 'vitest';
import { validateFeedbackInput } from '@/src/features/ai/services/rlhf/feedback-capture.service';

describe('FeedbackCaptureService', () => {
  describe('validateFeedbackInput', () => {
    it('should accept valid input with required fields only', () => {
      const result = validateFeedbackInput({
        message_id: '550e8400-e29b-41d4-a716-446655440000',
        rating: 'up',
      });

      expect(result.valid).toBe(true);
      if (result.valid) {
        expect(result.data.message_id).toBe('550e8400-e29b-41d4-a716-446655440000');
        expect(result.data.rating).toBe('up');
      }
    });

    it('should accept valid input with all fields', () => {
      const result = validateFeedbackInput({
        message_id: '550e8400-e29b-41d4-a716-446655440000',
        rating: 'down',
        feedback_text: 'La respuesta fue incorrecta',
        feedback_category: 'wrong_info',
      });

      expect(result.valid).toBe(true);
    });

    it('should reject missing message_id', () => {
      const result = validateFeedbackInput({
        rating: 'up',
      });

      expect(result.valid).toBe(false);
      if (!result.valid) {
        expect(result.error).toContain('message_id');
      }
    });

    it('should reject invalid UUID', () => {
      const result = validateFeedbackInput({
        message_id: 'not-a-uuid',
        rating: 'up',
      });

      expect(result.valid).toBe(false);
    });

    it('should reject invalid rating', () => {
      const result = validateFeedbackInput({
        message_id: '550e8400-e29b-41d4-a716-446655440000',
        rating: 'invalid',
      });

      expect(result.valid).toBe(false);
    });

    it('should reject feedback_text exceeding 500 chars', () => {
      const result = validateFeedbackInput({
        message_id: '550e8400-e29b-41d4-a716-446655440000',
        rating: 'down',
        feedback_text: 'a'.repeat(501),
      });

      expect(result.valid).toBe(false);
    });

    it('should reject invalid feedback_category', () => {
      const result = validateFeedbackInput({
        message_id: '550e8400-e29b-41d4-a716-446655440000',
        rating: 'down',
        feedback_category: 'invalid_category',
      });

      expect(result.valid).toBe(false);
    });
  });
});
```

### 4.2 Integration Tests

```typescript
// __tests__/api/rlhf/feedback.test.ts

import { describe, it, expect, beforeAll, afterAll } from 'vitest';

describe('POST /api/rlhf/feedback', () => {
  const validPayload = {
    message_id: '550e8400-e29b-41d4-a716-446655440000',
    rating: 'up',
  };

  it('should return 401 without auth token', async () => {
    const response = await fetch('/api/rlhf/feedback', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(validPayload),
    });

    expect(response.status).toBe(401);
  });

  it('should return 400 with invalid payload', async () => {
    const response = await fetch('/api/rlhf/feedback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer test-token',
      },
      body: JSON.stringify({ rating: 'up' }), // missing message_id
    });

    expect(response.status).toBe(400);
  });

  // Add more integration tests...
});
```

---

## 5. CHECKLIST DE IMPLEMENTACIÃ“N

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CHECKLIST 1.2 - API FEEDBACK                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  â–¡ Tipos TypeScript                                                    â”‚
â”‚    â”œâ”€â”€ [ ] rlhf.types.ts creado                                        â”‚
â”‚    â””â”€â”€ [ ] Todos los tipos exportados                                  â”‚
â”‚                                                                         â”‚
â”‚  â–¡ Servicio de captura                                                 â”‚
â”‚    â”œâ”€â”€ [ ] validateFeedbackInput implementado                          â”‚
â”‚    â”œâ”€â”€ [ ] sanitizeFeedbackText implementado                           â”‚
â”‚    â”œâ”€â”€ [ ] checkRateLimitForLead implementado                          â”‚
â”‚    â”œâ”€â”€ [ ] checkRateLimitForConversation implementado                  â”‚
â”‚    â”œâ”€â”€ [ ] enrichFeedbackWithContext implementado                      â”‚
â”‚    â””â”€â”€ [ ] captureFeedback implementado                                â”‚
â”‚                                                                         â”‚
â”‚  â–¡ API Route                                                           â”‚
â”‚    â”œâ”€â”€ [ ] POST /api/rlhf/feedback                                     â”‚
â”‚    â”œâ”€â”€ [ ] GET /api/rlhf/feedback (opcional)                           â”‚
â”‚    â”œâ”€â”€ [ ] AutenticaciÃ³n funciona                                      â”‚
â”‚    â””â”€â”€ [ ] Rate limiting funciona                                      â”‚
â”‚                                                                         â”‚
â”‚  â–¡ Testing                                                             â”‚
â”‚    â”œâ”€â”€ [ ] Unit tests para validaciÃ³n                                  â”‚
â”‚    â”œâ”€â”€ [ ] Unit tests para sanitizaciÃ³n                                â”‚
â”‚    â””â”€â”€ [ ] Integration tests para API                                  â”‚
â”‚                                                                         â”‚
â”‚  â–¡ DocumentaciÃ³n                                                       â”‚
â”‚    â””â”€â”€ [ ] API documentada en OpenAPI (opcional)                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. PRÃ“XIMOS PASOS

1. âœ… API implementada y testeada
2. â¡ï¸ Continuar con [1.3-UI-COMPONENTS.md](./1.3-UI-COMPONENTS.md)

---

**Documentos relacionados:**
- [1.1-SCHEMA-DB.md](./1.1-SCHEMA-DB.md) - Schema de DB
- [1.3-UI-COMPONENTS.md](./1.3-UI-COMPONENTS.md) - Siguiente: UI Components
