# 3.2 Statistical Tests - Drift Detection

## Descripción General

Este módulo implementa los tests estadísticos necesarios para detectar drift en diferentes dimensiones del sistema de AI Learning. Incluye tests para distribuciones continuas, categóricas, y métricas de rendimiento.

## Tipos de Drift y Tests

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      TIPOS DE DRIFT Y TESTS                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  DATA DRIFT (Input)                                                     │
│  ├── Kolmogorov-Smirnov Test  → Distribuciones continuas               │
│  ├── Chi-Square Test          → Distribuciones categóricas             │
│  ├── Population Stability Index (PSI) → Scoring/binning               │
│  └── Jensen-Shannon Divergence → Embeddings                            │
│                                                                          │
│  CONCEPT DRIFT (Input→Output relationship)                              │
│  ├── Performance Degradation Monitor                                    │
│  ├── Confidence Calibration Test                                        │
│  └── Intent Shift Detection                                             │
│                                                                          │
│  PERFORMANCE DRIFT (Output quality)                                     │
│  ├── CUSUM (Cumulative Sum)   → Cambios graduales                      │
│  ├── Page-Hinkley Test        → Cambios abruptos                       │
│  └── ADWIN (Adaptive Windowing) → Ambos tipos                          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Tipos TypeScript

```typescript
// lib/ai-learning/drift/statistical-tests/types.ts

export interface DriftTestResult {
  testName: string;
  metric: string;
  statistic: number;
  pValue: number;
  threshold: number;
  driftDetected: boolean;
  severity: 'none' | 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  details: Record<string, any>;
}

export interface DriftReport {
  tenantId: string;
  timestamp: Date;
  period: {
    current: { start: Date; end: Date };
    baseline: { start: Date; end: Date };
  };
  results: DriftTestResult[];
  overallDrift: boolean;
  severity: 'none' | 'low' | 'medium' | 'high' | 'critical';
  recommendations: string[];
}

export interface TestConfig {
  // Umbrales de p-value
  pValueThreshold: number; // Default: 0.05

  // Umbrales de severidad (para PSI)
  lowThreshold: number;    // Default: 0.1
  mediumThreshold: number; // Default: 0.2
  highThreshold: number;   // Default: 0.3

  // Configuración de ventana
  minSamples: number;      // Default: 100

  // Corrección de múltiples tests
  bonferroniCorrection: boolean;
}

export const DEFAULT_TEST_CONFIG: TestConfig = {
  pValueThreshold: 0.05,
  lowThreshold: 0.1,
  mediumThreshold: 0.2,
  highThreshold: 0.3,
  minSamples: 100,
  bonferroniCorrection: true,
};
```

## Kolmogorov-Smirnov Test

Test para detectar cambios en distribuciones continuas.

```typescript
// lib/ai-learning/drift/statistical-tests/ks-test.ts

import type { DriftTestResult, TestConfig } from './types';

/**
 * Kolmogorov-Smirnov Test para distribuciones continuas
 * Compara dos muestras para determinar si provienen de la misma distribución
 */
export class KolmogorovSmirnovTest {
  private config: TestConfig;

  constructor(config: Partial<TestConfig> = {}) {
    this.config = { ...DEFAULT_TEST_CONFIG, ...config };
  }

  /**
   * Ejecuta el test KS de dos muestras
   */
  test(
    baseline: number[],
    current: number[],
    metricName: string
  ): DriftTestResult {
    if (baseline.length < this.config.minSamples ||
        current.length < this.config.minSamples) {
      return this.insufficientDataResult(metricName, baseline.length, current.length);
    }

    // Ordenar ambas muestras
    const sortedBaseline = [...baseline].sort((a, b) => a - b);
    const sortedCurrent = [...current].sort((a, b) => a - b);

    // Calcular ECDF (Empirical Cumulative Distribution Function)
    const allValues = [...new Set([...sortedBaseline, ...sortedCurrent])].sort((a, b) => a - b);

    let maxDiff = 0;

    for (const value of allValues) {
      const baselineECDF = this.ecdf(sortedBaseline, value);
      const currentECDF = this.ecdf(sortedCurrent, value);
      const diff = Math.abs(baselineECDF - currentECDF);

      if (diff > maxDiff) {
        maxDiff = diff;
      }
    }

    // Calcular estadístico D ajustado
    const n1 = baseline.length;
    const n2 = current.length;
    const nEffective = Math.sqrt((n1 * n2) / (n1 + n2));
    const dStatistic = maxDiff;

    // Calcular p-value usando aproximación asintótica
    const pValue = this.calculatePValue(dStatistic, nEffective);

    // Determinar severidad
    const severity = this.determineSeverity(dStatistic, pValue);

    return {
      testName: 'Kolmogorov-Smirnov',
      metric: metricName,
      statistic: dStatistic,
      pValue,
      threshold: this.config.pValueThreshold,
      driftDetected: pValue < this.config.pValueThreshold,
      severity,
      confidence: 1 - pValue,
      details: {
        baselineSamples: n1,
        currentSamples: n2,
        baselineMean: this.mean(baseline),
        currentMean: this.mean(current),
        baselineStd: this.std(baseline),
        currentStd: this.std(current),
        maxDifference: maxDiff,
      },
    };
  }

  /**
   * Calcula ECDF para un valor dado
   */
  private ecdf(sortedSample: number[], value: number): number {
    let count = 0;
    for (const x of sortedSample) {
      if (x <= value) count++;
      else break;
    }
    return count / sortedSample.length;
  }

  /**
   * Calcula p-value usando aproximación de Kolmogorov
   */
  private calculatePValue(d: number, nEffective: number): number {
    const lambda = (nEffective + 0.12 + 0.11 / nEffective) * d;

    if (lambda < 0.001) return 1.0;
    if (lambda > 8.0) return 0.0;

    // Aproximación usando serie de Kolmogorov
    let pValue = 0;
    for (let k = 1; k <= 100; k++) {
      const term = Math.pow(-1, k - 1) * Math.exp(-2 * k * k * lambda * lambda);
      pValue += term;
      if (Math.abs(term) < 1e-10) break;
    }

    return Math.max(0, Math.min(1, 2 * pValue));
  }

  /**
   * Determina severidad basada en estadístico D
   */
  private determineSeverity(d: number, pValue: number): DriftTestResult['severity'] {
    if (pValue >= this.config.pValueThreshold) return 'none';
    if (d < 0.1) return 'low';
    if (d < 0.2) return 'medium';
    if (d < 0.3) return 'high';
    return 'critical';
  }

  private mean(arr: number[]): number {
    return arr.reduce((a, b) => a + b, 0) / arr.length;
  }

  private std(arr: number[]): number {
    const m = this.mean(arr);
    const variance = arr.reduce((sum, x) => sum + Math.pow(x - m, 2), 0) / arr.length;
    return Math.sqrt(variance);
  }

  private insufficientDataResult(metric: string, n1: number, n2: number): DriftTestResult {
    return {
      testName: 'Kolmogorov-Smirnov',
      metric,
      statistic: 0,
      pValue: 1,
      threshold: this.config.pValueThreshold,
      driftDetected: false,
      severity: 'none',
      confidence: 0,
      details: {
        error: 'Insufficient data',
        baselineSamples: n1,
        currentSamples: n2,
        required: this.config.minSamples,
      },
    };
  }
}
```

## Chi-Square Test

Test para distribuciones categóricas.

```typescript
// lib/ai-learning/drift/statistical-tests/chi-square-test.ts

import type { DriftTestResult, TestConfig, DEFAULT_TEST_CONFIG } from './types';

/**
 * Chi-Square Test para distribuciones categóricas
 * Compara distribuciones de frecuencia observada vs esperada
 */
export class ChiSquareTest {
  private config: TestConfig;

  constructor(config: Partial<TestConfig> = {}) {
    this.config = { ...DEFAULT_TEST_CONFIG, ...config };
  }

  /**
   * Ejecuta test Chi-Square comparando distribuciones
   */
  test(
    baseline: Record<string, number>,
    current: Record<string, number>,
    metricName: string
  ): DriftTestResult {
    // Obtener todas las categorías
    const allCategories = new Set([
      ...Object.keys(baseline),
      ...Object.keys(current),
    ]);

    const categories = Array.from(allCategories);

    // Convertir a frecuencias
    const baselineTotal = Object.values(baseline).reduce((a, b) => a + b, 0);
    const currentTotal = Object.values(current).reduce((a, b) => a + b, 0);

    if (baselineTotal < this.config.minSamples ||
        currentTotal < this.config.minSamples) {
      return this.insufficientDataResult(metricName, baselineTotal, currentTotal);
    }

    // Calcular frecuencias esperadas (basadas en baseline)
    const baselineProbs: Record<string, number> = {};
    for (const cat of categories) {
      baselineProbs[cat] = (baseline[cat] || 0) / baselineTotal;
    }

    // Calcular estadístico Chi-Square
    let chiSquare = 0;
    const cellContributions: Record<string, number> = {};

    for (const cat of categories) {
      const observed = current[cat] || 0;
      const expected = baselineProbs[cat] * currentTotal;

      // Evitar división por cero con corrección de Yates
      const expectedAdjusted = Math.max(expected, 0.5);
      const contribution = Math.pow(observed - expected, 2) / expectedAdjusted;

      chiSquare += contribution;
      cellContributions[cat] = contribution;
    }

    // Grados de libertad
    const degreesOfFreedom = Math.max(1, categories.length - 1);

    // Calcular p-value
    const pValue = this.chiSquarePValue(chiSquare, degreesOfFreedom);

    // Encontrar categorías con mayor contribución
    const topContributors = Object.entries(cellContributions)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([cat, contrib]) => ({
        category: cat,
        contribution: contrib,
        baselineRate: baselineProbs[cat],
        currentRate: (current[cat] || 0) / currentTotal,
      }));

    const severity = this.determineSeverity(chiSquare, degreesOfFreedom, pValue);

    return {
      testName: 'Chi-Square',
      metric: metricName,
      statistic: chiSquare,
      pValue,
      threshold: this.config.pValueThreshold,
      driftDetected: pValue < this.config.pValueThreshold,
      severity,
      confidence: 1 - pValue,
      details: {
        degreesOfFreedom,
        categories: categories.length,
        baselineSamples: baselineTotal,
        currentSamples: currentTotal,
        topContributors,
        baselineDistribution: baselineProbs,
        currentDistribution: Object.fromEntries(
          categories.map(c => [c, (current[c] || 0) / currentTotal])
        ),
      },
    };
  }

  /**
   * Calcula p-value usando aproximación de chi-square
   */
  private chiSquarePValue(chiSquare: number, df: number): number {
    // Implementación usando aproximación gamma incompleta
    return 1 - this.gammaCDF(chiSquare / 2, df / 2);
  }

  /**
   * CDF de distribución gamma (regularizada)
   */
  private gammaCDF(x: number, a: number): number {
    if (x <= 0) return 0;
    if (x < a + 1) {
      return this.gammaIncLower(a, x) / this.gamma(a);
    } else {
      return 1 - this.gammaIncUpper(a, x) / this.gamma(a);
    }
  }

  /**
   * Función gamma usando aproximación de Stirling
   */
  private gamma(z: number): number {
    const g = 7;
    const c = [
      0.99999999999980993,
      676.5203681218851,
      -1259.1392167224028,
      771.32342877765313,
      -176.61502916214059,
      12.507343278686905,
      -0.13857109526572012,
      9.9843695780195716e-6,
      1.5056327351493116e-7,
    ];

    if (z < 0.5) {
      return Math.PI / (Math.sin(Math.PI * z) * this.gamma(1 - z));
    }

    z -= 1;
    let x = c[0];
    for (let i = 1; i < g + 2; i++) {
      x += c[i] / (z + i);
    }

    const t = z + g + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  }

  /**
   * Gamma incompleta inferior (serie)
   */
  private gammaIncLower(a: number, x: number): number {
    let sum = 0;
    let term = 1 / a;

    for (let n = 1; n < 100; n++) {
      sum += term;
      term *= x / (a + n);
      if (Math.abs(term) < 1e-10) break;
    }

    return Math.pow(x, a) * Math.exp(-x) * sum;
  }

  /**
   * Gamma incompleta superior (fracción continuada)
   */
  private gammaIncUpper(a: number, x: number): number {
    let b = x + 1 - a;
    let c = 1 / 1e-30;
    let d = 1 / b;
    let h = d;

    for (let i = 1; i < 100; i++) {
      const an = -i * (i - a);
      b += 2;
      d = an * d + b;
      if (Math.abs(d) < 1e-30) d = 1e-30;
      c = b + an / c;
      if (Math.abs(c) < 1e-30) c = 1e-30;
      d = 1 / d;
      const del = d * c;
      h *= del;
      if (Math.abs(del - 1) < 1e-10) break;
    }

    return Math.exp(-x + a * Math.log(x)) * h;
  }

  private determineSeverity(
    chiSquare: number,
    df: number,
    pValue: number
  ): DriftTestResult['severity'] {
    if (pValue >= this.config.pValueThreshold) return 'none';

    // Cramér's V para effect size
    const cramersV = Math.sqrt(chiSquare / (this.config.minSamples * df));

    if (cramersV < 0.1) return 'low';
    if (cramersV < 0.3) return 'medium';
    if (cramersV < 0.5) return 'high';
    return 'critical';
  }

  private insufficientDataResult(metric: string, n1: number, n2: number): DriftTestResult {
    return {
      testName: 'Chi-Square',
      metric,
      statistic: 0,
      pValue: 1,
      threshold: this.config.pValueThreshold,
      driftDetected: false,
      severity: 'none',
      confidence: 0,
      details: {
        error: 'Insufficient data',
        baselineSamples: n1,
        currentSamples: n2,
        required: this.config.minSamples,
      },
    };
  }
}
```

## Population Stability Index (PSI)

Métrica estándar en la industria para monitoreo de modelos.

```typescript
// lib/ai-learning/drift/statistical-tests/psi.ts

import type { DriftTestResult, TestConfig, DEFAULT_TEST_CONFIG } from './types';

/**
 * Population Stability Index (PSI)
 * Mide cuánto ha cambiado una distribución respecto a una referencia
 *
 * Interpretación estándar:
 * - PSI < 0.1: No hay cambio significativo
 * - 0.1 <= PSI < 0.2: Cambio moderado, investigar
 * - PSI >= 0.2: Cambio significativo, acción requerida
 */
export class PopulationStabilityIndex {
  private config: TestConfig;

  constructor(config: Partial<TestConfig> = {}) {
    this.config = { ...DEFAULT_TEST_CONFIG, ...config };
  }

  /**
   * Calcula PSI para variables continuas usando buckets
   */
  calculateContinuous(
    baseline: number[],
    current: number[],
    metricName: string,
    numBuckets = 10
  ): DriftTestResult {
    if (baseline.length < this.config.minSamples ||
        current.length < this.config.minSamples) {
      return this.insufficientDataResult(metricName, baseline.length, current.length);
    }

    // Crear buckets basados en quantiles del baseline
    const buckets = this.createQuantileBuckets(baseline, numBuckets);

    // Calcular distribución en cada bucket
    const baselineDist = this.calculateBucketDistribution(baseline, buckets);
    const currentDist = this.calculateBucketDistribution(current, buckets);

    // Calcular PSI
    const { psi, bucketPSIs } = this.calculatePSI(baselineDist, currentDist, buckets);

    // Determinar severidad
    const severity = this.determineSeverity(psi);

    // Encontrar buckets con mayor contribución
    const topBuckets = bucketPSIs
      .map((psiValue, i) => ({
        bucket: `${buckets[i].toFixed(2)} - ${buckets[i + 1]?.toFixed(2) || '∞'}`,
        psi: psiValue,
        baselineRate: baselineDist[i],
        currentRate: currentDist[i],
      }))
      .sort((a, b) => b.psi - a.psi)
      .slice(0, 5);

    return {
      testName: 'Population Stability Index',
      metric: metricName,
      statistic: psi,
      pValue: this.psiToPValue(psi), // Aproximación
      threshold: this.config.mediumThreshold,
      driftDetected: psi >= this.config.lowThreshold,
      severity,
      confidence: Math.min(0.99, psi / this.config.highThreshold),
      details: {
        interpretation: this.getInterpretation(psi),
        numBuckets,
        baselineSamples: baseline.length,
        currentSamples: current.length,
        topContributingBuckets: topBuckets,
        bucketBoundaries: buckets,
        baselineDistribution: baselineDist,
        currentDistribution: currentDist,
      },
    };
  }

  /**
   * Calcula PSI para variables categóricas
   */
  calculateCategorical(
    baseline: Record<string, number>,
    current: Record<string, number>,
    metricName: string
  ): DriftTestResult {
    const categories = [...new Set([
      ...Object.keys(baseline),
      ...Object.keys(current),
    ])];

    const baselineTotal = Object.values(baseline).reduce((a, b) => a + b, 0);
    const currentTotal = Object.values(current).reduce((a, b) => a + b, 0);

    if (baselineTotal < this.config.minSamples ||
        currentTotal < this.config.minSamples) {
      return this.insufficientDataResult(metricName, baselineTotal, currentTotal);
    }

    // Calcular proporciones
    const baselineDist = categories.map(c => (baseline[c] || 0) / baselineTotal);
    const currentDist = categories.map(c => (current[c] || 0) / currentTotal);

    // Calcular PSI
    let psi = 0;
    const categoryPSIs: Record<string, number> = {};

    for (let i = 0; i < categories.length; i++) {
      const baselineP = Math.max(baselineDist[i], 0.0001);
      const currentP = Math.max(currentDist[i], 0.0001);

      const categoryPSI = (currentP - baselineP) * Math.log(currentP / baselineP);
      psi += categoryPSI;
      categoryPSIs[categories[i]] = categoryPSI;
    }

    const severity = this.determineSeverity(psi);

    // Top categorías contribuyentes
    const topCategories = Object.entries(categoryPSIs)
      .sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]))
      .slice(0, 5)
      .map(([cat, psiValue]) => ({
        category: cat,
        psi: psiValue,
        baselineRate: (baseline[cat] || 0) / baselineTotal,
        currentRate: (current[cat] || 0) / currentTotal,
      }));

    return {
      testName: 'Population Stability Index (Categorical)',
      metric: metricName,
      statistic: psi,
      pValue: this.psiToPValue(psi),
      threshold: this.config.mediumThreshold,
      driftDetected: psi >= this.config.lowThreshold,
      severity,
      confidence: Math.min(0.99, psi / this.config.highThreshold),
      details: {
        interpretation: this.getInterpretation(psi),
        categories: categories.length,
        baselineSamples: baselineTotal,
        currentSamples: currentTotal,
        topContributingCategories: topCategories,
        categoryPSIs,
      },
    };
  }

  /**
   * Crea buckets basados en quantiles
   */
  private createQuantileBuckets(data: number[], numBuckets: number): number[] {
    const sorted = [...data].sort((a, b) => a - b);
    const buckets: number[] = [sorted[0]];

    for (let i = 1; i <= numBuckets; i++) {
      const index = Math.floor((i / numBuckets) * (sorted.length - 1));
      const value = sorted[index];
      if (value !== buckets[buckets.length - 1]) {
        buckets.push(value);
      }
    }

    return buckets;
  }

  /**
   * Calcula distribución en buckets
   */
  private calculateBucketDistribution(data: number[], buckets: number[]): number[] {
    const counts = new Array(buckets.length).fill(0);

    for (const value of data) {
      for (let i = 0; i < buckets.length; i++) {
        if (i === buckets.length - 1 || value < buckets[i + 1]) {
          counts[i]++;
          break;
        }
      }
    }

    return counts.map(c => c / data.length);
  }

  /**
   * Calcula PSI total y por bucket
   */
  private calculatePSI(
    baseline: number[],
    current: number[],
    buckets: number[]
  ): { psi: number; bucketPSIs: number[] } {
    let psi = 0;
    const bucketPSIs: number[] = [];

    for (let i = 0; i < baseline.length; i++) {
      const baselineP = Math.max(baseline[i], 0.0001);
      const currentP = Math.max(current[i], 0.0001);

      const bucketPSI = (currentP - baselineP) * Math.log(currentP / baselineP);
      psi += bucketPSI;
      bucketPSIs.push(bucketPSI);
    }

    return { psi, bucketPSIs };
  }

  /**
   * Aproxima p-value desde PSI
   */
  private psiToPValue(psi: number): number {
    // Aproximación empírica
    if (psi < 0.05) return 0.5;
    if (psi < 0.1) return 0.1;
    if (psi < 0.2) return 0.05;
    if (psi < 0.3) return 0.01;
    return 0.001;
  }

  private determineSeverity(psi: number): DriftTestResult['severity'] {
    if (psi < this.config.lowThreshold) return 'none';
    if (psi < this.config.mediumThreshold) return 'low';
    if (psi < this.config.highThreshold) return 'medium';
    if (psi < 0.5) return 'high';
    return 'critical';
  }

  private getInterpretation(psi: number): string {
    if (psi < 0.1) return 'No significant change - distribution is stable';
    if (psi < 0.2) return 'Moderate change - investigation recommended';
    if (psi < 0.3) return 'Significant change - action required';
    return 'Critical change - immediate attention needed';
  }

  private insufficientDataResult(metric: string, n1: number, n2: number): DriftTestResult {
    return {
      testName: 'Population Stability Index',
      metric,
      statistic: 0,
      pValue: 1,
      threshold: this.config.mediumThreshold,
      driftDetected: false,
      severity: 'none',
      confidence: 0,
      details: {
        error: 'Insufficient data',
        baselineSamples: n1,
        currentSamples: n2,
        required: this.config.minSamples,
      },
    };
  }
}
```

## Jensen-Shannon Divergence

Para comparar distribuciones de embeddings.

```typescript
// lib/ai-learning/drift/statistical-tests/js-divergence.ts

import type { DriftTestResult, TestConfig, DEFAULT_TEST_CONFIG } from './types';

/**
 * Jensen-Shannon Divergence
 * Métrica simétrica para comparar distribuciones de probabilidad
 * Útil para embeddings y representaciones vectoriales
 */
export class JensenShannonDivergence {
  private config: TestConfig;

  constructor(config: Partial<TestConfig> = {}) {
    this.config = { ...DEFAULT_TEST_CONFIG, ...config };
  }

  /**
   * Calcula JS Divergence entre dos conjuntos de embeddings
   */
  calculateForEmbeddings(
    baselineEmbeddings: number[][],
    currentEmbeddings: number[][],
    metricName: string,
    numBins = 50
  ): DriftTestResult {
    if (baselineEmbeddings.length < 10 || currentEmbeddings.length < 10) {
      return this.insufficientDataResult(metricName);
    }

    // Calcular centroides
    const baselineCentroid = this.calculateCentroid(baselineEmbeddings);
    const currentCentroid = this.calculateCentroid(currentEmbeddings);

    // Calcular distancias al centroide respectivo
    const baselineDistances = baselineEmbeddings.map(e =>
      this.cosineSimilarity(e, baselineCentroid)
    );
    const currentDistances = currentEmbeddings.map(e =>
      this.cosineSimilarity(e, currentCentroid)
    );

    // Crear histogramas normalizados
    const baselineHist = this.createHistogram(baselineDistances, numBins);
    const currentHist = this.createHistogram(currentDistances, numBins);

    // Calcular JS Divergence
    const jsd = this.calculateJSD(baselineHist, currentHist);

    // También calcular distancia entre centroides
    const centroidSimilarity = this.cosineSimilarity(baselineCentroid, currentCentroid);
    const centroidDrift = 1 - centroidSimilarity;

    const severity = this.determineSeverity(jsd, centroidDrift);

    return {
      testName: 'Jensen-Shannon Divergence',
      metric: metricName,
      statistic: jsd,
      pValue: this.jsdToPValue(jsd),
      threshold: 0.1, // JSD típicamente < 0.1 indica estabilidad
      driftDetected: jsd > 0.1 || centroidDrift > 0.05,
      severity,
      confidence: Math.min(0.99, jsd * 5),
      details: {
        jsDivergence: jsd,
        centroidSimilarity,
        centroidDrift,
        baselineSamples: baselineEmbeddings.length,
        currentSamples: currentEmbeddings.length,
        embeddingDimension: baselineEmbeddings[0]?.length || 0,
        baselineSpread: this.calculateSpread(baselineDistances),
        currentSpread: this.calculateSpread(currentDistances),
      },
    };
  }

  /**
   * Calcula JS Divergence entre dos distribuciones discretas
   */
  calculateForDistributions(
    p: number[],
    q: number[],
    metricName: string
  ): DriftTestResult {
    // Normalizar
    const pSum = p.reduce((a, b) => a + b, 0);
    const qSum = q.reduce((a, b) => a + b, 0);
    const pNorm = p.map(x => x / pSum);
    const qNorm = q.map(x => x / qSum);

    const jsd = this.calculateJSD(pNorm, qNorm);
    const severity = this.determineSeverity(jsd, 0);

    return {
      testName: 'Jensen-Shannon Divergence',
      metric: metricName,
      statistic: jsd,
      pValue: this.jsdToPValue(jsd),
      threshold: 0.1,
      driftDetected: jsd > 0.1,
      severity,
      confidence: Math.min(0.99, jsd * 5),
      details: {
        jsDivergence: jsd,
        klDivergence_P_M: this.klDivergence(pNorm, this.mixture(pNorm, qNorm)),
        klDivergence_Q_M: this.klDivergence(qNorm, this.mixture(pNorm, qNorm)),
      },
    };
  }

  /**
   * Calcula JSD = 0.5 * KL(P||M) + 0.5 * KL(Q||M) donde M = (P+Q)/2
   */
  private calculateJSD(p: number[], q: number[]): number {
    const m = this.mixture(p, q);
    const klPM = this.klDivergence(p, m);
    const klQM = this.klDivergence(q, m);
    return 0.5 * klPM + 0.5 * klQM;
  }

  /**
   * Distribución mezcla
   */
  private mixture(p: number[], q: number[]): number[] {
    return p.map((pVal, i) => (pVal + q[i]) / 2);
  }

  /**
   * KL Divergence
   */
  private klDivergence(p: number[], q: number[]): number {
    let kl = 0;
    for (let i = 0; i < p.length; i++) {
      if (p[i] > 0 && q[i] > 0) {
        kl += p[i] * Math.log(p[i] / q[i]);
      }
    }
    return kl;
  }

  /**
   * Calcula centroide de embeddings
   */
  private calculateCentroid(embeddings: number[][]): number[] {
    const dim = embeddings[0].length;
    const centroid = new Array(dim).fill(0);

    for (const emb of embeddings) {
      for (let i = 0; i < dim; i++) {
        centroid[i] += emb[i];
      }
    }

    for (let i = 0; i < dim; i++) {
      centroid[i] /= embeddings.length;
    }

    return centroid;
  }

  /**
   * Cosine similarity
   */
  private cosineSimilarity(a: number[], b: number[]): number {
    let dot = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < a.length; i++) {
      dot += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }

    return dot / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  /**
   * Crea histograma normalizado
   */
  private createHistogram(values: number[], numBins: number): number[] {
    const min = Math.min(...values);
    const max = Math.max(...values);
    const binWidth = (max - min) / numBins || 1;

    const histogram = new Array(numBins).fill(0);

    for (const value of values) {
      const binIndex = Math.min(
        numBins - 1,
        Math.floor((value - min) / binWidth)
      );
      histogram[binIndex]++;
    }

    // Normalizar con smoothing (Laplace)
    const total = values.length + numBins;
    return histogram.map(count => (count + 1) / total);
  }

  private calculateSpread(values: number[]): number {
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
    return Math.sqrt(variance);
  }

  private jsdToPValue(jsd: number): number {
    // Aproximación empírica
    if (jsd < 0.05) return 0.5;
    if (jsd < 0.1) return 0.1;
    if (jsd < 0.2) return 0.05;
    return 0.01;
  }

  private determineSeverity(jsd: number, centroidDrift: number): DriftTestResult['severity'] {
    const combined = jsd + centroidDrift;
    if (combined < 0.1) return 'none';
    if (combined < 0.2) return 'low';
    if (combined < 0.3) return 'medium';
    if (combined < 0.5) return 'high';
    return 'critical';
  }

  private insufficientDataResult(metric: string): DriftTestResult {
    return {
      testName: 'Jensen-Shannon Divergence',
      metric,
      statistic: 0,
      pValue: 1,
      threshold: 0.1,
      driftDetected: false,
      severity: 'none',
      confidence: 0,
      details: { error: 'Insufficient embedding data' },
    };
  }
}
```

## CUSUM para Performance Drift

```typescript
// lib/ai-learning/drift/statistical-tests/cusum.ts

import type { DriftTestResult, TestConfig, DEFAULT_TEST_CONFIG } from './types';

/**
 * CUSUM (Cumulative Sum) Control Chart
 * Detecta cambios graduales en series temporales de métricas
 */
export class CUSUMDetector {
  private config: TestConfig;

  constructor(config: Partial<TestConfig> = {}) {
    this.config = { ...DEFAULT_TEST_CONFIG, ...config };
  }

  /**
   * Detecta drift en una serie temporal
   */
  detect(
    values: number[],
    metricName: string,
    options: {
      targetMean?: number;
      threshold?: number; // h - decision interval
      slack?: number;     // k - allowance
    } = {}
  ): DriftTestResult {
    if (values.length < 20) {
      return this.insufficientDataResult(metricName, values.length);
    }

    // Calcular parámetros si no se proveen
    const mean = options.targetMean ?? this.calculateMean(values.slice(0, Math.floor(values.length / 2)));
    const std = this.calculateStd(values.slice(0, Math.floor(values.length / 2)));
    const k = options.slack ?? std / 2;
    const h = options.threshold ?? 5 * std;

    // Calcular CUSUM positivo y negativo
    const cusumPos: number[] = [0];
    const cusumNeg: number[] = [0];
    let maxCusumPos = 0;
    let maxCusumNeg = 0;
    let firstViolationIndex = -1;

    for (let i = 0; i < values.length; i++) {
      const xi = values[i];

      // CUSUM positivo (detecta incremento)
      const newPos = Math.max(0, cusumPos[cusumPos.length - 1] + (xi - mean) - k);
      cusumPos.push(newPos);

      // CUSUM negativo (detecta decremento)
      const newNeg = Math.max(0, cusumNeg[cusumNeg.length - 1] - (xi - mean) - k);
      cusumNeg.push(newNeg);

      maxCusumPos = Math.max(maxCusumPos, newPos);
      maxCusumNeg = Math.max(maxCusumNeg, newNeg);

      // Detectar primera violación
      if (firstViolationIndex < 0 && (newPos > h || newNeg > h)) {
        firstViolationIndex = i;
      }
    }

    const driftDetected = maxCusumPos > h || maxCusumNeg > h;
    const statistic = Math.max(maxCusumPos, maxCusumNeg);
    const direction = maxCusumPos > maxCusumNeg ? 'increase' : 'decrease';

    const severity = this.determineSeverity(statistic, h);

    return {
      testName: 'CUSUM',
      metric: metricName,
      statistic,
      pValue: driftDetected ? 0.01 : 0.5, // Simplificado
      threshold: h,
      driftDetected,
      severity,
      confidence: driftDetected ? 0.95 : 0.5,
      details: {
        targetMean: mean,
        standardDeviation: std,
        slack: k,
        decisionInterval: h,
        maxPositiveCusum: maxCusumPos,
        maxNegativeCusum: maxCusumNeg,
        direction,
        firstViolationIndex,
        samplesAnalyzed: values.length,
        currentMean: this.calculateMean(values.slice(-10)),
        meanShift: this.calculateMean(values.slice(-10)) - mean,
      },
    };
  }

  /**
   * Versión online para monitoreo en tiempo real
   */
  createOnlineDetector(
    initialValues: number[],
    options: { threshold?: number; slack?: number } = {}
  ): OnlineCUSUM {
    const mean = this.calculateMean(initialValues);
    const std = this.calculateStd(initialValues);

    return new OnlineCUSUM({
      mean,
      std,
      threshold: options.threshold ?? 5 * std,
      slack: options.slack ?? std / 2,
    });
  }

  private calculateMean(values: number[]): number {
    return values.reduce((a, b) => a + b, 0) / values.length;
  }

  private calculateStd(values: number[]): number {
    const mean = this.calculateMean(values);
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
    return Math.sqrt(variance);
  }

  private determineSeverity(statistic: number, threshold: number): DriftTestResult['severity'] {
    const ratio = statistic / threshold;
    if (ratio < 0.5) return 'none';
    if (ratio < 1) return 'low';
    if (ratio < 1.5) return 'medium';
    if (ratio < 2) return 'high';
    return 'critical';
  }

  private insufficientDataResult(metric: string, n: number): DriftTestResult {
    return {
      testName: 'CUSUM',
      metric,
      statistic: 0,
      pValue: 1,
      threshold: 0,
      driftDetected: false,
      severity: 'none',
      confidence: 0,
      details: {
        error: 'Insufficient data',
        samples: n,
        required: 20,
      },
    };
  }
}

/**
 * CUSUM online para monitoreo en tiempo real
 */
export class OnlineCUSUM {
  private mean: number;
  private std: number;
  private threshold: number;
  private slack: number;
  private cusumPos = 0;
  private cusumNeg = 0;
  private count = 0;

  constructor(params: {
    mean: number;
    std: number;
    threshold: number;
    slack: number;
  }) {
    this.mean = params.mean;
    this.std = params.std;
    this.threshold = params.threshold;
    this.slack = params.slack;
  }

  /**
   * Procesa un nuevo valor y retorna si hay drift
   */
  update(value: number): {
    driftDetected: boolean;
    direction: 'increase' | 'decrease' | 'none';
    cusumPos: number;
    cusumNeg: number;
  } {
    this.count++;

    this.cusumPos = Math.max(0, this.cusumPos + (value - this.mean) - this.slack);
    this.cusumNeg = Math.max(0, this.cusumNeg - (value - this.mean) - this.slack);

    let direction: 'increase' | 'decrease' | 'none' = 'none';
    let driftDetected = false;

    if (this.cusumPos > this.threshold) {
      driftDetected = true;
      direction = 'increase';
    } else if (this.cusumNeg > this.threshold) {
      driftDetected = true;
      direction = 'decrease';
    }

    return {
      driftDetected,
      direction,
      cusumPos: this.cusumPos,
      cusumNeg: this.cusumNeg,
    };
  }

  /**
   * Reset después de detectar drift
   */
  reset(): void {
    this.cusumPos = 0;
    this.cusumNeg = 0;
  }

  getState(): { cusumPos: number; cusumNeg: number; count: number } {
    return {
      cusumPos: this.cusumPos,
      cusumNeg: this.cusumNeg,
      count: this.count,
    };
  }
}
```

## Drift Detector Service

Orquesta todos los tests.

```typescript
// lib/ai-learning/drift/drift-detector.ts

import { createClient } from '@/lib/supabase/server';
import { KolmogorovSmirnovTest } from './statistical-tests/ks-test';
import { ChiSquareTest } from './statistical-tests/chi-square-test';
import { PopulationStabilityIndex } from './statistical-tests/psi';
import { JensenShannonDivergence } from './statistical-tests/js-divergence';
import { CUSUMDetector } from './statistical-tests/cusum';
import type {
  DriftTestResult,
  DriftReport,
  TestConfig,
  DEFAULT_TEST_CONFIG,
  InputSnapshot,
  OutputSnapshot,
  PerformanceSnapshot,
} from './types';

export class DriftDetector {
  private ksTest: KolmogorovSmirnovTest;
  private chiSquare: ChiSquareTest;
  private psi: PopulationStabilityIndex;
  private jsDivergence: JensenShannonDivergence;
  private cusum: CUSUMDetector;
  private config: TestConfig;

  constructor(config: Partial<TestConfig> = {}) {
    this.config = { ...DEFAULT_TEST_CONFIG, ...config };
    this.ksTest = new KolmogorovSmirnovTest(this.config);
    this.chiSquare = new ChiSquareTest(this.config);
    this.psi = new PopulationStabilityIndex(this.config);
    this.jsDivergence = new JensenShannonDivergence(this.config);
    this.cusum = new CUSUMDetector(this.config);
  }

  /**
   * Ejecuta análisis completo de drift para un tenant
   */
  async analyzeForTenant(
    tenantId: string,
    currentPeriod: { start: Date; end: Date },
    baselinePeriod?: { start: Date; end: Date }
  ): Promise<DriftReport> {
    const supabase = await createClient();

    // Obtener baseline (o usar período anterior)
    const baseline = baselinePeriod || this.calculateBaselinePeriod(currentPeriod);

    // Obtener snapshots
    const [currentInput, baselineInput] = await Promise.all([
      this.getInputSnapshots(tenantId, currentPeriod.start, currentPeriod.end),
      this.getInputSnapshots(tenantId, baseline.start, baseline.end),
    ]);

    const [currentOutput, baselineOutput] = await Promise.all([
      this.getOutputSnapshots(tenantId, currentPeriod.start, currentPeriod.end),
      this.getOutputSnapshots(tenantId, baseline.start, baseline.end),
    ]);

    const [currentPerf, baselinePerf] = await Promise.all([
      this.getPerformanceSnapshots(tenantId, currentPeriod.start, currentPeriod.end),
      this.getPerformanceSnapshots(tenantId, baseline.start, baseline.end),
    ]);

    const results: DriftTestResult[] = [];

    // Analizar Input Drift
    if (currentInput.length > 0 && baselineInput.length > 0) {
      results.push(...this.analyzeInputDrift(currentInput, baselineInput));
    }

    // Analizar Output Drift
    if (currentOutput.length > 0 && baselineOutput.length > 0) {
      results.push(...this.analyzeOutputDrift(currentOutput, baselineOutput));
    }

    // Analizar Performance Drift
    if (currentPerf.length > 0 && baselinePerf.length > 0) {
      results.push(...this.analyzePerformanceDrift(currentPerf, baselinePerf));
    }

    // Aplicar corrección de Bonferroni si está habilitada
    if (this.config.bonferroniCorrection && results.length > 1) {
      const correctedThreshold = this.config.pValueThreshold / results.length;
      for (const result of results) {
        result.threshold = correctedThreshold;
        result.driftDetected = result.pValue < correctedThreshold;
      }
    }

    // Calcular severidad general
    const driftResults = results.filter(r => r.driftDetected);
    const overallSeverity = this.calculateOverallSeverity(driftResults);

    // Generar recomendaciones
    const recommendations = this.generateRecommendations(results);

    const report: DriftReport = {
      tenantId,
      timestamp: new Date(),
      period: {
        current: currentPeriod,
        baseline: baseline,
      },
      results,
      overallDrift: driftResults.length > 0,
      severity: overallSeverity,
      recommendations,
    };

    // Guardar reporte
    await this.saveDriftReport(report);

    return report;
  }

  /**
   * Analiza drift en inputs
   */
  private analyzeInputDrift(
    current: InputSnapshot[],
    baseline: InputSnapshot[]
  ): DriftTestResult[] {
    const results: DriftTestResult[] = [];

    // Extraer métricas agregadas
    const currentLengths = current.map(s => s.avgMessageLength);
    const baselineLengths = baseline.map(s => s.avgMessageLength);

    // KS Test para longitud de mensajes
    results.push(this.ksTest.test(
      baselineLengths,
      currentLengths,
      'message_length'
    ));

    // PSI para distribución de intents
    const currentIntents = this.aggregateDistributions(
      current.map(s => s.intentDistribution)
    );
    const baselineIntents = this.aggregateDistributions(
      baseline.map(s => s.intentDistribution)
    );

    results.push(this.psi.calculateCategorical(
      baselineIntents,
      currentIntents,
      'intent_distribution'
    ));

    // Chi-Square para top tokens (si disponible)
    const currentTokens = this.aggregateTokens(current.flatMap(s => s.topTokens || []));
    const baselineTokens = this.aggregateTokens(baseline.flatMap(s => s.topTokens || []));

    if (Object.keys(currentTokens).length > 0 && Object.keys(baselineTokens).length > 0) {
      results.push(this.chiSquare.test(
        baselineTokens,
        currentTokens,
        'vocabulary_distribution'
      ));
    }

    return results;
  }

  /**
   * Analiza drift en outputs
   */
  private analyzeOutputDrift(
    current: OutputSnapshot[],
    baseline: OutputSnapshot[]
  ): DriftTestResult[] {
    const results: DriftTestResult[] = [];

    // KS Test para confianza
    const currentConfidences = current.map(s => s.avgConfidence);
    const baselineConfidences = baseline.map(s => s.avgConfidence);

    results.push(this.ksTest.test(
      baselineConfidences,
      currentConfidences,
      'confidence_score'
    ));

    // PSI para distribución de acciones
    const currentActions = this.aggregateDistributions(
      current.map(s => s.actionDistribution)
    );
    const baselineActions = this.aggregateDistributions(
      baseline.map(s => s.actionDistribution)
    );

    results.push(this.psi.calculateCategorical(
      baselineActions,
      currentActions,
      'action_distribution'
    ));

    // KS Test para tasa de escalación
    const currentEscalation = current.map(s => s.escalationRate);
    const baselineEscalation = baseline.map(s => s.escalationRate);

    results.push(this.ksTest.test(
      baselineEscalation,
      currentEscalation,
      'escalation_rate'
    ));

    return results;
  }

  /**
   * Analiza drift en performance
   */
  private analyzePerformanceDrift(
    current: PerformanceSnapshot[],
    baseline: PerformanceSnapshot[]
  ): DriftTestResult[] {
    const results: DriftTestResult[] = [];

    // CUSUM para tasa de feedback positivo
    const positiveRates = [...baseline, ...current].map(s => s.positiveFeedbackRate);
    results.push(this.cusum.detect(positiveRates, 'positive_feedback_rate'));

    // KS Test para latencia
    const currentLatencies = current.map(s => s.p95ResponseTimeMs);
    const baselineLatencies = baseline.map(s => s.p95ResponseTimeMs);

    results.push(this.ksTest.test(
      baselineLatencies,
      currentLatencies,
      'p95_latency'
    ));

    // CUSUM para tasa de error
    const errorRates = [...baseline, ...current].map(s => s.errorRate);
    results.push(this.cusum.detect(errorRates, 'error_rate'));

    // KS Test para tasa de resolución
    const currentResolution = current.map(s => s.resolutionRate);
    const baselineResolution = baseline.map(s => s.resolutionRate);

    results.push(this.ksTest.test(
      baselineResolution,
      currentResolution,
      'resolution_rate'
    ));

    return results;
  }

  // Helper methods
  private aggregateDistributions(
    distributions: Array<Record<string, number>>
  ): Record<string, number> {
    const aggregated: Record<string, number> = {};

    for (const dist of distributions) {
      for (const [key, value] of Object.entries(dist)) {
        aggregated[key] = (aggregated[key] || 0) + value;
      }
    }

    return aggregated;
  }

  private aggregateTokens(
    tokens: Array<{ token: string; count: number }>
  ): Record<string, number> {
    const aggregated: Record<string, number> = {};

    for (const { token, count } of tokens) {
      aggregated[token] = (aggregated[token] || 0) + count;
    }

    return aggregated;
  }

  private calculateBaselinePeriod(
    currentPeriod: { start: Date; end: Date }
  ): { start: Date; end: Date } {
    const duration = currentPeriod.end.getTime() - currentPeriod.start.getTime();

    return {
      start: new Date(currentPeriod.start.getTime() - duration),
      end: currentPeriod.start,
    };
  }

  private calculateOverallSeverity(
    driftResults: DriftTestResult[]
  ): DriftReport['severity'] {
    if (driftResults.length === 0) return 'none';

    const severityOrder = ['none', 'low', 'medium', 'high', 'critical'];
    const maxSeverity = driftResults.reduce((max, r) => {
      const current = severityOrder.indexOf(r.severity);
      const maxIndex = severityOrder.indexOf(max);
      return current > maxIndex ? r.severity : max;
    }, 'none' as DriftTestResult['severity']);

    return maxSeverity;
  }

  private generateRecommendations(results: DriftTestResult[]): string[] {
    const recommendations: string[] = [];
    const driftResults = results.filter(r => r.driftDetected);

    if (driftResults.length === 0) {
      recommendations.push('No significant drift detected. Continue monitoring.');
      return recommendations;
    }

    for (const result of driftResults) {
      switch (result.metric) {
        case 'message_length':
          recommendations.push(
            'Input message length distribution has changed. Review if user communication patterns have shifted.'
          );
          break;
        case 'intent_distribution':
          recommendations.push(
            'Intent distribution has drifted. Consider updating training data or adding new intent categories.'
          );
          break;
        case 'confidence_score':
          recommendations.push(
            'Model confidence scores have shifted. Review recent predictions for calibration issues.'
          );
          break;
        case 'positive_feedback_rate':
          recommendations.push(
            'User satisfaction metrics have changed. Investigate recent changes to prompts or model behavior.'
          );
          break;
        case 'error_rate':
          recommendations.push(
            'Error rate has increased. Check for system issues or API changes.'
          );
          break;
        default:
          recommendations.push(
            `Drift detected in ${result.metric}. Review recent changes and monitor closely.`
          );
      }
    }

    if (driftResults.some(r => r.severity === 'critical')) {
      recommendations.unshift(
        'CRITICAL: Immediate attention required. Consider rollback or model retraining.'
      );
    }

    return recommendations;
  }

  private async getInputSnapshots(
    tenantId: string,
    start: Date,
    end: Date
  ): Promise<InputSnapshot[]> {
    const supabase = await createClient();

    const { data } = await supabase
      .from('ai_drift_input_snapshots')
      .select('*')
      .eq('tenant_id', tenantId)
      .gte('period_start', start.toISOString())
      .lte('period_end', end.toISOString())
      .order('period_start', { ascending: true });

    return (data || []).map(this.mapInputSnapshot);
  }

  private async getOutputSnapshots(
    tenantId: string,
    start: Date,
    end: Date
  ): Promise<OutputSnapshot[]> {
    const supabase = await createClient();

    const { data } = await supabase
      .from('ai_drift_output_snapshots')
      .select('*')
      .eq('tenant_id', tenantId)
      .gte('period_start', start.toISOString())
      .lte('period_end', end.toISOString())
      .order('period_start', { ascending: true });

    return (data || []).map(this.mapOutputSnapshot);
  }

  private async getPerformanceSnapshots(
    tenantId: string,
    start: Date,
    end: Date
  ): Promise<PerformanceSnapshot[]> {
    const supabase = await createClient();

    const { data } = await supabase
      .from('ai_drift_performance_snapshots')
      .select('*')
      .eq('tenant_id', tenantId)
      .gte('period_start', start.toISOString())
      .lte('period_end', end.toISOString())
      .order('period_start', { ascending: true });

    return (data || []).map(this.mapPerformanceSnapshot);
  }

  private mapInputSnapshot(row: any): InputSnapshot {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      periodStart: new Date(row.period_start),
      periodEnd: new Date(row.period_end),
      granularity: row.granularity,
      avgMessageLength: row.avg_message_length,
      stdMessageLength: row.std_message_length,
      minMessageLength: row.min_message_length,
      maxMessageLength: row.max_message_length,
      lengthHistogram: row.length_histogram,
      uniqueTokens: row.unique_tokens,
      vocabularySize: row.vocabulary_size,
      oovRate: row.oov_rate,
      topTokens: row.top_tokens,
      intentDistribution: row.intent_distribution,
      embeddingCentroid: row.embedding_centroid,
      embeddingSpread: row.embedding_spread,
      messageCount: row.message_count,
      createdAt: new Date(row.created_at),
    };
  }

  private mapOutputSnapshot(row: any): OutputSnapshot {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      periodStart: new Date(row.period_start),
      periodEnd: new Date(row.period_end),
      granularity: row.granularity,
      avgResponseLength: row.avg_response_length,
      stdResponseLength: row.std_response_length,
      actionDistribution: row.action_distribution,
      avgConfidence: row.avg_confidence,
      confidenceHistogram: row.confidence_histogram,
      escalationRate: row.escalation_rate,
      avgTokensUsed: row.avg_tokens_used,
      totalTokensUsed: row.total_tokens_used,
      responseCount: row.response_count,
      createdAt: new Date(row.created_at),
    };
  }

  private mapPerformanceSnapshot(row: any): PerformanceSnapshot {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      periodStart: new Date(row.period_start),
      periodEnd: new Date(row.period_end),
      granularity: row.granularity,
      positiveFeedbackRate: row.positive_feedback_rate,
      negativeFeedbackRate: row.negative_feedback_rate,
      noFeedbackRate: row.no_feedback_rate,
      resolutionRate: row.resolution_rate,
      avgTurnsToResolution: row.avg_turns_to_resolution,
      avgResponseTimeMs: row.avg_response_time_ms,
      p50ResponseTimeMs: row.p50_response_time_ms,
      p95ResponseTimeMs: row.p95_response_time_ms,
      p99ResponseTimeMs: row.p99_response_time_ms,
      errorRate: row.error_rate,
      timeoutRate: row.timeout_rate,
      totalConversations: row.total_conversations,
      totalMessages: row.total_messages,
      uniqueUsers: row.unique_users,
      createdAt: new Date(row.created_at),
    };
  }

  private async saveDriftReport(report: DriftReport): Promise<void> {
    const supabase = await createClient();

    await supabase.from('ai_drift_reports').insert({
      tenant_id: report.tenantId,
      period_start: report.period.current.start.toISOString(),
      period_end: report.period.current.end.toISOString(),
      baseline_start: report.period.baseline.start.toISOString(),
      baseline_end: report.period.baseline.end.toISOString(),
      overall_drift: report.overallDrift,
      severity: report.severity,
      results: report.results,
      recommendations: report.recommendations,
    });
  }
}
```

## Siguiente Documento

Continúa con [3.3-ALERT-SYSTEM.md](./3.3-ALERT-SYSTEM.md) para la implementación del sistema de alertas de drift.
