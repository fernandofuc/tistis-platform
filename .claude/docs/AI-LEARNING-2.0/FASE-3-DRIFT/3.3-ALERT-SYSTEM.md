# 3.3 Alert System - Drift Detection

## DescripciÃ³n General

El sistema de alertas monitorea continuamente los resultados de detecciÃ³n de drift y notifica a los stakeholders relevantes cuando se detectan anomalÃ­as. Soporta mÃºltiples canales de notificaciÃ³n y configuraciÃ³n de umbrales por tenant.

## Arquitectura

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ALERT SYSTEM ARCHITECTURE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                     â”‚
â”‚  â”‚ Drift Detector â”‚                                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                     â”‚
â”‚          â”‚                                                              â”‚
â”‚          â–¼                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ Alert Manager  â”‚â”€â”€â”€â”€â–¶â”‚ Alert Rules  â”‚â”€â”€â”€â”€â–¶â”‚ Alert Store  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚          â”‚                                                              â”‚
â”‚          â–¼                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚                    NOTIFICATION CHANNELS                    â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚
â”‚  â”‚   Email    â”‚   Slack    â”‚  Webhook   â”‚   In-App          â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Schema de Base de Datos

```sql
-- =====================================================
-- TABLAS PARA SISTEMA DE ALERTAS
-- =====================================================

-- Reglas de alerta configurables por tenant
CREATE TABLE ai_drift_alert_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),

  -- IdentificaciÃ³n
  name TEXT NOT NULL,
  description TEXT,

  -- Condiciones
  metric_name TEXT NOT NULL, -- 'message_length', 'intent_distribution', etc.
  condition_type TEXT NOT NULL, -- 'severity_gte' | 'pvalue_lte' | 'statistic_gte'
  threshold_value FLOAT NOT NULL,

  -- Severidad mÃ­nima para activar
  min_severity TEXT NOT NULL DEFAULT 'medium', -- 'low' | 'medium' | 'high' | 'critical'

  -- ConfiguraciÃ³n de notificaciÃ³n
  notification_channels JSONB NOT NULL DEFAULT '[]', -- ['email', 'slack', 'webhook']
  recipients JSONB NOT NULL DEFAULT '[]', -- emails, slack channels, webhook urls
  cooldown_minutes INT NOT NULL DEFAULT 60, -- Evitar spam de alertas

  -- Estado
  is_active BOOLEAN NOT NULL DEFAULT true,

  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES users(id),

  UNIQUE(tenant_id, name)
);

-- Alertas generadas
CREATE TABLE ai_drift_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),

  -- Referencia a regla que la generÃ³
  rule_id UUID NOT NULL REFERENCES ai_drift_alert_rules(id),

  -- Detalles del drift
  drift_report_id UUID, -- Referencia al reporte de drift
  metric_name TEXT NOT NULL,
  severity TEXT NOT NULL,
  statistic FLOAT NOT NULL,
  p_value FLOAT,
  details JSONB NOT NULL,

  -- Estado de la alerta
  status TEXT NOT NULL DEFAULT 'open', -- 'open' | 'acknowledged' | 'resolved' | 'dismissed'
  acknowledged_at TIMESTAMPTZ,
  acknowledged_by UUID REFERENCES users(id),
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES users(id),
  resolution_notes TEXT,

  -- Notificaciones
  notifications_sent JSONB NOT NULL DEFAULT '[]',

  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Historial de notificaciones
CREATE TABLE ai_drift_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  alert_id UUID NOT NULL REFERENCES ai_drift_alerts(id),

  -- Detalles de envÃ­o
  channel TEXT NOT NULL, -- 'email' | 'slack' | 'webhook' | 'in_app'
  recipient TEXT NOT NULL,
  status TEXT NOT NULL, -- 'sent' | 'failed' | 'pending'
  error_message TEXT,

  -- Contenido enviado
  subject TEXT,
  body TEXT,
  payload JSONB,

  -- Metadata
  sent_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Reportes de drift (referencia desde alerts)
CREATE TABLE ai_drift_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),

  -- PerÃ­odo analizado
  period_start TIMESTAMPTZ NOT NULL,
  period_end TIMESTAMPTZ NOT NULL,
  baseline_start TIMESTAMPTZ NOT NULL,
  baseline_end TIMESTAMPTZ NOT NULL,

  -- Resultados
  overall_drift BOOLEAN NOT NULL,
  severity TEXT NOT NULL,
  results JSONB NOT NULL,
  recommendations JSONB NOT NULL DEFAULT '[]',

  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Ãndices
CREATE INDEX idx_alert_rules_tenant ON ai_drift_alert_rules(tenant_id) WHERE is_active = true;
CREATE INDEX idx_alerts_tenant_status ON ai_drift_alerts(tenant_id, status, created_at DESC);
CREATE INDEX idx_alerts_rule ON ai_drift_alerts(rule_id, created_at DESC);
CREATE INDEX idx_notifications_alert ON ai_drift_notifications(alert_id);
CREATE INDEX idx_drift_reports_tenant ON ai_drift_reports(tenant_id, created_at DESC);

-- RLS Policies
ALTER TABLE ai_drift_alert_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_drift_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_drift_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_drift_reports ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation ON ai_drift_alert_rules
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_drift_alerts
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_drift_notifications
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_drift_reports
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);
```

## Tipos TypeScript

```typescript
// lib/ai-learning/drift/alerts/types.ts

export interface AlertRule {
  id: string;
  tenantId: string;
  name: string;
  description?: string;
  metricName: string;
  conditionType: 'severity_gte' | 'pvalue_lte' | 'statistic_gte';
  thresholdValue: number;
  minSeverity: 'low' | 'medium' | 'high' | 'critical';
  notificationChannels: NotificationChannel[];
  recipients: Recipient[];
  cooldownMinutes: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
}

export type NotificationChannel = 'email' | 'slack' | 'webhook' | 'in_app';

export interface Recipient {
  type: NotificationChannel;
  value: string; // email, slack channel, webhook URL, user ID
  name?: string;
}

export interface Alert {
  id: string;
  tenantId: string;
  ruleId: string;
  driftReportId?: string;
  metricName: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  statistic: number;
  pValue?: number;
  details: Record<string, any>;
  status: 'open' | 'acknowledged' | 'resolved' | 'dismissed';
  acknowledgedAt?: Date;
  acknowledgedBy?: string;
  resolvedAt?: Date;
  resolvedBy?: string;
  resolutionNotes?: string;
  notificationsSent: NotificationRecord[];
  createdAt: Date;
  updatedAt: Date;
}

export interface NotificationRecord {
  id: string;
  channel: NotificationChannel;
  recipient: string;
  status: 'sent' | 'failed' | 'pending';
  sentAt?: Date;
}

export interface AlertNotification {
  id: string;
  tenantId: string;
  alertId: string;
  channel: NotificationChannel;
  recipient: string;
  status: 'sent' | 'failed' | 'pending';
  errorMessage?: string;
  subject?: string;
  body?: string;
  payload?: Record<string, any>;
  sentAt?: Date;
  createdAt: Date;
}

export interface AlertSummary {
  total: number;
  open: number;
  acknowledged: number;
  resolved: number;
  bySeverity: Record<string, number>;
  byMetric: Record<string, number>;
  recentTrend: 'increasing' | 'stable' | 'decreasing';
}
```

## Alert Manager

```typescript
// lib/ai-learning/drift/alerts/alert-manager.ts

import { createClient } from '@/lib/supabase/server';
import { EmailNotifier } from './notifiers/email-notifier';
import { SlackNotifier } from './notifiers/slack-notifier';
import { WebhookNotifier } from './notifiers/webhook-notifier';
import { InAppNotifier } from './notifiers/in-app-notifier';
import type {
  AlertRule,
  Alert,
  NotificationChannel,
  Recipient,
  AlertSummary,
} from './types';
import type { DriftReport, DriftTestResult } from '../types';

export class AlertManager {
  private emailNotifier: EmailNotifier;
  private slackNotifier: SlackNotifier;
  private webhookNotifier: WebhookNotifier;
  private inAppNotifier: InAppNotifier;

  constructor() {
    this.emailNotifier = new EmailNotifier();
    this.slackNotifier = new SlackNotifier();
    this.webhookNotifier = new WebhookNotifier();
    this.inAppNotifier = new InAppNotifier();
  }

  /**
   * Procesa un reporte de drift y genera alertas segÃºn las reglas
   */
  async processReport(report: DriftReport): Promise<Alert[]> {
    const supabase = await createClient();

    // Obtener reglas activas para el tenant
    const { data: rules } = await supabase
      .from('ai_drift_alert_rules')
      .select('*')
      .eq('tenant_id', report.tenantId)
      .eq('is_active', true);

    if (!rules || rules.length === 0) {
      return [];
    }

    const alerts: Alert[] = [];

    for (const result of report.results) {
      if (!result.driftDetected) continue;

      // Evaluar cada regla
      for (const ruleRow of rules) {
        const rule = this.mapRule(ruleRow);

        if (this.shouldTrigger(rule, result)) {
          // Verificar cooldown
          const isInCooldown = await this.isInCooldown(rule);
          if (isInCooldown) continue;

          // Crear alerta
          const alert = await this.createAlert(rule, result, report);
          alerts.push(alert);

          // Enviar notificaciones
          await this.sendNotifications(alert, rule, result);
        }
      }
    }

    return alerts;
  }

  /**
   * EvalÃºa si una regla debe dispararse para un resultado
   */
  private shouldTrigger(rule: AlertRule, result: DriftTestResult): boolean {
    // Verificar mÃ©trica
    if (rule.metricName !== '*' && rule.metricName !== result.metric) {
      return false;
    }

    // Verificar severidad mÃ­nima
    const severityOrder = ['low', 'medium', 'high', 'critical'];
    const resultSeverityIndex = severityOrder.indexOf(result.severity);
    const minSeverityIndex = severityOrder.indexOf(rule.minSeverity);

    if (resultSeverityIndex < minSeverityIndex) {
      return false;
    }

    // Evaluar condiciÃ³n
    switch (rule.conditionType) {
      case 'severity_gte':
        return resultSeverityIndex >= rule.thresholdValue;

      case 'pvalue_lte':
        return result.pValue <= rule.thresholdValue;

      case 'statistic_gte':
        return result.statistic >= rule.thresholdValue;

      default:
        return false;
    }
  }

  /**
   * Verifica si la regla estÃ¡ en perÃ­odo de cooldown
   */
  private async isInCooldown(rule: AlertRule): Promise<boolean> {
    const supabase = await createClient();

    const cooldownStart = new Date();
    cooldownStart.setMinutes(cooldownStart.getMinutes() - rule.cooldownMinutes);

    const { count } = await supabase
      .from('ai_drift_alerts')
      .select('id', { count: 'exact', head: true })
      .eq('rule_id', rule.id)
      .gte('created_at', cooldownStart.toISOString());

    return (count || 0) > 0;
  }

  /**
   * Crea una nueva alerta en la base de datos
   */
  private async createAlert(
    rule: AlertRule,
    result: DriftTestResult,
    report: DriftReport
  ): Promise<Alert> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_drift_alerts')
      .insert({
        tenant_id: rule.tenantId,
        rule_id: rule.id,
        metric_name: result.metric,
        severity: result.severity,
        statistic: result.statistic,
        p_value: result.pValue,
        details: {
          testName: result.testName,
          threshold: result.threshold,
          confidence: result.confidence,
          ...result.details,
          reportPeriod: report.period,
          recommendations: report.recommendations,
        },
        status: 'open',
        notifications_sent: [],
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating alert:', error);
      throw error;
    }

    return this.mapAlert(data);
  }

  /**
   * EnvÃ­a notificaciones por todos los canales configurados
   */
  private async sendNotifications(
    alert: Alert,
    rule: AlertRule,
    result: DriftTestResult
  ): Promise<void> {
    const context = this.buildNotificationContext(alert, rule, result);

    for (const channel of rule.notificationChannels) {
      const recipients = rule.recipients.filter(r => r.type === channel);

      for (const recipient of recipients) {
        try {
          await this.sendNotification(channel, recipient, alert, context);
        } catch (error) {
          console.error(`Failed to send ${channel} notification:`, error);
          await this.recordNotificationFailure(alert.id, channel, recipient.value, String(error));
        }
      }
    }
  }

  /**
   * EnvÃ­a una notificaciÃ³n individual
   */
  private async sendNotification(
    channel: NotificationChannel,
    recipient: Recipient,
    alert: Alert,
    context: NotificationContext
  ): Promise<void> {
    const supabase = await createClient();

    let result: { success: boolean; error?: string };

    switch (channel) {
      case 'email':
        result = await this.emailNotifier.send(recipient.value, context);
        break;
      case 'slack':
        result = await this.slackNotifier.send(recipient.value, context);
        break;
      case 'webhook':
        result = await this.webhookNotifier.send(recipient.value, context);
        break;
      case 'in_app':
        result = await this.inAppNotifier.send(recipient.value, context);
        break;
      default:
        result = { success: false, error: `Unknown channel: ${channel}` };
    }

    // Registrar notificaciÃ³n
    await supabase.from('ai_drift_notifications').insert({
      tenant_id: alert.tenantId,
      alert_id: alert.id,
      channel,
      recipient: recipient.value,
      status: result.success ? 'sent' : 'failed',
      error_message: result.error,
      subject: context.subject,
      body: context.body,
      payload: context.payload,
      sent_at: result.success ? new Date().toISOString() : null,
    });

    // Actualizar lista de notificaciones en alert
    await supabase
      .from('ai_drift_alerts')
      .update({
        notifications_sent: supabase.sql`
          notifications_sent || ${JSON.stringify([{
            channel,
            recipient: recipient.value,
            status: result.success ? 'sent' : 'failed',
            sentAt: result.success ? new Date().toISOString() : null,
          }])}::jsonb
        `,
        updated_at: new Date().toISOString(),
      })
      .eq('id', alert.id);
  }

  private async recordNotificationFailure(
    alertId: string,
    channel: NotificationChannel,
    recipient: string,
    error: string
  ): Promise<void> {
    const supabase = await createClient();

    await supabase.from('ai_drift_notifications').insert({
      alert_id: alertId,
      channel,
      recipient,
      status: 'failed',
      error_message: error,
    });
  }

  /**
   * Construye el contexto para notificaciones
   */
  private buildNotificationContext(
    alert: Alert,
    rule: AlertRule,
    result: DriftTestResult
  ): NotificationContext {
    const severityEmoji = {
      low: 'ğŸŸ¡',
      medium: 'ğŸŸ ',
      high: 'ğŸ”´',
      critical: 'ğŸš¨',
    }[alert.severity];

    const subject = `${severityEmoji} Drift Alert: ${result.metric} - ${alert.severity.toUpperCase()}`;

    const body = `
## AI Learning Drift Alert

**Metric:** ${result.metric}
**Severity:** ${alert.severity.toUpperCase()}
**Test:** ${result.testName}

### Statistics
- Statistic: ${result.statistic.toFixed(4)}
- P-Value: ${result.pValue?.toFixed(4) || 'N/A'}
- Threshold: ${result.threshold}
- Confidence: ${(result.confidence * 100).toFixed(1)}%

### Details
${JSON.stringify(result.details, null, 2)}

### Recommendations
${alert.details.recommendations?.map((r: string) => `- ${r}`).join('\n') || 'No recommendations available.'}

---
*Alert Rule: ${rule.name}*
*Generated at: ${alert.createdAt.toISOString()}*
    `.trim();

    return {
      alertId: alert.id,
      tenantId: alert.tenantId,
      ruleName: rule.name,
      metric: result.metric,
      severity: alert.severity,
      subject,
      body,
      payload: {
        alert,
        result,
        rule: {
          id: rule.id,
          name: rule.name,
        },
      },
    };
  }

  // ==========================================
  // CRUD Operations for Alert Rules
  // ==========================================

  /**
   * Crea una nueva regla de alerta
   */
  async createRule(
    tenantId: string,
    input: Omit<AlertRule, 'id' | 'tenantId' | 'createdAt' | 'updatedAt'>
  ): Promise<AlertRule> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_drift_alert_rules')
      .insert({
        tenant_id: tenantId,
        name: input.name,
        description: input.description,
        metric_name: input.metricName,
        condition_type: input.conditionType,
        threshold_value: input.thresholdValue,
        min_severity: input.minSeverity,
        notification_channels: input.notificationChannels,
        recipients: input.recipients,
        cooldown_minutes: input.cooldownMinutes,
        is_active: input.isActive,
        created_by: input.createdBy,
      })
      .select()
      .single();

    if (error) throw error;
    return this.mapRule(data);
  }

  /**
   * Actualiza una regla existente
   */
  async updateRule(
    ruleId: string,
    updates: Partial<AlertRule>
  ): Promise<AlertRule> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_drift_alert_rules')
      .update({
        name: updates.name,
        description: updates.description,
        metric_name: updates.metricName,
        condition_type: updates.conditionType,
        threshold_value: updates.thresholdValue,
        min_severity: updates.minSeverity,
        notification_channels: updates.notificationChannels,
        recipients: updates.recipients,
        cooldown_minutes: updates.cooldownMinutes,
        is_active: updates.isActive,
        updated_at: new Date().toISOString(),
      })
      .eq('id', ruleId)
      .select()
      .single();

    if (error) throw error;
    return this.mapRule(data);
  }

  /**
   * Elimina una regla
   */
  async deleteRule(ruleId: string): Promise<void> {
    const supabase = await createClient();

    const { error } = await supabase
      .from('ai_drift_alert_rules')
      .delete()
      .eq('id', ruleId);

    if (error) throw error;
  }

  /**
   * Lista reglas de un tenant
   */
  async listRules(tenantId: string): Promise<AlertRule[]> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_drift_alert_rules')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return (data || []).map(this.mapRule);
  }

  // ==========================================
  // Alert Management
  // ==========================================

  /**
   * Obtiene alertas con filtros
   */
  async getAlerts(
    tenantId: string,
    filters: {
      status?: Alert['status'];
      severity?: Alert['severity'];
      metric?: string;
      startDate?: Date;
      endDate?: Date;
      limit?: number;
      offset?: number;
    } = {}
  ): Promise<{ alerts: Alert[]; total: number }> {
    const supabase = await createClient();

    let query = supabase
      .from('ai_drift_alerts')
      .select('*', { count: 'exact' })
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false });

    if (filters.status) {
      query = query.eq('status', filters.status);
    }
    if (filters.severity) {
      query = query.eq('severity', filters.severity);
    }
    if (filters.metric) {
      query = query.eq('metric_name', filters.metric);
    }
    if (filters.startDate) {
      query = query.gte('created_at', filters.startDate.toISOString());
    }
    if (filters.endDate) {
      query = query.lte('created_at', filters.endDate.toISOString());
    }

    const limit = filters.limit || 50;
    const offset = filters.offset || 0;
    query = query.range(offset, offset + limit - 1);

    const { data, count, error } = await query;

    if (error) throw error;

    return {
      alerts: (data || []).map(this.mapAlert),
      total: count || 0,
    };
  }

  /**
   * Acknowledges una alerta
   */
  async acknowledgeAlert(
    alertId: string,
    userId: string
  ): Promise<Alert> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_drift_alerts')
      .update({
        status: 'acknowledged',
        acknowledged_at: new Date().toISOString(),
        acknowledged_by: userId,
        updated_at: new Date().toISOString(),
      })
      .eq('id', alertId)
      .select()
      .single();

    if (error) throw error;
    return this.mapAlert(data);
  }

  /**
   * Resuelve una alerta
   */
  async resolveAlert(
    alertId: string,
    userId: string,
    notes?: string
  ): Promise<Alert> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_drift_alerts')
      .update({
        status: 'resolved',
        resolved_at: new Date().toISOString(),
        resolved_by: userId,
        resolution_notes: notes,
        updated_at: new Date().toISOString(),
      })
      .eq('id', alertId)
      .select()
      .single();

    if (error) throw error;
    return this.mapAlert(data);
  }

  /**
   * Descarta una alerta
   */
  async dismissAlert(
    alertId: string,
    userId: string,
    reason?: string
  ): Promise<Alert> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_drift_alerts')
      .update({
        status: 'dismissed',
        resolved_at: new Date().toISOString(),
        resolved_by: userId,
        resolution_notes: reason ? `Dismissed: ${reason}` : 'Dismissed',
        updated_at: new Date().toISOString(),
      })
      .eq('id', alertId)
      .select()
      .single();

    if (error) throw error;
    return this.mapAlert(data);
  }

  /**
   * Obtiene resumen de alertas
   */
  async getAlertSummary(tenantId: string): Promise<AlertSummary> {
    const supabase = await createClient();

    // Contar por status
    const { data: statusCounts } = await supabase
      .from('ai_drift_alerts')
      .select('status')
      .eq('tenant_id', tenantId);

    const statusMap: Record<string, number> = {
      open: 0,
      acknowledged: 0,
      resolved: 0,
      dismissed: 0,
    };

    for (const row of statusCounts || []) {
      statusMap[row.status]++;
    }

    // Contar por severidad (solo open)
    const { data: severityCounts } = await supabase
      .from('ai_drift_alerts')
      .select('severity')
      .eq('tenant_id', tenantId)
      .eq('status', 'open');

    const bySeverity: Record<string, number> = {};
    for (const row of severityCounts || []) {
      bySeverity[row.severity] = (bySeverity[row.severity] || 0) + 1;
    }

    // Contar por mÃ©trica (solo open)
    const { data: metricCounts } = await supabase
      .from('ai_drift_alerts')
      .select('metric_name')
      .eq('tenant_id', tenantId)
      .eq('status', 'open');

    const byMetric: Record<string, number> = {};
    for (const row of metricCounts || []) {
      byMetric[row.metric_name] = (byMetric[row.metric_name] || 0) + 1;
    }

    // Calcular tendencia (Ãºltimos 7 dÃ­as vs 7 dÃ­as anteriores)
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);

    const { count: recentCount } = await supabase
      .from('ai_drift_alerts')
      .select('id', { count: 'exact', head: true })
      .eq('tenant_id', tenantId)
      .gte('created_at', weekAgo.toISOString());

    const { count: previousCount } = await supabase
      .from('ai_drift_alerts')
      .select('id', { count: 'exact', head: true })
      .eq('tenant_id', tenantId)
      .gte('created_at', twoWeeksAgo.toISOString())
      .lt('created_at', weekAgo.toISOString());

    let recentTrend: AlertSummary['recentTrend'] = 'stable';
    if ((recentCount || 0) > (previousCount || 0) * 1.2) {
      recentTrend = 'increasing';
    } else if ((recentCount || 0) < (previousCount || 0) * 0.8) {
      recentTrend = 'decreasing';
    }

    return {
      total: Object.values(statusMap).reduce((a, b) => a + b, 0),
      open: statusMap.open,
      acknowledged: statusMap.acknowledged,
      resolved: statusMap.resolved + statusMap.dismissed,
      bySeverity,
      byMetric,
      recentTrend,
    };
  }

  // ==========================================
  // Mappers
  // ==========================================

  private mapRule(row: any): AlertRule {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      name: row.name,
      description: row.description,
      metricName: row.metric_name,
      conditionType: row.condition_type,
      thresholdValue: row.threshold_value,
      minSeverity: row.min_severity,
      notificationChannels: row.notification_channels,
      recipients: row.recipients,
      cooldownMinutes: row.cooldown_minutes,
      isActive: row.is_active,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      createdBy: row.created_by,
    };
  }

  private mapAlert(row: any): Alert {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      ruleId: row.rule_id,
      driftReportId: row.drift_report_id,
      metricName: row.metric_name,
      severity: row.severity,
      statistic: row.statistic,
      pValue: row.p_value,
      details: row.details,
      status: row.status,
      acknowledgedAt: row.acknowledged_at ? new Date(row.acknowledged_at) : undefined,
      acknowledgedBy: row.acknowledged_by,
      resolvedAt: row.resolved_at ? new Date(row.resolved_at) : undefined,
      resolvedBy: row.resolved_by,
      resolutionNotes: row.resolution_notes,
      notificationsSent: row.notifications_sent,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }
}

interface NotificationContext {
  alertId: string;
  tenantId: string;
  ruleName: string;
  metric: string;
  severity: string;
  subject: string;
  body: string;
  payload: Record<string, any>;
}
```

## Notificadores

### Email Notifier

```typescript
// lib/ai-learning/drift/alerts/notifiers/email-notifier.ts

import { Resend } from 'resend';

interface NotificationContext {
  alertId: string;
  tenantId: string;
  ruleName: string;
  metric: string;
  severity: string;
  subject: string;
  body: string;
  payload: Record<string, any>;
}

export class EmailNotifier {
  private resend: Resend;
  private fromEmail: string;

  constructor() {
    this.resend = new Resend(process.env.RESEND_API_KEY);
    this.fromEmail = process.env.ALERT_FROM_EMAIL || 'alerts@tistis.com';
  }

  async send(
    email: string,
    context: NotificationContext
  ): Promise<{ success: boolean; error?: string }> {
    try {
      await this.resend.emails.send({
        from: this.fromEmail,
        to: email,
        subject: context.subject,
        html: this.buildHtmlEmail(context),
        text: context.body,
        tags: [
          { name: 'type', value: 'drift-alert' },
          { name: 'severity', value: context.severity },
          { name: 'metric', value: context.metric },
        ],
      });

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private buildHtmlEmail(context: NotificationContext): string {
    const severityColors = {
      low: '#f59e0b',
      medium: '#f97316',
      high: '#ef4444',
      critical: '#dc2626',
    };

    const color = severityColors[context.severity as keyof typeof severityColors] || '#6b7280';

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { background: ${color}; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
    .content { background: #f9fafb; padding: 20px; border-radius: 0 0 8px 8px; }
    .metric { font-size: 14px; color: #6b7280; margin-bottom: 8px; }
    .severity { display: inline-block; padding: 4px 12px; border-radius: 4px; background: ${color}; color: white; font-weight: 600; }
    .stats { background: white; padding: 16px; border-radius: 8px; margin: 16px 0; }
    .stat-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e5e7eb; }
    .stat-row:last-child { border-bottom: none; }
    .recommendations { background: #fef3c7; padding: 16px; border-radius: 8px; margin-top: 16px; }
    .recommendations h3 { color: #92400e; margin: 0 0 8px 0; }
    .recommendations ul { margin: 0; padding-left: 20px; color: #78350f; }
    .footer { text-align: center; margin-top: 20px; color: #9ca3af; font-size: 12px; }
    .btn { display: inline-block; padding: 12px 24px; background: ${color}; color: white; text-decoration: none; border-radius: 6px; margin-top: 16px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 style="margin: 0;">ğŸš¨ Drift Alert</h1>
      <p style="margin: 8px 0 0 0; opacity: 0.9;">Rule: ${context.ruleName}</p>
    </div>
    <div class="content">
      <div class="metric">
        Metric: <strong>${context.metric}</strong>
      </div>
      <div class="severity">${context.severity.toUpperCase()}</div>

      <div class="stats">
        <div class="stat-row">
          <span>Test Name</span>
          <strong>${context.payload.result?.testName || 'N/A'}</strong>
        </div>
        <div class="stat-row">
          <span>Statistic</span>
          <strong>${context.payload.result?.statistic?.toFixed(4) || 'N/A'}</strong>
        </div>
        <div class="stat-row">
          <span>P-Value</span>
          <strong>${context.payload.result?.pValue?.toFixed(4) || 'N/A'}</strong>
        </div>
        <div class="stat-row">
          <span>Confidence</span>
          <strong>${((context.payload.result?.confidence || 0) * 100).toFixed(1)}%</strong>
        </div>
      </div>

      ${context.payload.alert?.details?.recommendations?.length ? `
      <div class="recommendations">
        <h3>Recommendations</h3>
        <ul>
          ${context.payload.alert.details.recommendations.map((r: string) => `<li>${r}</li>`).join('')}
        </ul>
      </div>
      ` : ''}

      <center>
        <a href="${process.env.NEXT_PUBLIC_APP_URL}/admin/ai-learning/drift/alerts/${context.alertId}" class="btn">
          View Alert Details
        </a>
      </center>
    </div>
    <div class="footer">
      <p>TIS TIS AI Learning Drift Detection System</p>
      <p>Alert ID: ${context.alertId}</p>
    </div>
  </div>
</body>
</html>
    `;
  }
}
```

### Slack Notifier

```typescript
// lib/ai-learning/drift/alerts/notifiers/slack-notifier.ts

interface NotificationContext {
  alertId: string;
  tenantId: string;
  ruleName: string;
  metric: string;
  severity: string;
  subject: string;
  body: string;
  payload: Record<string, any>;
}

export class SlackNotifier {
  async send(
    webhookUrl: string,
    context: NotificationContext
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const severityEmoji = {
        low: 'ğŸŸ¡',
        medium: 'ğŸŸ ',
        high: 'ğŸ”´',
        critical: 'ğŸš¨',
      }[context.severity] || 'âšª';

      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          blocks: [
            {
              type: 'header',
              text: {
                type: 'plain_text',
                text: `${severityEmoji} Drift Alert: ${context.metric}`,
                emoji: true,
              },
            },
            {
              type: 'section',
              fields: [
                {
                  type: 'mrkdwn',
                  text: `*Severity:*\n${context.severity.toUpperCase()}`,
                },
                {
                  type: 'mrkdwn',
                  text: `*Rule:*\n${context.ruleName}`,
                },
                {
                  type: 'mrkdwn',
                  text: `*Statistic:*\n${context.payload.result?.statistic?.toFixed(4) || 'N/A'}`,
                },
                {
                  type: 'mrkdwn',
                  text: `*P-Value:*\n${context.payload.result?.pValue?.toFixed(4) || 'N/A'}`,
                },
              ],
            },
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `*Test:* ${context.payload.result?.testName || 'N/A'}\n*Confidence:* ${((context.payload.result?.confidence || 0) * 100).toFixed(1)}%`,
              },
            },
            ...(context.payload.alert?.details?.recommendations?.length ? [{
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `*Recommendations:*\n${context.payload.alert.details.recommendations.map((r: string) => `â€¢ ${r}`).join('\n')}`,
              },
            }] : []),
            {
              type: 'actions',
              elements: [
                {
                  type: 'button',
                  text: {
                    type: 'plain_text',
                    text: 'View Details',
                    emoji: true,
                  },
                  url: `${process.env.NEXT_PUBLIC_APP_URL}/admin/ai-learning/drift/alerts/${context.alertId}`,
                  style: 'primary',
                },
                {
                  type: 'button',
                  text: {
                    type: 'plain_text',
                    text: 'Acknowledge',
                    emoji: true,
                  },
                  url: `${process.env.NEXT_PUBLIC_APP_URL}/api/drift/alerts/${context.alertId}/acknowledge`,
                },
              ],
            },
            {
              type: 'context',
              elements: [
                {
                  type: 'mrkdwn',
                  text: `Alert ID: ${context.alertId} | Generated: <!date^${Math.floor(Date.now() / 1000)}^{date_short_pretty} {time}|${new Date().toISOString()}>`,
                },
              ],
            },
          ],
        }),
      });

      if (!response.ok) {
        const text = await response.text();
        return { success: false, error: `Slack API error: ${text}` };
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
}
```

### Webhook Notifier

```typescript
// lib/ai-learning/drift/alerts/notifiers/webhook-notifier.ts

import { createHmac } from 'crypto';

interface NotificationContext {
  alertId: string;
  tenantId: string;
  ruleName: string;
  metric: string;
  severity: string;
  subject: string;
  body: string;
  payload: Record<string, any>;
}

export class WebhookNotifier {
  async send(
    webhookUrl: string,
    context: NotificationContext
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const payload = {
        event: 'drift.alert.created',
        timestamp: new Date().toISOString(),
        alert: {
          id: context.alertId,
          tenantId: context.tenantId,
          ruleName: context.ruleName,
          metric: context.metric,
          severity: context.severity,
          testResult: context.payload.result,
        },
        recommendations: context.payload.alert?.details?.recommendations || [],
      };

      const payloadString = JSON.stringify(payload);

      // Crear firma HMAC para verificaciÃ³n
      const signature = this.createSignature(payloadString);

      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-TisTis-Signature': signature,
          'X-TisTis-Event': 'drift.alert.created',
          'X-TisTis-Delivery': context.alertId,
        },
        body: payloadString,
      });

      if (!response.ok) {
        const text = await response.text();
        return { success: false, error: `Webhook returned ${response.status}: ${text}` };
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private createSignature(payload: string): string {
    const secret = process.env.WEBHOOK_SIGNING_SECRET || 'default-secret';
    return `sha256=${createHmac('sha256', secret).update(payload).digest('hex')}`;
  }
}
```

### In-App Notifier

```typescript
// lib/ai-learning/drift/alerts/notifiers/in-app-notifier.ts

import { createClient } from '@/lib/supabase/server';

interface NotificationContext {
  alertId: string;
  tenantId: string;
  ruleName: string;
  metric: string;
  severity: string;
  subject: string;
  body: string;
  payload: Record<string, any>;
}

export class InAppNotifier {
  async send(
    userId: string,
    context: NotificationContext
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const supabase = await createClient();

      // Crear notificaciÃ³n en la tabla de notificaciones del usuario
      const { error } = await supabase.from('user_notifications').insert({
        user_id: userId,
        tenant_id: context.tenantId,
        type: 'drift_alert',
        title: context.subject,
        message: `Drift detected in ${context.metric} (${context.severity})`,
        data: {
          alertId: context.alertId,
          metric: context.metric,
          severity: context.severity,
          ruleName: context.ruleName,
        },
        link: `/admin/ai-learning/drift/alerts/${context.alertId}`,
        read: false,
      });

      if (error) {
        return { success: false, error: error.message };
      }

      // TambiÃ©n podrÃ­amos enviar un evento de Realtime aquÃ­
      // para notificaciones push instantÃ¡neas

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
}
```

## API Endpoints

```typescript
// app/api/drift/alerts/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { AlertManager } from '@/lib/ai-learning/drift/alerts/alert-manager';
import { getServerSession } from '@/lib/auth';
import { getTenantId } from '@/lib/tenant';

const alertManager = new AlertManager();

export async function GET(request: NextRequest) {
  const session = await getServerSession();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const tenantId = await getTenantId();
  const searchParams = request.nextUrl.searchParams;

  const { alerts, total } = await alertManager.getAlerts(tenantId, {
    status: searchParams.get('status') as any,
    severity: searchParams.get('severity') as any,
    metric: searchParams.get('metric') || undefined,
    limit: parseInt(searchParams.get('limit') || '50'),
    offset: parseInt(searchParams.get('offset') || '0'),
  });

  return NextResponse.json({ alerts, total });
}

// app/api/drift/alerts/[id]/acknowledge/route.ts

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const alert = await alertManager.acknowledgeAlert(params.id, session.user.id);
  return NextResponse.json({ alert });
}

// app/api/drift/alerts/[id]/resolve/route.ts

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();
  const alert = await alertManager.resolveAlert(
    params.id,
    session.user.id,
    body.notes
  );

  return NextResponse.json({ alert });
}

// app/api/drift/alerts/summary/route.ts

export async function GET() {
  const session = await getServerSession();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const tenantId = await getTenantId();
  const summary = await alertManager.getAlertSummary(tenantId);

  return NextResponse.json({ summary });
}
```

## Default Alert Rules

```typescript
// lib/ai-learning/drift/alerts/default-rules.ts

import type { AlertRule } from './types';

/**
 * Reglas de alerta predeterminadas para nuevos tenants
 */
export const DEFAULT_ALERT_RULES: Omit<AlertRule, 'id' | 'tenantId' | 'createdAt' | 'updatedAt'>[] = [
  {
    name: 'Critical Drift Alert',
    description: 'Alerta para cualquier drift de severidad crÃ­tica',
    metricName: '*', // Todas las mÃ©tricas
    conditionType: 'severity_gte',
    thresholdValue: 3, // critical = index 3
    minSeverity: 'critical',
    notificationChannels: ['email', 'slack', 'in_app'],
    recipients: [], // Se configura por tenant
    cooldownMinutes: 30,
    isActive: true,
  },
  {
    name: 'Intent Distribution Shift',
    description: 'Cambios significativos en la distribuciÃ³n de intents detectados',
    metricName: 'intent_distribution',
    conditionType: 'statistic_gte',
    thresholdValue: 0.2, // PSI >= 0.2
    minSeverity: 'medium',
    notificationChannels: ['email', 'in_app'],
    recipients: [],
    cooldownMinutes: 120,
    isActive: true,
  },
  {
    name: 'Performance Degradation',
    description: 'DegradaciÃ³n en mÃ©tricas de feedback positivo',
    metricName: 'positive_feedback_rate',
    conditionType: 'pvalue_lte',
    thresholdValue: 0.01,
    minSeverity: 'high',
    notificationChannels: ['email', 'slack', 'in_app'],
    recipients: [],
    cooldownMinutes: 60,
    isActive: true,
  },
  {
    name: 'Error Rate Spike',
    description: 'Incremento anormal en la tasa de errores',
    metricName: 'error_rate',
    conditionType: 'statistic_gte',
    thresholdValue: 5, // CUSUM threshold
    minSeverity: 'high',
    notificationChannels: ['email', 'slack', 'webhook', 'in_app'],
    recipients: [],
    cooldownMinutes: 30,
    isActive: true,
  },
];

/**
 * Crea reglas predeterminadas para un nuevo tenant
 */
export async function createDefaultRulesForTenant(
  tenantId: string,
  adminEmail: string
): Promise<void> {
  const alertManager = new AlertManager();

  for (const ruleTemplate of DEFAULT_ALERT_RULES) {
    await alertManager.createRule(tenantId, {
      ...ruleTemplate,
      recipients: [
        { type: 'email', value: adminEmail, name: 'Admin' },
        { type: 'in_app', value: 'admin', name: 'Admin Users' },
      ],
    });
  }
}
```

## Siguiente Documento

ContinÃºa con [3.4-DASHBOARD.md](./3.4-DASHBOARD.md) para la implementaciÃ³n del dashboard de monitoreo de drift.
