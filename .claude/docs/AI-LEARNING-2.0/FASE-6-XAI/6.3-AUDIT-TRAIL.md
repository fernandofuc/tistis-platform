# 6.3 Audit Trail - Explainability (XAI)

## Descripción General

El Audit Trail proporciona un registro inmutable de todas las decisiones y cambios del sistema AI para compliance, debugging, y accountability.

## Schema

```sql
-- Audit trail principal
CREATE TABLE ai_audit_trail (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),

  -- Tipo de evento
  event_type TEXT NOT NULL, -- 'decision' | 'model_change' | 'config_change' | 'feedback' | 'escalation'
  event_subtype TEXT,

  -- Actor
  actor_type TEXT NOT NULL, -- 'system' | 'user' | 'admin' | 'cron'
  actor_id UUID,
  actor_name TEXT,

  -- Recurso afectado
  resource_type TEXT NOT NULL, -- 'conversation' | 'model' | 'prompt' | 'config'
  resource_id UUID,

  -- Datos del evento
  action TEXT NOT NULL,
  before_state JSONB,
  after_state JSONB,
  metadata JSONB,

  -- Trazabilidad
  decision_log_id UUID REFERENCES ai_decision_logs(id),
  parent_event_id UUID REFERENCES ai_audit_trail(id),

  -- Inmutabilidad
  checksum TEXT NOT NULL, -- SHA256 del contenido
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Índices
CREATE INDEX idx_audit_tenant_time ON ai_audit_trail(tenant_id, created_at DESC);
CREATE INDEX idx_audit_resource ON ai_audit_trail(resource_type, resource_id);
CREATE INDEX idx_audit_actor ON ai_audit_trail(actor_type, actor_id);
CREATE INDEX idx_audit_type ON ai_audit_trail(tenant_id, event_type, created_at DESC);

-- Prevenir modificaciones
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Audit trail records cannot be modified or deleted';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_immutable
  BEFORE UPDATE OR DELETE ON ai_audit_trail
  FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();
```

## Audit Trail Service

```typescript
// lib/ai-learning/xai/audit-trail.ts

import { createClient } from '@/lib/supabase/server';
import crypto from 'crypto';

type EventType = 'decision' | 'model_change' | 'config_change' | 'feedback' | 'escalation';
type ActorType = 'system' | 'user' | 'admin' | 'cron';
type ResourceType = 'conversation' | 'model' | 'prompt' | 'config' | 'pattern';

interface AuditEvent {
  id: string;
  tenantId: string;
  eventType: EventType;
  eventSubtype?: string;
  actorType: ActorType;
  actorId?: string;
  actorName?: string;
  resourceType: ResourceType;
  resourceId?: string;
  action: string;
  beforeState?: Record<string, any>;
  afterState?: Record<string, any>;
  metadata?: Record<string, any>;
  decisionLogId?: string;
  parentEventId?: string;
  checksum: string;
  createdAt: Date;
}

interface AuditQuery {
  tenantId: string;
  eventType?: EventType;
  resourceType?: ResourceType;
  resourceId?: string;
  actorType?: ActorType;
  actorId?: string;
  startDate?: Date;
  endDate?: Date;
  limit?: number;
  offset?: number;
}

export class AuditTrailService {
  /**
   * Registra un evento de auditoría
   */
  async log(params: {
    tenantId: string;
    eventType: EventType;
    eventSubtype?: string;
    actorType: ActorType;
    actorId?: string;
    actorName?: string;
    resourceType: ResourceType;
    resourceId?: string;
    action: string;
    beforeState?: Record<string, any>;
    afterState?: Record<string, any>;
    metadata?: Record<string, any>;
    decisionLogId?: string;
    parentEventId?: string;
  }): Promise<string> {
    const supabase = await createClient();

    // Calcular checksum para inmutabilidad
    const checksum = this.calculateChecksum({
      ...params,
      timestamp: new Date().toISOString(),
    });

    const { data, error } = await supabase
      .from('ai_audit_trail')
      .insert({
        tenant_id: params.tenantId,
        event_type: params.eventType,
        event_subtype: params.eventSubtype,
        actor_type: params.actorType,
        actor_id: params.actorId,
        actor_name: params.actorName,
        resource_type: params.resourceType,
        resource_id: params.resourceId,
        action: params.action,
        before_state: params.beforeState,
        after_state: params.afterState,
        metadata: params.metadata,
        decision_log_id: params.decisionLogId,
        parent_event_id: params.parentEventId,
        checksum,
      })
      .select('id')
      .single();

    if (error) throw error;
    return data.id;
  }

  /**
   * Log de decisión AI
   */
  async logDecision(
    tenantId: string,
    decisionLogId: string,
    action: string,
    metadata?: Record<string, any>
  ): Promise<string> {
    return this.log({
      tenantId,
      eventType: 'decision',
      actorType: 'system',
      resourceType: 'conversation',
      action,
      metadata,
      decisionLogId,
    });
  }

  /**
   * Log de cambio de modelo
   */
  async logModelChange(
    tenantId: string,
    actorId: string,
    beforeModel: string,
    afterModel: string,
    reason?: string
  ): Promise<string> {
    return this.log({
      tenantId,
      eventType: 'model_change',
      actorType: 'admin',
      actorId,
      resourceType: 'model',
      action: 'model_switched',
      beforeState: { model: beforeModel },
      afterState: { model: afterModel },
      metadata: { reason },
    });
  }

  /**
   * Log de feedback
   */
  async logFeedback(
    tenantId: string,
    userId: string,
    conversationId: string,
    rating: number,
    comment?: string
  ): Promise<string> {
    return this.log({
      tenantId,
      eventType: 'feedback',
      actorType: 'user',
      actorId: userId,
      resourceType: 'conversation',
      resourceId: conversationId,
      action: 'feedback_submitted',
      afterState: { rating, comment },
    });
  }

  /**
   * Log de escalación
   */
  async logEscalation(
    tenantId: string,
    conversationId: string,
    reason: string,
    decisionLogId?: string
  ): Promise<string> {
    return this.log({
      tenantId,
      eventType: 'escalation',
      actorType: 'system',
      resourceType: 'conversation',
      resourceId: conversationId,
      action: 'escalated_to_human',
      metadata: { reason },
      decisionLogId,
    });
  }

  /**
   * Consulta eventos de auditoría
   */
  async query(params: AuditQuery): Promise<{
    events: AuditEvent[];
    total: number;
  }> {
    const supabase = await createClient();

    let query = supabase
      .from('ai_audit_trail')
      .select('*', { count: 'exact' })
      .eq('tenant_id', params.tenantId)
      .order('created_at', { ascending: false });

    if (params.eventType) {
      query = query.eq('event_type', params.eventType);
    }
    if (params.resourceType) {
      query = query.eq('resource_type', params.resourceType);
    }
    if (params.resourceId) {
      query = query.eq('resource_id', params.resourceId);
    }
    if (params.actorType) {
      query = query.eq('actor_type', params.actorType);
    }
    if (params.actorId) {
      query = query.eq('actor_id', params.actorId);
    }
    if (params.startDate) {
      query = query.gte('created_at', params.startDate.toISOString());
    }
    if (params.endDate) {
      query = query.lt('created_at', params.endDate.toISOString());
    }

    const limit = params.limit || 50;
    const offset = params.offset || 0;
    query = query.range(offset, offset + limit - 1);

    const { data, count, error } = await query;
    if (error) throw error;

    return {
      events: (data || []).map(this.mapEvent),
      total: count || 0,
    };
  }

  /**
   * Obtiene historial de un recurso
   */
  async getResourceHistory(
    tenantId: string,
    resourceType: ResourceType,
    resourceId: string
  ): Promise<AuditEvent[]> {
    const { events } = await this.query({
      tenantId,
      resourceType,
      resourceId,
      limit: 100,
    });
    return events;
  }

  /**
   * Verifica integridad del audit trail
   */
  async verifyIntegrity(eventId: string): Promise<{
    valid: boolean;
    details: string;
  }> {
    const supabase = await createClient();

    const { data: event } = await supabase
      .from('ai_audit_trail')
      .select('*')
      .eq('id', eventId)
      .single();

    if (!event) {
      return { valid: false, details: 'Event not found' };
    }

    const expectedChecksum = this.calculateChecksum({
      tenantId: event.tenant_id,
      eventType: event.event_type,
      eventSubtype: event.event_subtype,
      actorType: event.actor_type,
      actorId: event.actor_id,
      actorName: event.actor_name,
      resourceType: event.resource_type,
      resourceId: event.resource_id,
      action: event.action,
      beforeState: event.before_state,
      afterState: event.after_state,
      metadata: event.metadata,
      decisionLogId: event.decision_log_id,
      parentEventId: event.parent_event_id,
      timestamp: event.created_at,
    });

    const valid = expectedChecksum === event.checksum;

    return {
      valid,
      details: valid ? 'Checksum verified' : 'Checksum mismatch - data may have been tampered',
    };
  }

  /**
   * Exporta audit trail para compliance
   */
  async export(
    tenantId: string,
    startDate: Date,
    endDate: Date
  ): Promise<string> {
    const { events } = await this.query({
      tenantId,
      startDate,
      endDate,
      limit: 10000,
    });

    // Formato CSV
    const headers = [
      'id', 'timestamp', 'event_type', 'event_subtype',
      'actor_type', 'actor_id', 'actor_name',
      'resource_type', 'resource_id', 'action',
      'checksum'
    ];

    const rows = events.map(e => [
      e.id,
      e.createdAt.toISOString(),
      e.eventType,
      e.eventSubtype || '',
      e.actorType,
      e.actorId || '',
      e.actorName || '',
      e.resourceType,
      e.resourceId || '',
      e.action,
      e.checksum,
    ]);

    return [headers, ...rows].map(r => r.join(',')).join('\n');
  }

  private calculateChecksum(data: any): string {
    const str = JSON.stringify(data, Object.keys(data).sort());
    return crypto.createHash('sha256').update(str).digest('hex');
  }

  private mapEvent(row: any): AuditEvent {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      eventType: row.event_type,
      eventSubtype: row.event_subtype,
      actorType: row.actor_type,
      actorId: row.actor_id,
      actorName: row.actor_name,
      resourceType: row.resource_type,
      resourceId: row.resource_id,
      action: row.action,
      beforeState: row.before_state,
      afterState: row.after_state,
      metadata: row.metadata,
      decisionLogId: row.decision_log_id,
      parentEventId: row.parent_event_id,
      checksum: row.checksum,
      createdAt: new Date(row.created_at),
    };
  }
}
```

## Siguiente Documento

Continúa con [6.4-UI-COMPONENTS.md](./6.4-UI-COMPONENTS.md) para los componentes de UI de explainability.
