# 4.1 Schema Design - Feature Store

## Descripción General

El Feature Store requiere un diseño de schema cuidadoso para soportar:
- Versionado de features
- Point-in-time queries (evitar data leakage)
- Acceso eficiente tanto para training (batch) como serving (real-time)
- Multi-tenancy con aislamiento de datos

## Arquitectura del Schema

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        FEATURE STORE SCHEMA                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     FEATURE REGISTRY                                 │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │   │
│  │  │ Feature      │  │ Feature      │  │ Feature      │              │   │
│  │  │ Groups       │──│ Definitions  │──│ Versions     │              │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌────────────────────────────┐  ┌────────────────────────────────────┐   │
│  │      OFFLINE STORE         │  │       ONLINE STORE                  │   │
│  │  (PostgreSQL + Partitions) │  │    (Redis/PostgreSQL Hot)           │   │
│  │                            │  │                                     │   │
│  │  - Historical features     │  │  - Latest feature values           │   │
│  │  - Time-series data        │  │  - Low-latency access              │   │
│  │  - Batch queries           │  │  - Real-time serving               │   │
│  │  - Training data           │  │  - Point-in-time snapshots         │   │
│  └────────────────────────────┘  └────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## SQL Schema Completo

```sql
-- =====================================================
-- FEATURE REGISTRY TABLES
-- =====================================================

-- Grupos de features (organizador lógico)
CREATE TABLE ai_feature_groups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),

  -- Identificación
  name TEXT NOT NULL,
  display_name TEXT NOT NULL,
  description TEXT,

  -- Entidad principal del grupo
  entity_type TEXT NOT NULL, -- 'tenant' | 'user' | 'conversation' | 'message'
  entity_id_column TEXT NOT NULL DEFAULT 'entity_id',

  -- Configuración
  online_enabled BOOLEAN NOT NULL DEFAULT true,
  offline_enabled BOOLEAN NOT NULL DEFAULT true,
  ttl_seconds INT, -- Time-to-live para online store

  -- Estado
  status TEXT NOT NULL DEFAULT 'active', -- 'active' | 'deprecated' | 'archived'

  -- Metadata
  tags JSONB DEFAULT '[]',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES users(id),

  UNIQUE(tenant_id, name)
);

-- Definiciones individuales de features
CREATE TABLE ai_feature_definitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  group_id UUID NOT NULL REFERENCES ai_feature_groups(id) ON DELETE CASCADE,

  -- Identificación
  name TEXT NOT NULL,
  display_name TEXT NOT NULL,
  description TEXT,

  -- Tipo de dato
  data_type TEXT NOT NULL, -- 'int64' | 'float64' | 'string' | 'bool' | 'timestamp' | 'array' | 'embedding'
  embedding_dimension INT, -- Solo para tipo 'embedding'

  -- Fuente de datos
  source_type TEXT NOT NULL, -- 'batch' | 'stream' | 'on_demand'
  source_config JSONB, -- Configuración específica de la fuente

  -- Transformaciones
  transformation_sql TEXT, -- SQL para calcular el feature
  aggregation_type TEXT, -- 'sum' | 'avg' | 'count' | 'max' | 'min' | 'last' | 'first'
  window_size_seconds INT, -- Para agregaciones temporales

  -- Validaciones
  validation_rules JSONB, -- {"min": 0, "max": 100, "not_null": true}

  -- Estado
  status TEXT NOT NULL DEFAULT 'active',
  version INT NOT NULL DEFAULT 1,

  -- Metadata
  tags JSONB DEFAULT '[]',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(group_id, name, version)
);

-- Historial de versiones de features
CREATE TABLE ai_feature_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  feature_id UUID NOT NULL REFERENCES ai_feature_definitions(id) ON DELETE CASCADE,

  -- Versión
  version INT NOT NULL,
  changelog TEXT,

  -- Snapshot de la definición
  definition_snapshot JSONB NOT NULL,

  -- Estadísticas de la versión
  stats JSONB, -- {"mean": 0.5, "std": 0.1, "min": 0, "max": 1, "nulls": 0.01}

  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES users(id),

  UNIQUE(feature_id, version)
);

-- =====================================================
-- OFFLINE STORE TABLES (Historical Data)
-- =====================================================

-- Tabla principal de valores de features (particionada por tiempo)
CREATE TABLE ai_feature_values (
  id UUID DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL,
  feature_id UUID NOT NULL,

  -- Entidad
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,

  -- Valor (JSONB para flexibilidad)
  value JSONB NOT NULL,
  value_type TEXT NOT NULL, -- 'scalar' | 'vector' | 'embedding'

  -- Timestamp para point-in-time
  event_timestamp TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Partition key
  partition_key DATE NOT NULL DEFAULT CURRENT_DATE,

  PRIMARY KEY (id, partition_key)
) PARTITION BY RANGE (partition_key);

-- Crear particiones mensuales
CREATE TABLE ai_feature_values_y2024m01 PARTITION OF ai_feature_values
  FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE ai_feature_values_y2024m02 PARTITION OF ai_feature_values
  FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
-- ... continuar con más particiones

-- Función para crear particiones automáticamente
CREATE OR REPLACE FUNCTION create_feature_partition()
RETURNS void AS $$
DECLARE
  partition_date DATE;
  partition_name TEXT;
  start_date DATE;
  end_date DATE;
BEGIN
  -- Crear particiones para los próximos 3 meses
  FOR i IN 0..3 LOOP
    partition_date := date_trunc('month', CURRENT_DATE + (i || ' months')::interval);
    partition_name := 'ai_feature_values_y' || to_char(partition_date, 'YYYY') ||
                      'm' || to_char(partition_date, 'MM');
    start_date := partition_date;
    end_date := partition_date + '1 month'::interval;

    -- Verificar si ya existe
    IF NOT EXISTS (
      SELECT 1 FROM pg_class WHERE relname = partition_name
    ) THEN
      EXECUTE format(
        'CREATE TABLE %I PARTITION OF ai_feature_values
         FOR VALUES FROM (%L) TO (%L)',
        partition_name, start_date, end_date
      );

      -- Crear índices en la partición
      EXECUTE format(
        'CREATE INDEX %I ON %I (tenant_id, entity_type, entity_id, event_timestamp DESC)',
        partition_name || '_entity_idx', partition_name
      );
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Tabla para embeddings (separada por eficiencia)
CREATE TABLE ai_feature_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL,
  feature_id UUID NOT NULL REFERENCES ai_feature_definitions(id),

  -- Entidad
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,

  -- Embedding
  embedding vector(1536) NOT NULL,
  model_version TEXT NOT NULL DEFAULT 'text-embedding-3-small',

  -- Timestamp
  event_timestamp TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- ONLINE STORE TABLES (Latest Values)
-- =====================================================

-- Valores más recientes para serving en tiempo real
CREATE TABLE ai_feature_online (
  tenant_id UUID NOT NULL,
  feature_id UUID NOT NULL,
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,

  -- Valor actual
  value JSONB NOT NULL,
  value_type TEXT NOT NULL,

  -- Timestamp del valor
  event_timestamp TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- TTL (para cleanup)
  expires_at TIMESTAMPTZ,

  PRIMARY KEY (tenant_id, feature_id, entity_type, entity_id)
);

-- Embeddings online (hot cache)
CREATE TABLE ai_feature_embeddings_online (
  tenant_id UUID NOT NULL,
  feature_id UUID NOT NULL,
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,

  embedding vector(1536) NOT NULL,
  event_timestamp TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,

  PRIMARY KEY (tenant_id, feature_id, entity_type, entity_id)
);

-- =====================================================
-- MATERIALIZATION JOBS
-- =====================================================

-- Registro de jobs de materialización
CREATE TABLE ai_feature_materialization_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),

  -- Configuración
  feature_group_id UUID NOT NULL REFERENCES ai_feature_groups(id),
  job_type TEXT NOT NULL, -- 'full' | 'incremental' | 'point_in_time'

  -- Período
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,

  -- Estado
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending' | 'running' | 'completed' | 'failed'
  progress FLOAT DEFAULT 0,
  error_message TEXT,

  -- Métricas
  rows_processed BIGINT DEFAULT 0,
  rows_failed BIGINT DEFAULT 0,
  duration_ms BIGINT,

  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
);

-- =====================================================
-- INDEXES
-- =====================================================

-- Feature Registry
CREATE INDEX idx_feature_groups_tenant ON ai_feature_groups(tenant_id) WHERE status = 'active';
CREATE INDEX idx_feature_defs_group ON ai_feature_definitions(group_id) WHERE status = 'active';
CREATE INDEX idx_feature_defs_tenant ON ai_feature_definitions(tenant_id);

-- Offline Store
CREATE INDEX idx_feature_values_lookup ON ai_feature_values(tenant_id, feature_id, entity_type, entity_id, event_timestamp DESC);
CREATE INDEX idx_feature_values_time ON ai_feature_values(tenant_id, event_timestamp DESC);

-- Embeddings
CREATE INDEX idx_feature_embeddings_entity ON ai_feature_embeddings(tenant_id, entity_type, entity_id);
CREATE INDEX idx_feature_embeddings_hnsw ON ai_feature_embeddings
  USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 64);

-- Online Store (ya tiene PK, agregar index para TTL cleanup)
CREATE INDEX idx_feature_online_expires ON ai_feature_online(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX idx_feature_embeddings_online_expires ON ai_feature_embeddings_online(expires_at) WHERE expires_at IS NOT NULL;

-- Jobs
CREATE INDEX idx_materialization_jobs_status ON ai_feature_materialization_jobs(tenant_id, status, created_at DESC);

-- =====================================================
-- ROW LEVEL SECURITY
-- =====================================================

ALTER TABLE ai_feature_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_feature_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_feature_values ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_feature_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_feature_online ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_feature_embeddings_online ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_feature_materialization_jobs ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation ON ai_feature_groups
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_feature_definitions
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_feature_values
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_feature_embeddings
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_feature_online
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_feature_embeddings_online
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);

CREATE POLICY tenant_isolation ON ai_feature_materialization_jobs
  FOR ALL USING (tenant_id = current_setting('app.tenant_id')::uuid);
```

## Tipos TypeScript

```typescript
// lib/ai-learning/feature-store/types.ts

// ==========================================
// Feature Registry Types
// ==========================================

export interface FeatureGroup {
  id: string;
  tenantId: string;
  name: string;
  displayName: string;
  description?: string;
  entityType: EntityType;
  entityIdColumn: string;
  onlineEnabled: boolean;
  offlineEnabled: boolean;
  ttlSeconds?: number;
  status: 'active' | 'deprecated' | 'archived';
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
}

export type EntityType = 'tenant' | 'user' | 'conversation' | 'message';

export interface FeatureDefinition {
  id: string;
  tenantId: string;
  groupId: string;
  name: string;
  displayName: string;
  description?: string;
  dataType: FeatureDataType;
  embeddingDimension?: number;
  sourceType: 'batch' | 'stream' | 'on_demand';
  sourceConfig?: Record<string, any>;
  transformationSql?: string;
  aggregationType?: AggregationType;
  windowSizeSeconds?: number;
  validationRules?: ValidationRules;
  status: 'active' | 'deprecated';
  version: number;
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
}

export type FeatureDataType =
  | 'int64'
  | 'float64'
  | 'string'
  | 'bool'
  | 'timestamp'
  | 'array'
  | 'embedding';

export type AggregationType =
  | 'sum'
  | 'avg'
  | 'count'
  | 'max'
  | 'min'
  | 'last'
  | 'first';

export interface ValidationRules {
  min?: number;
  max?: number;
  notNull?: boolean;
  pattern?: string;
  allowedValues?: any[];
}

export interface FeatureVersion {
  id: string;
  featureId: string;
  version: number;
  changelog?: string;
  definitionSnapshot: FeatureDefinition;
  stats?: FeatureStats;
  createdAt: Date;
  createdBy?: string;
}

export interface FeatureStats {
  mean?: number;
  std?: number;
  min?: number;
  max?: number;
  nullRate?: number;
  uniqueCount?: number;
  histogram?: Record<string, number>;
}

// ==========================================
// Feature Value Types
// ==========================================

export interface FeatureValue {
  id: string;
  tenantId: string;
  featureId: string;
  entityType: EntityType;
  entityId: string;
  value: any;
  valueType: 'scalar' | 'vector' | 'embedding';
  eventTimestamp: Date;
  createdAt: Date;
}

export interface FeatureEmbedding {
  id: string;
  tenantId: string;
  featureId: string;
  entityType: EntityType;
  entityId: string;
  embedding: number[];
  modelVersion: string;
  eventTimestamp: Date;
  createdAt: Date;
}

export interface OnlineFeatureValue {
  tenantId: string;
  featureId: string;
  entityType: EntityType;
  entityId: string;
  value: any;
  valueType: 'scalar' | 'vector' | 'embedding';
  eventTimestamp: Date;
  updatedAt: Date;
  expiresAt?: Date;
}

// ==========================================
// Query Types
// ==========================================

export interface FeatureRequest {
  entityType: EntityType;
  entityId: string;
  features: string[]; // feature names
  timestamp?: Date; // for point-in-time queries (offline)
}

export interface FeatureResponse {
  entityType: EntityType;
  entityId: string;
  features: Record<string, any>;
  timestamps: Record<string, Date>;
  metadata: {
    source: 'online' | 'offline';
    latencyMs: number;
  };
}

export interface BatchFeatureRequest {
  entityType: EntityType;
  entityIds: string[];
  features: string[];
  startTime?: Date;
  endTime?: Date;
}

export interface BatchFeatureResponse {
  rows: Array<{
    entityId: string;
    eventTimestamp: Date;
    features: Record<string, any>;
  }>;
  metadata: {
    totalRows: number;
    latencyMs: number;
  };
}

export interface PointInTimeRequest {
  entityType: EntityType;
  entityTimestampPairs: Array<{
    entityId: string;
    timestamp: Date;
  }>;
  features: string[];
}

// ==========================================
// Materialization Types
// ==========================================

export interface MaterializationJob {
  id: string;
  tenantId: string;
  featureGroupId: string;
  jobType: 'full' | 'incremental' | 'point_in_time';
  startTime: Date;
  endTime: Date;
  status: 'pending' | 'running' | 'completed' | 'failed';
  progress: number;
  errorMessage?: string;
  rowsProcessed: number;
  rowsFailed: number;
  durationMs?: number;
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
}
```

## Feature Registry Service

```typescript
// lib/ai-learning/feature-store/registry.ts

import { createClient } from '@/lib/supabase/server';
import type {
  FeatureGroup,
  FeatureDefinition,
  FeatureVersion,
  EntityType,
  FeatureDataType,
  ValidationRules,
} from './types';

export class FeatureRegistry {
  // ==========================================
  // Feature Groups
  // ==========================================

  async createGroup(
    tenantId: string,
    input: {
      name: string;
      displayName: string;
      description?: string;
      entityType: EntityType;
      entityIdColumn?: string;
      onlineEnabled?: boolean;
      offlineEnabled?: boolean;
      ttlSeconds?: number;
      tags?: string[];
    }
  ): Promise<FeatureGroup> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_groups')
      .insert({
        tenant_id: tenantId,
        name: input.name,
        display_name: input.displayName,
        description: input.description,
        entity_type: input.entityType,
        entity_id_column: input.entityIdColumn || 'entity_id',
        online_enabled: input.onlineEnabled ?? true,
        offline_enabled: input.offlineEnabled ?? true,
        ttl_seconds: input.ttlSeconds,
        tags: input.tags || [],
      })
      .select()
      .single();

    if (error) throw error;
    return this.mapGroup(data);
  }

  async getGroup(groupId: string): Promise<FeatureGroup | null> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_groups')
      .select('*')
      .eq('id', groupId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }

    return this.mapGroup(data);
  }

  async listGroups(
    tenantId: string,
    options: {
      status?: string;
      entityType?: EntityType;
    } = {}
  ): Promise<FeatureGroup[]> {
    const supabase = await createClient();

    let query = supabase
      .from('ai_feature_groups')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false });

    if (options.status) {
      query = query.eq('status', options.status);
    }
    if (options.entityType) {
      query = query.eq('entity_type', options.entityType);
    }

    const { data, error } = await query;
    if (error) throw error;

    return (data || []).map(this.mapGroup);
  }

  async updateGroup(
    groupId: string,
    updates: Partial<{
      displayName: string;
      description: string;
      onlineEnabled: boolean;
      offlineEnabled: boolean;
      ttlSeconds: number;
      status: string;
      tags: string[];
    }>
  ): Promise<FeatureGroup> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_groups')
      .update({
        display_name: updates.displayName,
        description: updates.description,
        online_enabled: updates.onlineEnabled,
        offline_enabled: updates.offlineEnabled,
        ttl_seconds: updates.ttlSeconds,
        status: updates.status,
        tags: updates.tags,
        updated_at: new Date().toISOString(),
      })
      .eq('id', groupId)
      .select()
      .single();

    if (error) throw error;
    return this.mapGroup(data);
  }

  // ==========================================
  // Feature Definitions
  // ==========================================

  async createFeature(
    tenantId: string,
    groupId: string,
    input: {
      name: string;
      displayName: string;
      description?: string;
      dataType: FeatureDataType;
      embeddingDimension?: number;
      sourceType: 'batch' | 'stream' | 'on_demand';
      sourceConfig?: Record<string, any>;
      transformationSql?: string;
      aggregationType?: string;
      windowSizeSeconds?: number;
      validationRules?: ValidationRules;
      tags?: string[];
    }
  ): Promise<FeatureDefinition> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_definitions')
      .insert({
        tenant_id: tenantId,
        group_id: groupId,
        name: input.name,
        display_name: input.displayName,
        description: input.description,
        data_type: input.dataType,
        embedding_dimension: input.embeddingDimension,
        source_type: input.sourceType,
        source_config: input.sourceConfig,
        transformation_sql: input.transformationSql,
        aggregation_type: input.aggregationType,
        window_size_seconds: input.windowSizeSeconds,
        validation_rules: input.validationRules,
        tags: input.tags || [],
        version: 1,
      })
      .select()
      .single();

    if (error) throw error;

    const feature = this.mapFeature(data);

    // Crear versión inicial
    await this.createVersion(feature.id, 1, 'Initial version', feature);

    return feature;
  }

  async getFeature(featureId: string): Promise<FeatureDefinition | null> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_definitions')
      .select('*')
      .eq('id', featureId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }

    return this.mapFeature(data);
  }

  async getFeatureByName(
    tenantId: string,
    groupName: string,
    featureName: string
  ): Promise<FeatureDefinition | null> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_definitions')
      .select(`
        *,
        ai_feature_groups!inner(name)
      `)
      .eq('tenant_id', tenantId)
      .eq('ai_feature_groups.name', groupName)
      .eq('name', featureName)
      .eq('status', 'active')
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }

    return this.mapFeature(data);
  }

  async listFeatures(
    groupId: string,
    options: { status?: string } = {}
  ): Promise<FeatureDefinition[]> {
    const supabase = await createClient();

    let query = supabase
      .from('ai_feature_definitions')
      .select('*')
      .eq('group_id', groupId)
      .order('name', { ascending: true });

    if (options.status) {
      query = query.eq('status', options.status);
    }

    const { data, error } = await query;
    if (error) throw error;

    return (data || []).map(this.mapFeature);
  }

  async updateFeature(
    featureId: string,
    updates: Partial<{
      displayName: string;
      description: string;
      sourceConfig: Record<string, any>;
      transformationSql: string;
      validationRules: ValidationRules;
      status: string;
      tags: string[];
    }>,
    changelog?: string
  ): Promise<FeatureDefinition> {
    const supabase = await createClient();

    // Obtener feature actual
    const current = await this.getFeature(featureId);
    if (!current) throw new Error('Feature not found');

    // Incrementar versión si hay cambios sustanciales
    const newVersion = this.requiresNewVersion(updates) ? current.version + 1 : current.version;

    const { data, error } = await supabase
      .from('ai_feature_definitions')
      .update({
        display_name: updates.displayName,
        description: updates.description,
        source_config: updates.sourceConfig,
        transformation_sql: updates.transformationSql,
        validation_rules: updates.validationRules,
        status: updates.status,
        tags: updates.tags,
        version: newVersion,
        updated_at: new Date().toISOString(),
      })
      .eq('id', featureId)
      .select()
      .single();

    if (error) throw error;

    const updated = this.mapFeature(data);

    // Crear nueva versión si corresponde
    if (newVersion > current.version) {
      await this.createVersion(featureId, newVersion, changelog || 'Updated', updated);
    }

    return updated;
  }

  private requiresNewVersion(updates: Record<string, any>): boolean {
    const versionedFields = ['transformationSql', 'validationRules', 'sourceConfig'];
    return versionedFields.some(field => updates[field] !== undefined);
  }

  // ==========================================
  // Feature Versions
  // ==========================================

  private async createVersion(
    featureId: string,
    version: number,
    changelog: string,
    definition: FeatureDefinition
  ): Promise<void> {
    const supabase = await createClient();

    await supabase.from('ai_feature_versions').insert({
      feature_id: featureId,
      version,
      changelog,
      definition_snapshot: definition,
    });
  }

  async getVersionHistory(featureId: string): Promise<FeatureVersion[]> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_versions')
      .select('*')
      .eq('feature_id', featureId)
      .order('version', { ascending: false });

    if (error) throw error;

    return (data || []).map(row => ({
      id: row.id,
      featureId: row.feature_id,
      version: row.version,
      changelog: row.changelog,
      definitionSnapshot: row.definition_snapshot,
      stats: row.stats,
      createdAt: new Date(row.created_at),
      createdBy: row.created_by,
    }));
  }

  // ==========================================
  // Bulk Operations
  // ==========================================

  async resolveFeatureIds(
    tenantId: string,
    featureNames: string[]
  ): Promise<Map<string, string>> {
    const supabase = await createClient();

    // Parse names que pueden ser "group.feature" o solo "feature"
    const parsedNames = featureNames.map(name => {
      const parts = name.split('.');
      return parts.length === 2
        ? { group: parts[0], feature: parts[1] }
        : { group: null, feature: parts[0] };
    });

    const { data, error } = await supabase
      .from('ai_feature_definitions')
      .select(`
        id,
        name,
        ai_feature_groups!inner(name)
      `)
      .eq('tenant_id', tenantId)
      .eq('status', 'active')
      .in('name', parsedNames.map(p => p.feature));

    if (error) throw error;

    const map = new Map<string, string>();

    for (const row of data || []) {
      const groupName = (row as any).ai_feature_groups?.name;
      const fullName = `${groupName}.${row.name}`;
      map.set(fullName, row.id);
      map.set(row.name, row.id); // También mapear solo el nombre
    }

    return map;
  }

  // ==========================================
  // Mappers
  // ==========================================

  private mapGroup(row: any): FeatureGroup {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      name: row.name,
      displayName: row.display_name,
      description: row.description,
      entityType: row.entity_type,
      entityIdColumn: row.entity_id_column,
      onlineEnabled: row.online_enabled,
      offlineEnabled: row.offline_enabled,
      ttlSeconds: row.ttl_seconds,
      status: row.status,
      tags: row.tags,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      createdBy: row.created_by,
    };
  }

  private mapFeature(row: any): FeatureDefinition {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      groupId: row.group_id,
      name: row.name,
      displayName: row.display_name,
      description: row.description,
      dataType: row.data_type,
      embeddingDimension: row.embedding_dimension,
      sourceType: row.source_type,
      sourceConfig: row.source_config,
      transformationSql: row.transformation_sql,
      aggregationType: row.aggregation_type,
      windowSizeSeconds: row.window_size_seconds,
      validationRules: row.validation_rules,
      status: row.status,
      version: row.version,
      tags: row.tags,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }
}
```

## Definiciones de Features para TIS TIS

```typescript
// lib/ai-learning/feature-store/tistis-features.ts

import { FeatureRegistry } from './registry';
import type { FeatureDataType } from './types';

interface FeatureSpec {
  name: string;
  displayName: string;
  description: string;
  dataType: FeatureDataType;
  sourceType: 'batch' | 'stream' | 'on_demand';
  transformationSql?: string;
  aggregationType?: string;
  windowSizeSeconds?: number;
  validationRules?: Record<string, any>;
}

// ==========================================
// TENANT FEATURES
// ==========================================

export const TENANT_FEATURES: FeatureSpec[] = [
  {
    name: 'total_conversations',
    displayName: 'Total Conversations',
    description: 'Total number of AI conversations for the tenant',
    dataType: 'int64',
    sourceType: 'batch',
    transformationSql: `
      SELECT tenant_id as entity_id, COUNT(*) as value
      FROM ai_conversations
      WHERE created_at >= :start_time AND created_at < :end_time
      GROUP BY tenant_id
    `,
    aggregationType: 'sum',
    validationRules: { min: 0, notNull: true },
  },
  {
    name: 'avg_conversations_per_day',
    displayName: 'Average Conversations Per Day',
    description: 'Rolling 30-day average of daily conversations',
    dataType: 'float64',
    sourceType: 'batch',
    transformationSql: `
      SELECT tenant_id as entity_id,
             AVG(daily_count) as value
      FROM (
        SELECT tenant_id, DATE(created_at), COUNT(*) as daily_count
        FROM ai_conversations
        WHERE created_at >= NOW() - INTERVAL '30 days'
        GROUP BY tenant_id, DATE(created_at)
      ) daily
      GROUP BY tenant_id
    `,
    aggregationType: 'avg',
    windowSizeSeconds: 30 * 24 * 3600,
  },
  {
    name: 'positive_feedback_rate',
    displayName: 'Positive Feedback Rate',
    description: 'Percentage of positive feedback in last 7 days',
    dataType: 'float64',
    sourceType: 'batch',
    transformationSql: `
      SELECT
        tenant_id as entity_id,
        COALESCE(
          SUM(CASE WHEN rating > 0 THEN 1 ELSE 0 END)::float /
          NULLIF(COUNT(*), 0),
          0
        ) as value
      FROM ai_feedback
      WHERE created_at >= NOW() - INTERVAL '7 days'
      GROUP BY tenant_id
    `,
    windowSizeSeconds: 7 * 24 * 3600,
    validationRules: { min: 0, max: 1 },
  },
  {
    name: 'primary_language',
    displayName: 'Primary Language',
    description: 'Most common language detected in messages',
    dataType: 'string',
    sourceType: 'batch',
    transformationSql: `
      SELECT
        tenant_id as entity_id,
        MODE() WITHIN GROUP (ORDER BY metadata->>'detected_language') as value
      FROM ai_messages
      WHERE role = 'user'
        AND created_at >= NOW() - INTERVAL '30 days'
      GROUP BY tenant_id
    `,
    windowSizeSeconds: 30 * 24 * 3600,
  },
];

// ==========================================
// USER FEATURES
// ==========================================

export const USER_FEATURES: FeatureSpec[] = [
  {
    name: 'conversation_count',
    displayName: 'Conversation Count',
    description: 'Total conversations initiated by user',
    dataType: 'int64',
    sourceType: 'batch',
    transformationSql: `
      SELECT user_id as entity_id, COUNT(*) as value
      FROM ai_conversations
      WHERE created_at >= :start_time AND created_at < :end_time
      GROUP BY user_id
    `,
    aggregationType: 'count',
  },
  {
    name: 'avg_messages_per_conversation',
    displayName: 'Average Messages Per Conversation',
    description: 'Average number of messages user sends per conversation',
    dataType: 'float64',
    sourceType: 'batch',
    transformationSql: `
      SELECT
        c.user_id as entity_id,
        AVG(msg_count) as value
      FROM ai_conversations c
      JOIN (
        SELECT conversation_id, COUNT(*) as msg_count
        FROM ai_messages
        WHERE role = 'user'
        GROUP BY conversation_id
      ) m ON c.id = m.conversation_id
      GROUP BY c.user_id
    `,
    aggregationType: 'avg',
  },
  {
    name: 'preferred_channel',
    displayName: 'Preferred Channel',
    description: 'Most used communication channel (whatsapp, web, etc)',
    dataType: 'string',
    sourceType: 'batch',
    transformationSql: `
      SELECT
        user_id as entity_id,
        MODE() WITHIN GROUP (ORDER BY channel) as value
      FROM ai_conversations
      WHERE created_at >= NOW() - INTERVAL '90 days'
      GROUP BY user_id
    `,
  },
  {
    name: 'last_interaction_days',
    displayName: 'Days Since Last Interaction',
    description: 'Number of days since last conversation',
    dataType: 'int64',
    sourceType: 'on_demand',
    transformationSql: `
      SELECT
        user_id as entity_id,
        EXTRACT(DAY FROM NOW() - MAX(created_at))::int as value
      FROM ai_conversations
      GROUP BY user_id
    `,
  },
  {
    name: 'feedback_tendency',
    displayName: 'Feedback Tendency',
    description: 'User tendency to give feedback (-1 to 1)',
    dataType: 'float64',
    sourceType: 'batch',
    transformationSql: `
      SELECT
        f.user_id as entity_id,
        AVG(f.rating) as value
      FROM ai_feedback f
      GROUP BY f.user_id
    `,
    validationRules: { min: -1, max: 1 },
  },
];

// ==========================================
// CONVERSATION FEATURES
// ==========================================

export const CONVERSATION_FEATURES: FeatureSpec[] = [
  {
    name: 'message_count',
    displayName: 'Message Count',
    description: 'Total messages in conversation',
    dataType: 'int64',
    sourceType: 'stream',
    aggregationType: 'count',
  },
  {
    name: 'duration_seconds',
    displayName: 'Duration Seconds',
    description: 'Total duration of conversation in seconds',
    dataType: 'int64',
    sourceType: 'on_demand',
    transformationSql: `
      SELECT
        id as entity_id,
        EXTRACT(EPOCH FROM (
          COALESCE(updated_at, created_at) - created_at
        ))::int as value
      FROM ai_conversations
    `,
  },
  {
    name: 'primary_intent',
    displayName: 'Primary Intent',
    description: 'Most common detected intent in conversation',
    dataType: 'string',
    sourceType: 'stream',
    transformationSql: `
      SELECT
        conversation_id as entity_id,
        MODE() WITHIN GROUP (ORDER BY metadata->>'detected_intent') as value
      FROM ai_messages
      WHERE metadata->>'detected_intent' IS NOT NULL
      GROUP BY conversation_id
    `,
  },
  {
    name: 'escalated',
    displayName: 'Escalated',
    description: 'Whether conversation was escalated to human',
    dataType: 'bool',
    sourceType: 'stream',
  },
  {
    name: 'resolution_status',
    displayName: 'Resolution Status',
    description: 'Current resolution status of conversation',
    dataType: 'string',
    sourceType: 'stream',
  },
  {
    name: 'sentiment_score',
    displayName: 'Sentiment Score',
    description: 'Average sentiment score of user messages',
    dataType: 'float64',
    sourceType: 'batch',
    transformationSql: `
      SELECT
        conversation_id as entity_id,
        AVG((metadata->>'sentiment_score')::float) as value
      FROM ai_messages
      WHERE role = 'user'
        AND metadata->>'sentiment_score' IS NOT NULL
      GROUP BY conversation_id
    `,
    validationRules: { min: -1, max: 1 },
  },
];

// ==========================================
// MESSAGE FEATURES
// ==========================================

export const MESSAGE_FEATURES: FeatureSpec[] = [
  {
    name: 'length',
    displayName: 'Message Length',
    description: 'Character count of message',
    dataType: 'int64',
    sourceType: 'stream',
  },
  {
    name: 'token_count',
    displayName: 'Token Count',
    description: 'Number of tokens in message',
    dataType: 'int64',
    sourceType: 'stream',
  },
  {
    name: 'detected_intent',
    displayName: 'Detected Intent',
    description: 'Intent detected from message',
    dataType: 'string',
    sourceType: 'stream',
  },
  {
    name: 'confidence_score',
    displayName: 'Confidence Score',
    description: 'AI confidence in response',
    dataType: 'float64',
    sourceType: 'stream',
    validationRules: { min: 0, max: 1 },
  },
  {
    name: 'response_time_ms',
    displayName: 'Response Time (ms)',
    description: 'Time taken to generate response',
    dataType: 'int64',
    sourceType: 'stream',
    validationRules: { min: 0 },
  },
  {
    name: 'embedding',
    displayName: 'Message Embedding',
    description: 'Semantic embedding vector of message',
    dataType: 'embedding',
    sourceType: 'on_demand',
  },
];

/**
 * Inicializa los feature groups y definitions para un nuevo tenant
 */
export async function initializeTenantFeatures(
  tenantId: string
): Promise<void> {
  const registry = new FeatureRegistry();

  const groups = [
    { name: 'tenant', displayName: 'Tenant Features', entityType: 'tenant' as const, features: TENANT_FEATURES },
    { name: 'user', displayName: 'User Features', entityType: 'user' as const, features: USER_FEATURES },
    { name: 'conversation', displayName: 'Conversation Features', entityType: 'conversation' as const, features: CONVERSATION_FEATURES },
    { name: 'message', displayName: 'Message Features', entityType: 'message' as const, features: MESSAGE_FEATURES },
  ];

  for (const groupSpec of groups) {
    // Crear grupo
    const group = await registry.createGroup(tenantId, {
      name: groupSpec.name,
      displayName: groupSpec.displayName,
      description: `Features for ${groupSpec.entityType} entity`,
      entityType: groupSpec.entityType,
      onlineEnabled: true,
      offlineEnabled: true,
      ttlSeconds: groupSpec.entityType === 'message' ? 86400 : undefined, // 1 day TTL for messages
    });

    // Crear features
    for (const featureSpec of groupSpec.features) {
      await registry.createFeature(tenantId, group.id, {
        name: featureSpec.name,
        displayName: featureSpec.displayName,
        description: featureSpec.description,
        dataType: featureSpec.dataType,
        sourceType: featureSpec.sourceType,
        transformationSql: featureSpec.transformationSql,
        aggregationType: featureSpec.aggregationType,
        windowSizeSeconds: featureSpec.windowSizeSeconds,
        validationRules: featureSpec.validationRules,
      });
    }
  }
}
```

## Siguiente Documento

Continúa con [4.2-OFFLINE-STORE.md](./4.2-OFFLINE-STORE.md) para la implementación del Offline Store.
