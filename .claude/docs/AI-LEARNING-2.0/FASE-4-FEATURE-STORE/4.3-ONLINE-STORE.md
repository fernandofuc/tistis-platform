# 4.3 Online Store - Feature Store

## Descripción General

El Online Store proporciona acceso de baja latencia a los valores más recientes de features para serving en tiempo real durante inferencia.

## Arquitectura

```
┌─────────────────────────────────────────────────────────────────┐
│                      ONLINE STORE                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    CACHE LAYER                            │  │
│  │  ┌─────────────┐     ┌─────────────┐                     │  │
│  │  │   Redis     │ ←── │  LRU Cache  │ ← Hot Features      │  │
│  │  │   (Primary) │     │  (Memory)   │                     │  │
│  │  └──────┬──────┘     └─────────────┘                     │  │
│  │         │                                                 │  │
│  │         ▼                                                 │  │
│  │  ┌─────────────┐                                         │  │
│  │  │ PostgreSQL  │ ← Cold Features / Fallback              │  │
│  │  │ (Hot Table) │                                         │  │
│  │  └─────────────┘                                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  Target Latency: < 10ms p99                                     │
└─────────────────────────────────────────────────────────────────┘
```

## Online Store Service

```typescript
// lib/ai-learning/feature-store/online-store.ts

import { createClient } from '@/lib/supabase/server';
import { Redis } from '@upstash/redis';
import { FeatureRegistry } from './registry';
import type { OnlineFeatureValue, FeatureRequest, FeatureResponse, EntityType } from './types';

export class OnlineStore {
  private registry: FeatureRegistry;
  private redis: Redis;
  private memoryCache: Map<string, { value: any; expiresAt: number }>;
  private memoryCacheMaxSize: number = 10000;

  constructor() {
    this.registry = new FeatureRegistry();
    this.redis = Redis.fromEnv();
    this.memoryCache = new Map();
  }

  // ==========================================
  // READ OPERATIONS (Optimized for Latency)
  // ==========================================

  /**
   * Obtiene features para serving (< 10ms target)
   */
  async getFeatures(
    tenantId: string,
    request: FeatureRequest
  ): Promise<FeatureResponse> {
    const startTime = Date.now();
    const features: Record<string, any> = {};
    const timestamps: Record<string, Date> = {};

    // Resolver feature IDs
    const featureIdMap = await this.registry.resolveFeatureIds(
      tenantId,
      request.features
    );

    // Intentar obtener de cache en memoria primero
    const missingFromMemory: string[] = [];

    for (const [name, id] of featureIdMap) {
      const cacheKey = this.getCacheKey(tenantId, id, request.entityType, request.entityId);
      const cached = this.getFromMemoryCache(cacheKey);

      if (cached) {
        features[name] = cached.value;
        timestamps[name] = cached.timestamp;
      } else {
        missingFromMemory.push(name);
      }
    }

    // Si hay features faltantes, ir a Redis
    if (missingFromMemory.length > 0) {
      const redisResults = await this.getFromRedis(
        tenantId,
        missingFromMemory.map(n => featureIdMap.get(n)!),
        request.entityType,
        request.entityId
      );

      for (const [name, result] of Object.entries(redisResults)) {
        if (result) {
          features[name] = result.value;
          timestamps[name] = result.timestamp;

          // Actualizar memory cache
          const cacheKey = this.getCacheKey(
            tenantId,
            featureIdMap.get(name)!,
            request.entityType,
            request.entityId
          );
          this.setMemoryCache(cacheKey, result.value, result.timestamp);
        }
      }
    }

    // Fallback a PostgreSQL para features aún faltantes
    const stillMissing = request.features.filter(f => !(f in features));

    if (stillMissing.length > 0) {
      const pgResults = await this.getFromPostgres(
        tenantId,
        stillMissing.map(n => featureIdMap.get(n)!),
        request.entityType,
        request.entityId
      );

      for (const [featureId, result] of Object.entries(pgResults)) {
        if (result) {
          const name = this.getFeatureNameById(featureIdMap, featureId);
          if (name) {
            features[name] = result.value;
            timestamps[name] = result.timestamp;

            // Actualizar ambos caches
            await this.setFeature(
              tenantId,
              featureId,
              request.entityType,
              request.entityId,
              result.value,
              result.timestamp
            );
          }
        }
      }
    }

    return {
      entityType: request.entityType,
      entityId: request.entityId,
      features,
      timestamps,
      metadata: {
        source: stillMissing.length > 0 ? 'offline' : 'online',
        latencyMs: Date.now() - startTime,
      },
    };
  }

  /**
   * Obtiene features para múltiples entidades (batch)
   */
  async getBatchFeatures(
    tenantId: string,
    entityType: EntityType,
    entityIds: string[],
    featureNames: string[]
  ): Promise<Map<string, Record<string, any>>> {
    const results = new Map<string, Record<string, any>>();

    // Pipeline de Redis para eficiencia
    const featureIdMap = await this.registry.resolveFeatureIds(tenantId, featureNames);
    const pipeline = this.redis.pipeline();

    for (const entityId of entityIds) {
      for (const [name, featureId] of featureIdMap) {
        const key = `features:${tenantId}:${featureId}:${entityType}:${entityId}`;
        pipeline.get(key);
      }
    }

    const redisResults = await pipeline.exec();

    let idx = 0;
    for (const entityId of entityIds) {
      const features: Record<string, any> = {};

      for (const [name] of featureIdMap) {
        const result = redisResults[idx++];
        if (result) {
          features[name] = JSON.parse(result as string).value;
        }
      }

      results.set(entityId, features);
    }

    return results;
  }

  // ==========================================
  // WRITE OPERATIONS
  // ==========================================

  /**
   * Actualiza un feature en el online store
   */
  async setFeature(
    tenantId: string,
    featureId: string,
    entityType: EntityType,
    entityId: string,
    value: any,
    eventTimestamp: Date,
    ttlSeconds?: number
  ): Promise<void> {
    const feature = await this.registry.getFeature(featureId);
    const group = feature ? await this.registry.getGroup(feature.groupId) : null;
    const ttl = ttlSeconds || group?.ttlSeconds || 86400; // Default 24h

    const data = {
      value,
      timestamp: eventTimestamp.toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Escribir a Redis con TTL
    const redisKey = `features:${tenantId}:${featureId}:${entityType}:${entityId}`;
    await this.redis.set(redisKey, JSON.stringify(data), { ex: ttl });

    // Actualizar memory cache
    const cacheKey = this.getCacheKey(tenantId, featureId, entityType, entityId);
    this.setMemoryCache(cacheKey, value, eventTimestamp, ttl * 1000);

    // Escribir a PostgreSQL (async, no bloquear)
    this.writeToPostgres(tenantId, featureId, entityType, entityId, data, ttl).catch(
      err => console.error('Failed to write to PG online store:', err)
    );
  }

  /**
   * Actualiza múltiples features en batch
   */
  async setBatchFeatures(
    tenantId: string,
    updates: Array<{
      featureId: string;
      entityType: EntityType;
      entityId: string;
      value: any;
      eventTimestamp: Date;
    }>
  ): Promise<void> {
    const pipeline = this.redis.pipeline();

    for (const update of updates) {
      const data = {
        value: update.value,
        timestamp: update.eventTimestamp.toISOString(),
        updatedAt: new Date().toISOString(),
      };

      const key = `features:${tenantId}:${update.featureId}:${update.entityType}:${update.entityId}`;
      pipeline.set(key, JSON.stringify(data), { ex: 86400 });

      // Memory cache
      const cacheKey = this.getCacheKey(tenantId, update.featureId, update.entityType, update.entityId);
      this.setMemoryCache(cacheKey, update.value, update.eventTimestamp);
    }

    await pipeline.exec();
  }

  /**
   * Invalida features en cache
   */
  async invalidate(
    tenantId: string,
    featureId: string,
    entityType: EntityType,
    entityId: string
  ): Promise<void> {
    const redisKey = `features:${tenantId}:${featureId}:${entityType}:${entityId}`;
    await this.redis.del(redisKey);

    const cacheKey = this.getCacheKey(tenantId, featureId, entityType, entityId);
    this.memoryCache.delete(cacheKey);
  }

  // ==========================================
  // CACHE HELPERS
  // ==========================================

  private getCacheKey(
    tenantId: string,
    featureId: string,
    entityType: string,
    entityId: string
  ): string {
    return `${tenantId}:${featureId}:${entityType}:${entityId}`;
  }

  private getFromMemoryCache(key: string): { value: any; timestamp: Date } | null {
    const cached = this.memoryCache.get(key);
    if (!cached) return null;

    if (cached.expiresAt < Date.now()) {
      this.memoryCache.delete(key);
      return null;
    }

    return cached.value;
  }

  private setMemoryCache(
    key: string,
    value: any,
    timestamp: Date,
    ttlMs: number = 60000 // 1 minute default
  ): void {
    // Evict si está lleno (LRU simple)
    if (this.memoryCache.size >= this.memoryCacheMaxSize) {
      const firstKey = this.memoryCache.keys().next().value;
      if (firstKey) this.memoryCache.delete(firstKey);
    }

    this.memoryCache.set(key, {
      value: { value, timestamp },
      expiresAt: Date.now() + ttlMs,
    });
  }

  private async getFromRedis(
    tenantId: string,
    featureIds: string[],
    entityType: EntityType,
    entityId: string
  ): Promise<Record<string, { value: any; timestamp: Date } | null>> {
    const results: Record<string, { value: any; timestamp: Date } | null> = {};
    const pipeline = this.redis.pipeline();

    for (const featureId of featureIds) {
      const key = `features:${tenantId}:${featureId}:${entityType}:${entityId}`;
      pipeline.get(key);
    }

    const redisResults = await pipeline.exec();

    featureIds.forEach((featureId, idx) => {
      const result = redisResults[idx];
      if (result) {
        const parsed = JSON.parse(result as string);
        results[featureId] = {
          value: parsed.value,
          timestamp: new Date(parsed.timestamp),
        };
      } else {
        results[featureId] = null;
      }
    });

    return results;
  }

  private async getFromPostgres(
    tenantId: string,
    featureIds: string[],
    entityType: EntityType,
    entityId: string
  ): Promise<Record<string, { value: any; timestamp: Date } | null>> {
    const supabase = await createClient();

    const { data } = await supabase
      .from('ai_feature_online')
      .select('feature_id, value, event_timestamp')
      .eq('tenant_id', tenantId)
      .eq('entity_type', entityType)
      .eq('entity_id', entityId)
      .in('feature_id', featureIds);

    const results: Record<string, { value: any; timestamp: Date } | null> = {};

    for (const featureId of featureIds) {
      const row = (data || []).find(r => r.feature_id === featureId);
      results[featureId] = row
        ? { value: JSON.parse(row.value), timestamp: new Date(row.event_timestamp) }
        : null;
    }

    return results;
  }

  private async writeToPostgres(
    tenantId: string,
    featureId: string,
    entityType: EntityType,
    entityId: string,
    data: { value: any; timestamp: string; updatedAt: string },
    ttlSeconds: number
  ): Promise<void> {
    const supabase = await createClient();
    const expiresAt = new Date(Date.now() + ttlSeconds * 1000);

    await supabase.from('ai_feature_online').upsert({
      tenant_id: tenantId,
      feature_id: featureId,
      entity_type: entityType,
      entity_id: entityId,
      value: JSON.stringify(data.value),
      value_type: 'scalar',
      event_timestamp: data.timestamp,
      updated_at: data.updatedAt,
      expires_at: expiresAt.toISOString(),
    }, {
      onConflict: 'tenant_id,feature_id,entity_type,entity_id'
    });
  }

  private getFeatureNameById(
    featureIdMap: Map<string, string>,
    featureId: string
  ): string | null {
    for (const [name, id] of featureIdMap) {
      if (id === featureId) return name;
    }
    return null;
  }

  // ==========================================
  // MAINTENANCE
  // ==========================================

  /**
   * Limpia features expirados
   */
  async cleanupExpired(): Promise<number> {
    const supabase = await createClient();

    const { count } = await supabase
      .from('ai_feature_online')
      .delete({ count: 'exact' })
      .lt('expires_at', new Date().toISOString());

    return count || 0;
  }

  /**
   * Sincroniza desde offline store (backfill)
   */
  async syncFromOffline(
    tenantId: string,
    featureId: string,
    entityType: EntityType,
    entityIds: string[]
  ): Promise<number> {
    const supabase = await createClient();
    let synced = 0;

    // Obtener valores más recientes del offline store
    for (const entityId of entityIds) {
      const { data } = await supabase
        .from('ai_feature_values')
        .select('value, event_timestamp')
        .eq('tenant_id', tenantId)
        .eq('feature_id', featureId)
        .eq('entity_type', entityType)
        .eq('entity_id', entityId)
        .order('event_timestamp', { ascending: false })
        .limit(1)
        .single();

      if (data) {
        await this.setFeature(
          tenantId,
          featureId,
          entityType,
          entityId,
          JSON.parse(data.value),
          new Date(data.event_timestamp)
        );
        synced++;
      }
    }

    return synced;
  }
}
```

## Integración con LangGraph

```typescript
// lib/ai-learning/feature-store/langgraph-integration.ts

import { OnlineStore } from './online-store';
import type { FeatureRequest, EntityType } from './types';

/**
 * Tool para obtener features en LangGraph agents
 */
export function createFeatureStoreTool(tenantId: string) {
  const onlineStore = new OnlineStore();

  return {
    name: 'get_features',
    description: 'Get real-time features for an entity',
    parameters: {
      type: 'object',
      properties: {
        entityType: {
          type: 'string',
          enum: ['user', 'conversation', 'message'],
        },
        entityId: { type: 'string' },
        features: {
          type: 'array',
          items: { type: 'string' },
        },
      },
      required: ['entityType', 'entityId', 'features'],
    },
    handler: async (params: {
      entityType: EntityType;
      entityId: string;
      features: string[];
    }) => {
      const response = await onlineStore.getFeatures(tenantId, {
        entityType: params.entityType,
        entityId: params.entityId,
        features: params.features,
      });

      return response.features;
    },
  };
}

/**
 * Context enricher para agregar features al contexto del agent
 */
export async function enrichContextWithFeatures(
  tenantId: string,
  userId: string,
  conversationId: string,
  requestedFeatures: {
    user?: string[];
    conversation?: string[];
  }
): Promise<Record<string, any>> {
  const onlineStore = new OnlineStore();
  const context: Record<string, any> = {};

  if (requestedFeatures.user?.length) {
    const userFeatures = await onlineStore.getFeatures(tenantId, {
      entityType: 'user',
      entityId: userId,
      features: requestedFeatures.user,
    });
    context.userFeatures = userFeatures.features;
  }

  if (requestedFeatures.conversation?.length) {
    const convFeatures = await onlineStore.getFeatures(tenantId, {
      entityType: 'conversation',
      entityId: conversationId,
      features: requestedFeatures.conversation,
    });
    context.conversationFeatures = convFeatures.features;
  }

  return context;
}
```

## Siguiente Documento

Continúa con [4.4-FEATURE-PIPELINE.md](./4.4-FEATURE-PIPELINE.md) para la implementación del pipeline de features.
