# 4.4 Feature Pipeline - Feature Store

## Descripción General

El Feature Pipeline orquesta el flujo de datos desde las fuentes hasta los stores, incluyendo transformaciones, validaciones, y materialización programada.

## Arquitectura del Pipeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         FEATURE PIPELINE                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │   Sources   │───▶│  Transform  │───▶│  Validate   │───▶│   Write     │ │
│  │             │    │             │    │             │    │             │ │
│  │ - Tables    │    │ - SQL       │    │ - Schema    │    │ - Offline   │ │
│  │ - Events    │    │ - Functions │    │ - Rules     │    │ - Online    │ │
│  │ - APIs      │    │ - Windows   │    │ - Alerts    │    │ - Both      │ │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘ │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                    ORCHESTRATION                                       │ │
│  │  Batch Jobs (Cron)  │  Stream Processing  │  On-Demand Triggers       │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Feature Pipeline Service

```typescript
// lib/ai-learning/feature-store/pipeline.ts

import { createClient } from '@/lib/supabase/server';
import { FeatureRegistry } from './registry';
import { OfflineStore } from './offline-store';
import { OnlineStore } from './online-store';
import type { FeatureDefinition, FeatureGroup, MaterializationJob, EntityType } from './types';

interface PipelineConfig {
  tenantId: string;
  featureGroupId: string;
  timeRange: { start: Date; end: Date };
  mode: 'full' | 'incremental';
  writeToOnline: boolean;
  writeToOffline: boolean;
}

interface PipelineResult {
  jobId: string;
  status: 'completed' | 'failed';
  rowsProcessed: number;
  rowsFailed: number;
  durationMs: number;
  errors: string[];
}

export class FeaturePipeline {
  private registry: FeatureRegistry;
  private offlineStore: OfflineStore;
  private onlineStore: OnlineStore;

  constructor() {
    this.registry = new FeatureRegistry();
    this.offlineStore = new OfflineStore();
    this.onlineStore = new OnlineStore();
  }

  /**
   * Ejecuta el pipeline para un grupo de features
   */
  async run(config: PipelineConfig): Promise<PipelineResult> {
    const startTime = Date.now();
    const errors: string[] = [];
    let rowsProcessed = 0;
    let rowsFailed = 0;

    // Crear job de materialización
    const job = await this.createJob(config);

    try {
      // Obtener grupo y features
      const group = await this.registry.getGroup(config.featureGroupId);
      if (!group) throw new Error('Feature group not found');

      const features = await this.registry.listFeatures(config.featureGroupId, {
        status: 'active',
      });

      // Actualizar job a running
      await this.updateJobStatus(job.id, 'running');

      // Procesar cada feature
      for (const feature of features) {
        try {
          const result = await this.processFeature(config, group, feature);
          rowsProcessed += result.processed;
          rowsFailed += result.failed;

          // Actualizar progreso
          const progress = (features.indexOf(feature) + 1) / features.length;
          await this.updateJobProgress(job.id, progress, rowsProcessed);
        } catch (err) {
          errors.push(`Feature ${feature.name}: ${err}`);
          rowsFailed++;
        }
      }

      // Completar job
      await this.completeJob(job.id, rowsProcessed, rowsFailed, Date.now() - startTime);

      return {
        jobId: job.id,
        status: errors.length === 0 ? 'completed' : 'failed',
        rowsProcessed,
        rowsFailed,
        durationMs: Date.now() - startTime,
        errors,
      };
    } catch (err) {
      await this.failJob(job.id, String(err));
      throw err;
    }
  }

  /**
   * Procesa un feature individual
   */
  private async processFeature(
    config: PipelineConfig,
    group: FeatureGroup,
    feature: FeatureDefinition
  ): Promise<{ processed: number; failed: number }> {
    let processed = 0;
    let failed = 0;

    switch (feature.sourceType) {
      case 'batch':
        const batchResult = await this.processBatchFeature(config, group, feature);
        processed = batchResult.processed;
        failed = batchResult.failed;
        break;

      case 'on_demand':
        // On-demand features se calculan en tiempo real, no se materializan
        break;

      case 'stream':
        // Stream features se actualizan mediante eventos, no batch
        break;
    }

    return { processed, failed };
  }

  /**
   * Procesa feature tipo batch (SQL transformation)
   */
  private async processBatchFeature(
    config: PipelineConfig,
    group: FeatureGroup,
    feature: FeatureDefinition
  ): Promise<{ processed: number; failed: number }> {
    if (!feature.transformationSql) {
      return { processed: 0, failed: 0 };
    }

    const supabase = await createClient();

    // Preparar SQL con parámetros
    const sql = feature.transformationSql
      .replace(/:tenant_id/g, `'${config.tenantId}'`)
      .replace(/:start_time/g, `'${config.timeRange.start.toISOString()}'`)
      .replace(/:end_time/g, `'${config.timeRange.end.toISOString()}'`);

    // Ejecutar transformación
    const { data: results, error } = await supabase.rpc('execute_feature_sql', {
      p_sql: sql,
    });

    if (error) throw error;

    let processed = 0;
    let failed = 0;

    // Escribir resultados
    for (const row of results || []) {
      try {
        // Validar valor
        if (feature.validationRules) {
          this.validateValue(row.value, feature.validationRules);
        }

        // Escribir a offline store
        if (config.writeToOffline) {
          await this.offlineStore.writeFeatureValue(
            config.tenantId,
            feature.id,
            group.entityType,
            row.entity_id,
            row.value,
            config.timeRange.end
          );
        }

        // Escribir a online store
        if (config.writeToOnline && group.onlineEnabled) {
          await this.onlineStore.setFeature(
            config.tenantId,
            feature.id,
            group.entityType,
            row.entity_id,
            row.value,
            config.timeRange.end,
            group.ttlSeconds
          );
        }

        processed++;
      } catch (err) {
        console.error(`Failed to write feature value: ${err}`);
        failed++;
      }
    }

    return { processed, failed };
  }

  /**
   * Valida un valor contra las reglas definidas
   */
  private validateValue(value: any, rules: Record<string, any>): void {
    if (rules.notNull && (value === null || value === undefined)) {
      throw new Error('Value cannot be null');
    }

    if (typeof value === 'number') {
      if (rules.min !== undefined && value < rules.min) {
        throw new Error(`Value ${value} below minimum ${rules.min}`);
      }
      if (rules.max !== undefined && value > rules.max) {
        throw new Error(`Value ${value} above maximum ${rules.max}`);
      }
    }

    if (rules.allowedValues && !rules.allowedValues.includes(value)) {
      throw new Error(`Value not in allowed values`);
    }
  }

  // ==========================================
  // JOB MANAGEMENT
  // ==========================================

  private async createJob(config: PipelineConfig): Promise<MaterializationJob> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('ai_feature_materialization_jobs')
      .insert({
        tenant_id: config.tenantId,
        feature_group_id: config.featureGroupId,
        job_type: config.mode,
        start_time: config.timeRange.start.toISOString(),
        end_time: config.timeRange.end.toISOString(),
        status: 'pending',
        progress: 0,
      })
      .select()
      .single();

    if (error) throw error;
    return this.mapJob(data);
  }

  private async updateJobStatus(jobId: string, status: string): Promise<void> {
    const supabase = await createClient();
    await supabase
      .from('ai_feature_materialization_jobs')
      .update({
        status,
        started_at: status === 'running' ? new Date().toISOString() : undefined,
      })
      .eq('id', jobId);
  }

  private async updateJobProgress(
    jobId: string,
    progress: number,
    rowsProcessed: number
  ): Promise<void> {
    const supabase = await createClient();
    await supabase
      .from('ai_feature_materialization_jobs')
      .update({ progress, rows_processed: rowsProcessed })
      .eq('id', jobId);
  }

  private async completeJob(
    jobId: string,
    rowsProcessed: number,
    rowsFailed: number,
    durationMs: number
  ): Promise<void> {
    const supabase = await createClient();
    await supabase
      .from('ai_feature_materialization_jobs')
      .update({
        status: rowsFailed === 0 ? 'completed' : 'failed',
        progress: 1,
        rows_processed: rowsProcessed,
        rows_failed: rowsFailed,
        duration_ms: durationMs,
        completed_at: new Date().toISOString(),
      })
      .eq('id', jobId);
  }

  private async failJob(jobId: string, errorMessage: string): Promise<void> {
    const supabase = await createClient();
    await supabase
      .from('ai_feature_materialization_jobs')
      .update({
        status: 'failed',
        error_message: errorMessage,
        completed_at: new Date().toISOString(),
      })
      .eq('id', jobId);
  }

  private mapJob(row: any): MaterializationJob {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      featureGroupId: row.feature_group_id,
      jobType: row.job_type,
      startTime: new Date(row.start_time),
      endTime: new Date(row.end_time),
      status: row.status,
      progress: row.progress,
      errorMessage: row.error_message,
      rowsProcessed: row.rows_processed,
      rowsFailed: row.rows_failed,
      durationMs: row.duration_ms,
      createdAt: new Date(row.created_at),
      startedAt: row.started_at ? new Date(row.started_at) : undefined,
      completedAt: row.completed_at ? new Date(row.completed_at) : undefined,
    };
  }
}
```

## Cron Job para Materialización

```typescript
// app/api/cron/feature-materialization/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { FeaturePipeline } from '@/lib/ai-learning/feature-store/pipeline';

export const runtime = 'nodejs';
export const maxDuration = 300;

export async function GET(request: NextRequest) {
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const supabase = await createClient();
  const pipeline = new FeaturePipeline();

  // Obtener tenants activos
  const { data: tenants } = await supabase
    .from('tenants')
    .select('id')
    .eq('status', 'active');

  const results: any[] = [];
  const now = new Date();
  const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);

  for (const tenant of tenants || []) {
    // Obtener grupos de features activos
    const { data: groups } = await supabase
      .from('ai_feature_groups')
      .select('id')
      .eq('tenant_id', tenant.id)
      .eq('status', 'active')
      .eq('offline_enabled', true);

    for (const group of groups || []) {
      try {
        const result = await pipeline.run({
          tenantId: tenant.id,
          featureGroupId: group.id,
          timeRange: { start: hourAgo, end: now },
          mode: 'incremental',
          writeToOnline: true,
          writeToOffline: true,
        });

        results.push({
          tenantId: tenant.id,
          groupId: group.id,
          ...result,
        });
      } catch (err) {
        results.push({
          tenantId: tenant.id,
          groupId: group.id,
          status: 'error',
          error: String(err),
        });
      }
    }
  }

  return NextResponse.json({
    success: true,
    timestamp: now.toISOString(),
    results,
  });
}
```

## Event-Driven Feature Updates

```typescript
// lib/ai-learning/feature-store/event-handler.ts

import { OnlineStore } from './online-store';
import { OfflineStore } from './offline-store';
import { FeatureRegistry } from './registry';

type EventType = 'message.created' | 'conversation.created' | 'feedback.received';

interface FeatureEvent {
  type: EventType;
  tenantId: string;
  data: Record<string, any>;
  timestamp: Date;
}

export class FeatureEventHandler {
  private onlineStore: OnlineStore;
  private offlineStore: OfflineStore;
  private registry: FeatureRegistry;

  constructor() {
    this.onlineStore = new OnlineStore();
    this.offlineStore = new OfflineStore();
    this.registry = new FeatureRegistry();
  }

  /**
   * Procesa un evento y actualiza features relacionados
   */
  async handleEvent(event: FeatureEvent): Promise<void> {
    switch (event.type) {
      case 'message.created':
        await this.handleMessageCreated(event);
        break;
      case 'conversation.created':
        await this.handleConversationCreated(event);
        break;
      case 'feedback.received':
        await this.handleFeedbackReceived(event);
        break;
    }
  }

  private async handleMessageCreated(event: FeatureEvent): Promise<void> {
    const { tenantId, data, timestamp } = event;
    const { conversationId, userId, content, metadata } = data;

    // Actualizar features de mensaje
    const messageFeatures = [
      { name: 'length', value: content.length },
      { name: 'token_count', value: metadata.tokenCount || 0 },
      { name: 'detected_intent', value: metadata.intent || 'unknown' },
    ];

    for (const feature of messageFeatures) {
      const featureDef = await this.registry.getFeatureByName(
        tenantId,
        'message',
        feature.name
      );

      if (featureDef) {
        await this.onlineStore.setFeature(
          tenantId,
          featureDef.id,
          'message',
          data.messageId,
          feature.value,
          timestamp
        );
      }
    }

    // Actualizar conteo de mensajes en conversación
    await this.incrementFeature(
      tenantId,
      'conversation',
      'message_count',
      conversationId,
      timestamp
    );
  }

  private async handleConversationCreated(event: FeatureEvent): Promise<void> {
    const { tenantId, data, timestamp } = event;
    const { conversationId, userId } = data;

    // Incrementar conteo de conversaciones del usuario
    await this.incrementFeature(
      tenantId,
      'user',
      'conversation_count',
      userId,
      timestamp
    );
  }

  private async handleFeedbackReceived(event: FeatureEvent): Promise<void> {
    const { tenantId, data, timestamp } = event;
    const { userId, rating } = data;

    // Actualizar tendencia de feedback del usuario
    const featureDef = await this.registry.getFeatureByName(
      tenantId,
      'user',
      'feedback_tendency'
    );

    if (featureDef) {
      // Obtener valor actual y calcular promedio móvil
      const current = await this.onlineStore.getFeatures(tenantId, {
        entityType: 'user',
        entityId: userId,
        features: ['feedback_tendency'],
      });

      const currentValue = current.features.feedback_tendency || 0;
      const alpha = 0.3; // Factor de suavizado
      const newValue = alpha * rating + (1 - alpha) * currentValue;

      await this.onlineStore.setFeature(
        tenantId,
        featureDef.id,
        'user',
        userId,
        newValue,
        timestamp
      );
    }
  }

  private async incrementFeature(
    tenantId: string,
    entityType: 'user' | 'conversation',
    featureName: string,
    entityId: string,
    timestamp: Date
  ): Promise<void> {
    const featureDef = await this.registry.getFeatureByName(
      tenantId,
      entityType,
      featureName
    );

    if (!featureDef) return;

    // Obtener valor actual
    const current = await this.onlineStore.getFeatures(tenantId, {
      entityType,
      entityId,
      features: [featureName],
    });

    const currentValue = current.features[featureName] || 0;

    await this.onlineStore.setFeature(
      tenantId,
      featureDef.id,
      entityType,
      entityId,
      currentValue + 1,
      timestamp
    );
  }
}
```

## Fin de FASE-4

Con este documento se completa la documentación de FASE-4 Feature Store. Continúa con [FASE-5-FINETUNING](../FASE-5-FINETUNING/5.0-OVERVIEW.md) para la implementación del pipeline de Fine-tuning.
